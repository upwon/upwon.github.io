<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2-通讯录管理系统</title>
    <url>/posts/6bf45bcb.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/7865.jpg"></p>
<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<span id="more"></span>


<h2 id="1、系统需求"><a href="#1、系统需求" class="headerlink" title="1、系统需求"></a>1、系统需求</h2><p>通讯录是一个可以记录亲人、好友信息的工具。</p>
<p>系统中需要实现的功能如下：</p>
<ul>
<li>添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人</li>
<li>显示联系人：显示通讯录中所有联系人信息</li>
<li>删除联系人：按照姓名进行删除指定联系人</li>
<li>查找联系人：按照姓名查看指定联系人信息</li>
<li>修改联系人：按照姓名重新修改指定联系人</li>
<li>清空联系人：清空通讯录中所有信息</li>
<li>退出通讯录：退出当前使用的通讯录</li>
</ul>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>打开vs2017后，点击创建新项目，创建新的C++项目</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544151401138.png"></p>
<p>填写项目名称，选择项目路径</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544151579620.png"></p>
<h3 id="2-2添加文件"><a href="#2-2添加文件" class="headerlink" title="2.2添加文件"></a>2.2添加文件</h3><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544161551746.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544161648175.png"></p>
<p>添加成功后，效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544162344057.png"></p>
<p>至此，项目已创建完毕</p>
<h2 id="3、菜单功能"><a href="#3、菜单功能" class="headerlink" title="3、菜单功能"></a>3、菜单功能</h2><p><strong>功能描述：</strong> 用户选择功能的界面</p>
<p>菜单界面效果如下图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544149559893.png"></p>
<p><strong>步骤：</strong></p>
<ul>
<li>封装函数显示该界面  如 <code>void showMenu()</code></li>
<li>在main函数中调用封装好的函数</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  1、添加联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  2、显示联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  3、删除联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  4、查找联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  5、修改联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  6、清空联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  0、退出通讯录  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;***************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="4、退出功能"><a href="#4、退出功能" class="headerlink" title="4、退出功能"></a>4、退出功能</h2><p>功能描述：退出通讯录系统</p>
<p>思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建</p>
<p>当用户选择0时候，执行退出，选择其他先不做操作，也不会退出程序</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//添加联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//显示联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//删除联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//查找联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//修改联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//清空联系人</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出通讯录</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544163868043.png"></p>
<h2 id="5、添加联系人"><a href="#5、添加联系人" class="headerlink" title="5、添加联系人"></a>5、添加联系人</h2><p>功能描述：</p>
<p>实现添加联系人功能，联系人上限为1000人，联系人信息包括（姓名、性别、年龄、联系电话、家庭住址）</p>
<p>添加联系人实现步骤：</p>
<ul>
<li>设计联系人结构体</li>
<li>设计通讯录结构体</li>
<li>main函数中创建通讯录</li>
<li>封装添加联系人函数</li>
<li>测试添加联系人功能</li>
</ul>
<h3 id="5-1-设计联系人结构体"><a href="#5-1-设计联系人结构体" class="headerlink" title="5.1 设计联系人结构体"></a>5.1 设计联系人结构体</h3><p>联系人信息包括：姓名、性别、年龄、联系电话、家庭住址</p>
<p>设计如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">//string头文件</span></span></span><br><span class="line"><span class="comment">//联系人结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Sex; <span class="comment">//性别：1男 2女</span></span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//年龄</span></span><br><span class="line">	string m_Phone; <span class="comment">//电话</span></span><br><span class="line">	string m_Addr; <span class="comment">//住址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-设计通讯录结构体"><a href="#5-2-设计通讯录结构体" class="headerlink" title="5.2 设计通讯录结构体"></a>5.2 设计通讯录结构体</h3><p>设计时候可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量</p>
<p>设计如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000 <span class="comment">//最大人数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通讯录结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Addressbooks</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span> personArray[MAX]; <span class="comment">//通讯录中保存的联系人数组</span></span><br><span class="line">	<span class="type">int</span> m_Size; <span class="comment">//通讯录中人员个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-main函数中创建通讯录"><a href="#5-3-main函数中创建通讯录" class="headerlink" title="5.3 main函数中创建通讯录"></a>5.3 main函数中创建通讯录</h3><p>添加联系人函数封装好后，在main函数中创建一个通讯录变量，这个就是我们需要一直维护的通讯录</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mian函数起始位置添加：</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建通讯录</span></span><br><span class="line">	Addressbooks abs;</span><br><span class="line">	<span class="comment">//初始化通讯录中人数</span></span><br><span class="line">	abs.m_Size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>





<h3 id="5-4-封装添加联系人函数"><a href="#5-4-封装添加联系人函数" class="headerlink" title="5.4 封装添加联系人函数"></a>5.4 封装添加联系人函数</h3><p>思路：添加联系人前先判断通讯录是否已满，如果满了就不再添加，未满情况将新联系人信息逐个加入到通讯录</p>
<p>添加联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、添加联系人信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addPerson</span><span class="params">(Addressbooks *abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断电话本是否满了</span></span><br><span class="line">	<span class="keyword">if</span> (abs-&gt;m_Size == MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通讯录已满，无法添加&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//姓名</span></span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//性别</span></span><br><span class="line">		<span class="type">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span> (sex == <span class="number">1</span> || sex == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//年龄</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//联系电话</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入联系电话：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//家庭住址</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新通讯录人数</span></span><br><span class="line">		abs-&gt;m_Size++;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="5-5-测试添加联系人功能"><a href="#5-5-测试添加联系人功能" class="headerlink" title="5.5 测试添加联系人功能"></a>5.5 测试添加联系人功能</h3><p>选择界面中，如果玩家选择了1，代表添加联系人，我们可以测试下该功能</p>
<p>在switch case 语句中，case1里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//添加联系人</span></span><br><span class="line">	<span class="built_in">addPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544165554002.png"></p>
<h2 id="6、显示联系人"><a href="#6、显示联系人" class="headerlink" title="6、显示联系人"></a>6、显示联系人</h2><p>功能描述：显示通讯录中已有的联系人信息</p>
<p>显示联系人实现步骤：</p>
<ul>
<li>封装显示联系人函数</li>
<li>测试显示联系人功能</li>
</ul>
<h3 id="6-1-封装显示联系人函数"><a href="#6-1-封装显示联系人函数" class="headerlink" title="6.1 封装显示联系人函数"></a>6.1 封装显示联系人函数</h3><p>思路：判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中信息</p>
<p>显示联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、显示所有联系人信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (abs-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前记录为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; (abs-&gt;personArray[i].m_Sex == <span class="number">1</span> ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-2-测试显示联系人功能"><a href="#6-2-测试显示联系人功能" class="headerlink" title="6.2 测试显示联系人功能"></a>6.2 测试显示联系人功能</h3><p>在switch case语句中，case 2 里添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//显示联系人</span></span><br><span class="line">	<span class="built_in">showPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544166401582.png"></p>
<p align="right">
    🚀 <a href="#通讯录管理系统" target="_blank">回到顶部</a> | 
</p>

<h2 id="7、删除联系人"><a href="#7、删除联系人" class="headerlink" title="7、删除联系人"></a>7、删除联系人</h2><p>功能描述：按照姓名进行删除指定联系人</p>
<p>删除联系人实现步骤：</p>
<ul>
<li>封装检测联系人是否存在</li>
<li>封装删除联系人函数</li>
<li>测试删除联系人功能</li>
</ul>
<h3 id="7-1-封装检测联系人是否存在"><a href="#7-1-封装检测联系人是否存在" class="headerlink" title="7.1  封装检测联系人是否存在"></a>7.1  封装检测联系人是否存在</h3><p>设计思路：</p>
<p>删除联系人前，我们需要先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人</p>
<p>因此我们可以把检测联系人是否存在封装成一个函数中，如果存在，返回联系人在通讯录中的位置，不存在返回-1</p>
<p>检测联系人是否存在代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否存在查询的人员，存在返回在数组中索引位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isExist</span><span class="params">(Addressbooks * abs, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (abs-&gt;personArray[i].m_Name == name)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-2-封装删除联系人函数"><a href="#7-2-封装删除联系人函数" class="headerlink" title="7.2 封装删除联系人函数"></a>7.2 封装删除联系人函数</h3><p>根据用户输入的联系人判断该通讯录中是否有此人</p>
<p>查找到进行删除，并提示删除成功</p>
<p>查不到提示查无此人。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、删除指定联系人信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletePerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要删除的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = ret; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			abs-&gt;personArray[i] = abs-&gt;personArray[i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">         abs-&gt;m_Size--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;删除成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-测试删除联系人功能"><a href="#7-3-测试删除联系人功能" class="headerlink" title="7.3 测试删除联系人功能"></a>7.3 测试删除联系人功能</h3><p>在switch case 语句中，case3里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//删除联系人</span></span><br><span class="line">	<span class="built_in">deletePerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p>存在情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544167951559.png"></p>
<p>不存在情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544168010831.png"></p>
<h2 id="8、查找联系人"><a href="#8、查找联系人" class="headerlink" title="8、查找联系人"></a>8、查找联系人</h2><p>功能描述：按照姓名查看指定联系人信息</p>
<p>查找联系人实现步骤</p>
<ul>
<li>封装查找联系人函数</li>
<li>测试查找指定联系人</li>
</ul>
<h3 id="8-1-封装查找联系人函数"><a href="#8-1-封装查找联系人函数" class="headerlink" title="8.1 封装查找联系人函数"></a>8.1 封装查找联系人函数</h3><p>实现思路：判断用户指定的联系人是否存在，如果存在显示信息，不存在则提示查无此人。</p>
<p>查找联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4、查找指定联系人信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要查找的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Sex &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-测试查找指定联系人"><a href="#8-2-测试查找指定联系人" class="headerlink" title="8.2 测试查找指定联系人"></a>8.2 测试查找指定联系人</h3><p>在switch case 语句中，case4里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//查找联系人</span></span><br><span class="line">	<span class="built_in">findPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图</p>
<p>存在情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544170057646.png"></p>
<p>不存在情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544170254021.png"></p>
<h2 id="9、修改联系人"><a href="#9、修改联系人" class="headerlink" title="9、修改联系人"></a>9、修改联系人</h2><p>功能描述：按照姓名重新修改指定联系人</p>
<p>修改联系人实现步骤</p>
<ul>
<li>封装修改联系人函数</li>
<li>测试修改联系人功能</li>
</ul>
<h3 id="9-1-封装修改联系人函数"><a href="#9-1-封装修改联系人函数" class="headerlink" title="9.1 封装修改联系人函数"></a>9.1 封装修改联系人函数</h3><p>实现思路：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人</p>
<p>修改联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5、修改指定联系人信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您要修改的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs, name);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//姓名</span></span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs-&gt;personArray[ret].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//性别</span></span><br><span class="line">		<span class="type">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span> (sex == <span class="number">1</span> || sex == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				abs-&gt;personArray[ret].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//年龄</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs-&gt;personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//联系电话</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入联系电话：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs-&gt;personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//家庭住址</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs-&gt;personArray[ret].m_Addr = address;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;修改成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="9-2-测试修改联系人功能"><a href="#9-2-测试修改联系人功能" class="headerlink" title="9.2 测试修改联系人功能"></a>9.2 测试修改联系人功能</h3><p>在switch case 语句中，case 5里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//修改联系人</span></span><br><span class="line">	<span class="built_in">modifyPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p>查不到指定联系人情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544172265676.png"></p>
<p>查找到联系人，并修改成功：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544172164141.png"></p>
<p>再次查看通讯录，确认修改完毕</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544172228627.png"></p>
<h2 id="10、清空联系人"><a href="#10、清空联系人" class="headerlink" title="10、清空联系人"></a>10、清空联系人</h2><p>功能描述：清空通讯录中所有信息</p>
<p>清空联系人实现步骤</p>
<ul>
<li>封装清空联系人函数</li>
<li>测试清空联系人</li>
</ul>
<h3 id="10-1-封装清空联系人函数"><a href="#10-1-封装清空联系人函数" class="headerlink" title="10.1 封装清空联系人函数"></a>10.1 封装清空联系人函数</h3><p>实现思路： 将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置为0，做逻辑清空即可。</p>
<p>清空联系人代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6、清空所有联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	abs-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通讯录已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-2-测试清空联系人"><a href="#10-2-测试清空联系人" class="headerlink" title="10.2  测试清空联系人"></a>10.2  测试清空联系人</h3><p>在switch case 语句中，case 6 里添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//清空联系人</span></span><br><span class="line">	<span class="built_in">cleanPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>测试效果如图：</p>
<p>清空通讯录</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544172909693.png"></p>
<p>再次查看信息，显示记录为空</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544172943653.png"></p>
<p>至此，通讯录管理系统完成！</p>
<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<p align="right">
    🚀 <a href="#通讯录管理系统" target="_blank">回到顶部</a> | 
</p>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>1-C++基础入门</title>
    <url>/posts/d20c05ae.html</url>
    <content><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/pexels-photo-1498273.jpeg"></p>
<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li><p>创建项目</p>
</li>
<li><p>创建文件</p>
</li>
<li><p>编写代码</p>
</li>
<li><p>运行程序</p>
<span id="more"></span></li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541383178746.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541383377380.png"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541383814237.png"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541384140042.png"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541384818688.png"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，&#x3D;&#x3D;对该行代码说明&#x3D;&#x3D;</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，&#x3D;&#x3D;对该段代码做整体说明&#x3D;&#x3D;</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><p><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在文件上方定义&#x3D;&#x3D;，表示一个常量</li>
</ul>
</li>
<li><p><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p>
<ul>
<li>&#x3D;&#x3D;通常在变量定义前加关键字const&#x3D;&#x3D;，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是&#x3D;&#x3D;整数类型&#x3D;&#x3D;的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以&#x3D;&#x3D;统计数据类型所占内存大小&#x3D;&#x3D;</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 or 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p><strong>整型结论</strong>：&#x3D;&#x3D;short &lt; int &lt;&#x3D; long &lt;&#x3D; long long&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于&#x3D;&#x3D;表示小数&#x3D;&#x3D;</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>&#x2F;</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>&#96;</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些&#x3D;&#x3D;不能显示出来的ASCII字符&#x3D;&#x3D;</p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件&#x3D;&#x3D;#include&lt;string&gt;&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）</li>
</ul>
<p><strong>bool类型占&#x3D;&#x3D;1个字节&#x3D;&#x3D;大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>10 &#x2F; 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a&#x3D;2; b&#x3D;++a;</td>
<td>a&#x3D;3; b&#x3D;3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a&#x3D;2; b&#x3D;a++;</td>
<td>a&#x3D;3; b&#x3D;2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a&#x3D;2; b&#x3D;–a;</td>
<td>a&#x3D;1; b&#x3D;1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a&#x3D;2; b&#x3D;a–;</td>
<td>a&#x3D;1; b&#x3D;2;</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;2; b&#x3D;3;</td>
<td>a&#x3D;2; b&#x3D;3;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;0; a+&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;5; a-&#x3D;3;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;2; a*&#x3D;2;</td>
<td>a&#x3D;4;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;4; a&#x2F;&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3; a%2;</td>
<td>a&#x3D;1;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>相等于</td>
<td>4 &#x3D;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>4 !&#x3D; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>4 &lt;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>4 &gt;&#x3D; 1</td>
<td>1</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C和C++ 语言的比较运算中， &#x3D;&#x3D;“真”用数字“1”来表示， “假”用数字“0”来表示。&#x3D;&#x3D; </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：逻辑&#x3D;&#x3D;与&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同真为真，其余为假&#x3D;&#x3D;</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>逻辑&#x3D;&#x3D;或&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同假为假，其余为真&#x3D;&#x3D;</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D;</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image002.png"></p>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol start="2">
<li><p>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image002-1541662519170.png"></p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<ol start="3">
<li><p>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image002-1541662552695.png"></p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA.jpg"></p>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>&#x3D;&#x3D;只要循环条件的结果为真，就执行循环语句&#x3D;&#x3D;</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image002-1541668640382.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>&#x3D;&#x3D;猜数字&#x3D;&#x3D;</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/%E7%8C%9C%E6%95%B0%E5%AD%97.jpg"></p>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于&#x3D;&#x3D;do…while会先执行一次循环语句&#x3D;&#x3D;，再判断循环条件</p>
<p><img data-src="/C-plus-plus-Basics.assets/clip_image002-1541671163478.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 &#x3D; 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>详解：</strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541673704101.png"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541676003486.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/0006018857256120_b.jpg"></p>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出&#x3D;&#x3D;选择结构&#x3D;&#x3D;或者&#x3D;&#x3D;循环结构&#x3D;&#x3D;</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在&#x3D;&#x3D;循环语句&#x3D;&#x3D;中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个&#x3D;&#x3D;数据元素都是相同的数据类型&#x3D;&#x3D;</p>
<p><strong>特点2：</strong>数组是由&#x3D;&#x3D;连续的内存&#x3D;&#x3D;位置组成的</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541748375356.png"></p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] &#x3D; {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</p>
</li>
<li><p>重复以上的步骤，每次比较次数-1，直到不需要比较</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541905327273.png"></p>
</li>
</ol>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1541905559138.png"></p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用&#x3D;&#x3D;第二种更加直观，提高代码的可读性&#x3D;&#x3D;</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code> 函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，&#x3D;&#x3D;如果形参发生，并不会影响实参&#x3D;&#x3D;</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p align="right">
    🚀 <a href="#C++基础入门" target="_blank">回到顶部</a> | 
</p>





<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p>
</li>
<li><p>可以利用指针变量保存地址</p>
</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<p align="right">
    🚀 <a href="#C++基础入门" target="_blank">回到顶部</a> | 
</p>



<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户&#x3D;&#x3D;自定义的数据类型&#x3D;&#x3D;，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>









<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<p align="right">
    🚀 <a href="#C++基础入门" target="_blank">回到顶部</a> | 
</p>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>博客更改域名</title>
    <url>/posts/49394.html</url>
    <content><![CDATA[<p>本博客今日起更改域名为 <strong><a href="https://www.lifeee.top/">www.lifeee.top</a></strong></p>
<p>以下域名均跳转至 <a href="https://www.lifeee.top/">www.lifeee.top</a></p>
<ul>
<li><a href="https://upwon.github.io/">https://upwon.github.io/</a></li>
<li><a href="https://summerblog.netlify.app/">summerblog.netlify.app</a></li>
<li><a href="https://lifeee.top/">https://lifeee.top</a></li>
</ul>
<p>只是更新域名后网站的访问人数清零了。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/5 - 7c9377a88226cffcf55584d4b0014a90f703eab5.jpg" style="zoom:80%;" />

<br />




]]></content>
      <categories>
        <category>技术</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>提取3GPP LTE/5GNR中RRC的ASN.1</title>
    <url>/posts/61877.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529230039.jpeg"></p>
<p>本文介绍了如何从 3GPP 36.331 或者 38.331 中提取出 RRC 中的 ASN.1 部分抽象描述内容。</p>
<span id="more"></span>









<h1 id="ASN-1-标准简介"><a href="#ASN-1-标准简介" class="headerlink" title="ASN.1 标准简介"></a>ASN.1 标准简介</h1><p>在电信和计算机网络领域，<strong>ASN.1</strong>（<strong>Abstract Syntax Notation One</strong>) 是一套标准，是描述数据、编码、传输、解码的灵活的抽象语义记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。</p>
<br/>

<h2 id="ASN-1-标准下载"><a href="#ASN-1-标准下载" class="headerlink" title="ASN.1  标准下载"></a>ASN.1  标准下载</h2><p>描述ASN.1记法的标准：</p>
<ul>
<li><p>ITU-T Rec. X.680 | ISO&#x2F;IEC 8824-1</p>
</li>
<li><p>ITU-T Rec. X.681 | ISO&#x2F;IEC 8824-2</p>
</li>
<li><p>ITU-T Rec. X.682 | ISO&#x2F;IEC 8824-3</p>
</li>
<li><p>ITU-T Rec. X.683 | ISO&#x2F;IEC 8824-4</p>
</li>
</ul>
<p><a href="http://www.itu.int/ITU-T/studygroups/com17/languages/">从ITU-T网站免费下载</a></p>
<p>描述ASN.1编码规则的标准</p>
<ul>
<li>ITU-T Rec. X.690 | ISO&#x2F;IEC 8825-1 (BER, CER and DER)</li>
<li>ITU-T Rec. X.691 | ISO&#x2F;IEC 8825-2 (PER)</li>
<li>ITU-T Rec. X.692 | ISO&#x2F;IEC 8825-3 (ECN)</li>
<li>ITU-T Rec. X.693 | ISO&#x2F;IEC 8825-4 (XER)</li>
</ul>
<p><a href="https://web.archive.org/web/20050930230347/http://asn1.elibel.tm.fr/standards/">ASN.1标准列表</a></p>
<blockquote>
<p>关于 ASN.1的标准，可以在 ISO&#x2F;ITU-T 中找到关于本部分标准的链接，打开 <a href="http://www.itu.int/ITU-T/recommendations/index.aspx">http://www.itu.int/ITU-T/recommendations/index.aspx</a>  在 search 栏输入 x.680~x.683 或 x.690 可以查看到 ASN.1 的具体标准及编解码的方法，或者从 <a href="http://www.itu.int/ITU-T/studygroups/com17/languages/">http://www.itu.int/ITU-T/studygroups/com17/languages/</a> 获得相关文档</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529224451.png" style="zoom:50%;" />

<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529225240.png" style="zoom:50%;" />


</blockquote>
<br/>



<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p><a href="https://www.wikiwand.com/zh-cn/Foo">Foo</a>Protocol 结构的定义系使用 ASN.1 表示法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FooProtocol DEFINITIONS ::= BEGIN</span><br><span class="line"></span><br><span class="line">    FooQuestion ::= SEQUENCE &#123;</span><br><span class="line">        trackingNumber INTEGER,</span><br><span class="line">        question       IA5String</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FooAnswer ::= SEQUENCE &#123;</span><br><span class="line">        questionNumber INTEGER,</span><br><span class="line">        answer         BOOLEAN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>ASN.1没有定义的谈话流动。 这是协议的文本描述。</p>
<p>假设消息，符合与foo的协议将被发送到接收方。这种特定的消息（PDU）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myQuestion FooQuestion ::= &#123;</span><br><span class="line">    trackingNumber     5,</span><br><span class="line">    question           &quot;Anybody there?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要通过网络发送上述消息，需要编码成位元字串（string of bits）。ASN.1定义了不同的算法来完成这项任务，被称为编码规则。有很多，最简单的一个是DER.</p>
<p>Foo协议规范应明确名称一套编码规则的使用，Foo的协议，使用者 知道他们应该使用哪一个。</p>
<br/>

<h2 id="下载3GPP协议"><a href="#下载3GPP协议" class="headerlink" title="下载3GPP协议"></a>下载3GPP协议</h2><p>打开<a href="https://www.3gpp.org/ftp/Specs/archive">https://www.3gpp.org/ftp/Specs/archive</a></p>
<p>比如下载 <code>38.331</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529162852626.png"></p>
<div class="note info"><p>5G NR 的无线资源控制(RRC)协议是 38.331</p>
<p>LTE 的无线资源控制(RRC)协议是 36.331</p>
</div>

<br/>

<p>协议中的 ASN.1 描述长这个样子 😎</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530151548.png"></p>
<p>当然你可以手动复制粘贴出来，但是这样效率低下，浪费时间。因此推荐使用工具或者自己用代码来提取。具体方法请继续往下看哦 🌱</p>
<br/>

<h2 id="转换工具下载"><a href="#转换工具下载" class="headerlink" title="转换工具下载"></a>转换工具下载</h2><p>在 <a href="https://github.com/Dybinx/txt2asn1">https://github.com/Dybinx/txt2asn1</a> 中下载 txt2asn1 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200529115445.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529115520938.png" alt="下载好的工具 txt2asn1.exe"></p>
<br/>

<h2 id="开始转换为-ASN-1"><a href="#开始转换为-ASN-1" class="headerlink" title="开始转换为 ASN.1"></a>开始转换为 ASN.1</h2><p>下载好 38.331或者36.331，在 <code>word</code> 中打开协议，选择另存为，将其保存为 TXT 格式。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529115152665.png" alt="另存为txt"></p>
<p>在  txt2asn1 所在的路径下打开终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">txt2asn1.exe 待转换txt文件路径</span><br></pre></td></tr></table></figure>

<p>就能转换得到 ASN1文件了。</p>
<p>比如我输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">txt2asn1.exe 36331-g00.txt</span><br></pre></td></tr></table></figure>

<p>就能获得 <code>36331-g00.asn1</code> 文件了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529120250918.png" alt="转换成功"></p>
<br/>

<p>在 <code>VS Code</code> 打开生成的文件看一看 ，效果美滋滋 🍦</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529120447300.png" alt="image-20200529120447300"></p>
<p>推荐在  <code>VS Code</code> 中安装 <code>ASN.1 VS Code Extension</code> ，格式化后的 <code>ASN.1</code> 即美观又方便查看。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200529120533267.png" alt="安装的拓展"></p>
<p>阅读过程中，可以按住 <kbd>Ctrl</kbd> 然后点击鼠标左键，就能实现在一些配置信息之间跳转。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200529140532.gif" alt="跳转示例"></p>
<br/>

<h2 id="转换ASN-1-方式二"><a href="#转换ASN-1-方式二" class="headerlink" title="转换ASN.1-方式二"></a>转换ASN.1-方式二</h2><p>新建一个 <code>C++</code> 项目 ，在 <code>main.cpp</code> 中粘贴如下的代码。注意把 <code>input_file</code> 的路径改一下。代码来自 <a href="https://me.csdn.net/peng_yw">peng_yw</a> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string output_file;</span><br><span class="line"></span><br><span class="line">	std::string input_file = <span class="string">&quot;D:/Project_codeing/VisualStudio/Cplusplus/3GPP-ASN.1/Get-3GPP-ASN.1/Files/36331-g00.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; input_file.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = input_file.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		output_file = input_file + <span class="string">&quot;.asn1&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		output_file = input_file + <span class="string">&quot;_.asn1&quot;</span>;</span><br><span class="line">		<span class="comment">// output_file = input_file.substr(0, pos) + &quot;.asn1&quot;;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::fstream input;</span><br><span class="line"></span><br><span class="line">	input.<span class="built_in">open</span>(input_file.<span class="built_in">c_str</span>(), std::fstream::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (input.<span class="built_in">fail</span>() == <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Please check input file is correct !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::fstream output;</span><br><span class="line"></span><br><span class="line">	output.<span class="built_in">open</span>(output_file.<span class="built_in">c_str</span>(), std::fstream::out);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (output.<span class="built_in">fail</span>() == <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;The output file can not be created here !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::string input_line;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::string &gt; vec_asn;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::string &gt;::iterator itr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> cul_asn_idle = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> cul_asn_start = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asn_state = cul_asn_idle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (std::<span class="built_in">getline</span>(input, input_line))</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cul_asn_idle == asn_state)</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (input_line.<span class="built_in">find</span>(<span class="string">&quot;-- ASN1START&quot;</span>) != std::string::npos)</span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				asn_state |= cul_asn_start;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> != (cul_asn_start &amp; asn_state))</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (input_line.<span class="built_in">find</span>(<span class="string">&quot;-- ASN1STOP&quot;</span>) != std::string::npos)</span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				asn_state = cul_asn_idle;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				vec_asn.<span class="built_in">push_back</span>(input_line);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (itr = vec_asn.<span class="built_in">begin</span>(); itr != vec_asn.<span class="built_in">end</span>(); ++itr)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		output &lt;&lt; *itr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	input.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	output.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然可以把输入参数那里不要固定死，弄成一个输入参数的程序，这样在命令行中使用的话也会很方便的。</p>
<p>编译项目后运行，然后就会在 <code>input_file</code> 的路径下产生一个后缀为 <code>.asn1</code>的文件。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gf9f1nix8ij20p50ag3z0.jpg" alt="生成的示例" style="zoom:33%;" />



<br/>

<h2 id="利用开源ASN1C库实现asn-1的编解码，生成C代码"><a href="#利用开源ASN1C库实现asn-1的编解码，生成C代码" class="headerlink" title="利用开源ASN1C库实现asn.1的编解码，生成C代码"></a>利用开源ASN1C库实现asn.1的编解码，生成C代码</h2><p>在 <a href="http://lionet.info/asn1c/download.html">http://lionet.info/asn1c/download.html</a> 中下载  <a href="http://lionet.info/soft/asn1c-0.9.21.exe">Windows installer</a> ，然后安装。</p>
<p>关于详细的使用方式可以在项目地址中查看到：<a href="https://github.com/vlm/asn1c">https://github.com/vlm/asn1c</a> 。关于这个编译器的详细的文档在 <a href="https://github.com/vlm/asn1c/blob/master/doc/asn1c-usage.pdf">doc &#x2F; asn1c-usage.pdf</a> 中。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530084146.png"></p>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在安装编译器(请参阅 <a href="https://github.com/vlm/asn1c/blob/master/INSTALL.md">INSTALL.md</a>)之后，您可以使用 asn1c 命令编译 ASN. 1规范:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asn1c &lt;module.asn1&gt;                         # Compile module</span><br></pre></td></tr></table></figure>

<p>如果多个规范包含相互依赖关系，则必须同时指定所有规范:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asn1c &lt;module1.asn1&gt; &lt;module2.asn1&gt; ...     # Compile interdependent modules</span><br></pre></td></tr></table></figure>



<h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><p>在 <code>samples</code> 文件夹下有 <code>ASN.1</code> 示例文件，就让我来测试一下吧。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530084935.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530084858.png" alt="这是我的目录结构"></p>
<p>输入以下命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asn1c -P ./samples/rfc3280-*.asn1</span><br></pre></td></tr></table></figure>



<p>在本例中，-P选项用于在标准输出上打印编译后的文本。 默认行为是asn1c编译器为在指定ASN.1模块中找到的每个ASN.1类型创建多个.c和.h文件。</p>
<p>这样就打印出来了：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530085259.png" alt="打印"></p>
<p>在使用说明 <a href="https://github.com/vlm/asn1c/blob/master/doc/asn1c-usage.pdf">asn1c-usage.pdf</a> 中有其他使用的示例。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530085738.png"></p>
<p>比如输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asn1c ./samples/rfc3280-*.asn1</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530090004.png" alt="编译"></p>
<p>编译成功，可以看到已经产生了很多的 <code>.c</code> 、 <code>.h</code> 文件。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200530090820.png" alt="编译后生成的c代码"></p>
<br />

<br />

<br />



<blockquote class="blockquote-center">
<p>《小池》</p>
<p>杨万里</p>
<p>泉眼无声惜细流，树阴照水爱晴柔。<br>小荷才露尖尖角，早有蜻蜓立上头。</p>
<p>🍉</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>5G NR 常用术语</title>
    <url>/posts/55098.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200604165231.jpeg"></p>
<center><font size=1>图片来自酷安 </center>

<p>DFT-s-OFDM到底是什么呢？mMTC又为何？您能运用SS-RSRQ于句子中吗？5G术语和缩写的数量，无止境地不断增加。阅读本文，带您了解 5G NR 中常用的术语 🌞</p>
<span id="more"></span>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=36953766&auto=0&height=66"></iframe>

<center><font size=4>🎵 & 📖</center>

<h4 id="2G"><a href="#2G" class="headerlink" title="2G"></a>2G</h4><p>第二代数字蜂窝网络，旨在取代模拟通信的第一代无线电(1G)。主要设计旨在数字语音服务。</p>
<blockquote>
<p>第二代移动通信技术，简称2G（Second Generation）。相对于前一代直接以模拟信号的方式进行语音传输，2G移动通信系统对语音系以数字化方式传输，除具有通话功能外，某些系统并引入了短信（SMS，Short message service）功能。在某些2G系统中也支持数据传输与传真，但因为速度缓慢，只适合传输量低的电子邮件、软件等信息。 </p>
<p>2G技术基本上可依照采用的多路复用（Multiplexing）技术形式分成两类：一种是基于TDMA所发展出来的系统，以GSM为代表；另一种则是基于CDMA所发展出来的系统。 </p>
<p>主要的第二代手机通信技术规格标准有： </p>
<ul>
<li>GSM：以TDMA为基础所发展、源于欧洲、目前已全球化。 </li>
<li>IDEN：以TDMA为基础所发展、美国独有的系统。被美国电信系统商Nextell使用。 </li>
<li>IS-136﹙也叫做D-AMPS﹚：基于TDMA所发展，是美国最简单的TDMA系统，用于美洲。 </li>
<li>IS-95﹙也叫做cdmaOne﹚：基于CDMA所发展、是美国最简单的CDMA系统、用于美洲和亚洲一些国家。 </li>
<li>PDC﹙Personal Digital Cellular﹚：基于TDMA所发展，仅在日本普及。<br>在美国所使用的2G GSM系统通常称为PCS（Personal Communications Service），即采用1900MHz频段的GSM1900，频段异于欧洲所采用的GSM900（原始GSM频段）与GSM1800（原称PCN）。</li>
</ul>
</blockquote>
<blockquote>
<p>Second-generation digital cellular networks used by mobile phones, designed as a replacement for analog first-generation radio (1G). Designed primarily for voice using digital standards. </p>
</blockquote>
<br />

<h4 id="3G"><a href="#3G" class="headerlink" title="3G"></a>3G</h4><p>3G第三代无线移动电信技术，由国际电信联盟(ITU)制定的2000年国际移动电信(IMT-2000)标准要求，峰值速率至少支持200kbps。 利用IP协议的移动宽带为语音电话添加了文本和图像消息。</p>
<blockquote>
<p><strong>第三代移动通信</strong>技术，简称<strong>3G</strong>（英语：<strong>3rd-Generation</strong>），规范名称<strong>IMT-2000</strong>（International Mobile Telecommunications-2000），是指支持高速数据传输的蜂窝网络移动电话技术。3G服务能够同时发送声音（通话）及信息（电子邮件、即时通信等）。3G的代表特征是提供高速数据业务，速率一般在几百kbps以上。</p>
<p>3G规范是由国际电信联盟（ITU）所制定的IMT-2000规范的最终发展结果。原先制定的3G远景，是能够以此规范达到全球通信系统的标准化。当前3G存在四种标准：<a href="https://www.wikiwand.com/zh-cn/W-CDMA">W-CDMA</a>、<a href="https://www.wikiwand.com/zh-cn/CDMA2000">CDMA2000</a>、<a href="https://www.wikiwand.com/zh-cn/TD-SCDMA">TD-SCDMA</a>、<a href="https://www.wikiwand.com/zh-cn/WiMAX">WiMAX</a>。</p>
</blockquote>
<blockquote>
<p>Third-generation wireless mobile telecommunications technology, required by International Mobile T elecommunications<br>for the year 2000 (IMT -2000) standard from International Telecommunication Union (ITU) to support at least 200 kbps at<br>peak rate. First mobile broadband utilizing IP protocols added text and image messaging to voice phone calls. </p>
</blockquote>
<br />

<h4 id="3GPP-–-3rd-Generation-Partnership-Project"><a href="#3GPP-–-3rd-Generation-Partnership-Project" class="headerlink" title="3GPP – 3rd Generation Partnership Project"></a>3GPP – 3rd Generation Partnership Project</h4><p>3GPP最初的工作范围是为<strong>第三代移动通信系统（主要是UMTS）</strong>制定全球适用技术规范和技术报告。随后工作范围得到了改进，增加了对<strong>UTRA长期演进系统</strong>的研究和标准制定。组织开发和管理移动通信标准的移动通信行业协作。 关于5G，3GPP正在不断改进5G标准。</p>
<blockquote>
<p>A mobile communications industry collaboration that organizes the development and management of mobile communications standards. With respect to 5G, 3GPP is managing the evolving 5G standards.</p>
</blockquote>
<br/>

<h4 id="4G"><a href="#4G" class="headerlink" title="4G"></a>4G</h4><p>4G第四代移动通信技术，旨在接替3G。一种移动宽带标准，旨在支持呼叫、视频、数据和Web访问的全网际协议(IP)网络。4G的性能目标是用于汽车等高速移动应用的100 Mbps，以及用于包括行人和固定位置访问在内的低移动性使用情况的1 Gbps。</p>
<blockquote>
<p>从技术标准的角度看，按照<a href="https://www.wikiwand.com/zh-cn/ITU">ITU</a>的定义，静态传输速率达到1Gbps，用户在高速移动状态下可以达到100Mbps，就可以作为4G的技术之一。</p>
<p>从运营商的角度看，除了与现有网络的可兼容性外，4G要有更高的数据吞吐量、更低时延、更低的建设和运行维护成本、更高的鉴权能力和安全能力、支持多种QoS。</p>
<p>从融和的角度看，4G意味着更多的参与方，更多技术、行业、应用的融合，不再局限于电信行业，还可以应用于金融、医疗、教育、交通等行业；通信终端能做更多的事情，例如除语音通信之外的多媒体通信、远端控制等；或许局域网、互联网、电信网、广播网、卫星网等能够融为一体组成一个通播网，无论使用什么终端，都可以享受高质量的信息服务，向宽带无线化和无线宽带化演进，使4G渗透到生活的各个范畴。</p>
<p>从用户需求的角度看，4G能为用户提供更快的速度并满足用户更多的需求。移动通信之所以从模拟到数字、从2G到4G以及将来的xG演进，最根本的推动力是用户需求由无线语音服务向无线多媒体服务转变，从而激发营运商为了提高ARPU、开拓新的频段支持用户数量的持续增长、更有效的频谱利用率以及更低的营运成本，不得不进行变革转型。</p>
<p>因此，4G描述了下列两种不同但有所重叠的概念：</p>
<ul>
<li><strong>高速的移动电话网络</strong>，速度如同计算机网络[DSL的频宽，一秒能达10 Mbit或更多。此概念曾被用来描述在无线网络上。也是目前成功的3G系统提供商所提出来的愿景。</li>
<li><strong>无限网络</strong>（Pervasive Network）技术，一个比较抽象的说法是“弥漫型”、“无定型”、“整体”的无线技术，让用户完全融入系统当中。这个概念也包括了智能无线电（Smart Radio）的技术，并能够达到更高的频谱（spectrum use）和传输力量。此外，也能过滤、传输大量消息。</li>
</ul>
</blockquote>
<blockquote>
<p>Fourth-generation mobile telecommunications technology, designed to succeed 3G. A mobile broadband standard<br>designed to support an all Internet Protocol (IP) network for calls, video, data, and web access. The performance goals of<br>4G are 100 Mbps for high-speed mobile applications such as automobiles, and 1 Gbps for low-mobility use cases including<br>pedestrians and fixed-location access.</p>
</blockquote>
<br/>

<h4 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h4><p>5G第五代移动通信技术，国际移动T电子通信2020年(IMT-2020)标准要求支持全互联网协议(IP)网络。支持更快的数据速率、更高的连接密度和更低的延迟。</p>
<blockquote>
<p><strong>第五代移动通信技术</strong>（英语：5th generation mobile networks 或 5th generation wireless systems，简称<strong>5G</strong>）是最新一代移动通信技术，为4G（<a href="https://www.wikiwand.com/zh-cn/%E9%80%B2%E9%9A%8E%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE-A</a>、 <a href="https://www.wikiwand.com/zh-cn/IEEE_802.16">WiMAX-A</a>）系统后的延伸。5G的性能目标是高数据速率、减少延迟、节省能源、降低成本、提高系统容量和大规模设备连接。Release-15中的5G规范的第一阶段是为了适应早期的商业部署。Release-16的第二阶段将于2020年4月完成，作为IMT-2020技术的候选提交给国际电信联盟ITU）。</p>
<p>ITU IMT-2020规范要求速度高达20 Gbit&#x2F;s，可以实现宽信道带宽和大容量<a href="https://www.wikiwand.com/zh-cn/MIMO">MIMO</a>。第三代合作伙伴计划3GPP将提交<a href="https://www.wikiwand.com/zh-cn/5G%E6%96%B0%E6%97%A0%E7%BA%BF">5G NR</a>（新无线电）作为其5G通信标准提案。5G NR可包括低频（FR1），低于6 GHz和更高频率（FR2），高于24 GHz和<a href="https://www.wikiwand.com/zh-cn/%E6%A5%B5%E9%AB%98%E9%A0%BB">毫米波</a>范围。在早期发展时，在4G硬件（非独立）上使用5G NR软件的速度和延迟相较新一代4G系统只拥有约25％到50％的改善幅度。独立eMBB部署的仿真显示，在FR1范围内，吞吐量提高了2.5倍，在FR2范围内提高了近20倍。</p>
<p>当前，提供5G无线硬件与系统的公司有：<a href="https://www.wikiwand.com/zh-cn/%E8%8F%AF%E7%82%BA">华为</a>、<a href="https://www.wikiwand.com/zh-cn/%E4%B8%89%E6%98%9F%E7%94%B5%E5%AD%90">三星</a>、<a href="https://www.wikiwand.com/zh-cn/%E6%84%9B%E7%AB%8B%E4%BF%A1">爱立信</a>、<a href="https://www.wikiwand.com/zh-cn/%E9%AB%98%E9%80%9A">高通</a>、<a href="https://www.wikiwand.com/zh-cn/%E8%81%AF%E7%99%BC%E7%A7%91%E6%8A%80">联发科技</a>、<a href="https://www.wikiwand.com/zh-cn/%E8%AB%BE%E5%9F%BA%E4%BA%9E">诺基亚</a>、<a href="https://www.wikiwand.com/zh-cn/%E6%80%9D%E7%A7%91">思科</a>、<a href="https://www.wikiwand.com/zh-cn/%E7%9E%BB%E5%8D%9A%E7%B6%B2%E8%B7%AF">瞻博网络</a>、<a href="https://www.wikiwand.com/zh-cn/%E4%B8%AD%E8%88%88%E9%80%9A%E8%A8%8A">中兴</a>。</p>
</blockquote>
<blockquote>
<p>Fifth-generation of mobile telecommunications technology, required by International Mobile T elecommunications for the<br>year 2020 (IMT -2020) standard to support an all Internet  Protocol (IP) network. Supports faster data rates, higher connection density, and much lower latency. </p>
</blockquote>
<br/>

<h4 id="AAT-–-Antenna-array-tool"><a href="#AAT-–-Antenna-array-tool" class="headerlink" title="AAT – Antenna array tool"></a>AAT – Antenna array tool</h4><p>用于在测试场景中嵌入天线参数和辐射方向图的软件工具。</p>
<blockquote>
<p>Software tool for embedding antenna parameters and radiation patterns in test scenarios. </p>
</blockquote>
<br/>

<h4 id="ACP-–-Adjacent-channel-power"><a href="#ACP-–-Adjacent-channel-power" class="headerlink" title="ACP – Adjacent channel power"></a>ACP – Adjacent channel power</h4><p>邻道功率，在指定信道邻近的信道中的功率。</p>
<blockquote>
<p>The power contained in a frequency channel next to the specified channel. </p>
</blockquote>
<br/>

<h4 id="ACPR-–-Adjacent-channel-power-ratio"><a href="#ACPR-–-Adjacent-channel-power-ratio" class="headerlink" title="ACPR – Adjacent channel power ratio"></a>ACPR – Adjacent channel power ratio</h4><p>邻信道功率比(ACPR):Adjacent Channel Power Ratio是指相邻频率信道的平均功率和当前所用信道的平均功率之比。</p>
<blockquote>
<p>测量 ACPR 有两种方法。 第一种方法是找出总输出功率与相邻通道功率之比的10 ×log 对数。  第二种方法(也是更流行的方法)是在载波中心周围较小的带宽内求出输出功率与相邻信道功率的比值。 较小的带宽等于相邻信道信号的带宽。  第二种方法更受欢迎，因为它可以很容易地测量。ACPR 要求尽可能低。高 ACPR 表明已经发生了显著的光谱扩散。</p>
</blockquote>
<blockquote>
<p>The ratio of the power contained in a specified frequency<br>channel bandwidth relative to the total carrier power.</p>
</blockquote>
<h4 id="ACLR-–-Adjacent-channel-leakage-ratio"><a href="#ACLR-–-Adjacent-channel-leakage-ratio" class="headerlink" title="ACLR – Adjacent channel leakage ratio"></a>ACLR – Adjacent channel leakage ratio</h4><p>邻道泄漏比，指定信道上的发射功率与通过根升余弦滤波器后相邻信道上接收的功率之比。</p>
<blockquote>
<p>相邻信道泄漏比率(ACLR)或相邻信道功率比率(ACPR)被定义为指定信道上的发射功率与经过接收滤波器后相邻无线信道接收到的功率之比。每个无线标准具有位于不同频率偏移的相邻信道。 例如，根据3GPP 标准，ACLR 在1.6 MHz 的偏移量下不应超过 -33 dB，在3.2  MHz 的偏移量下不应超过 -43 dB。 Cdma 放大器包括两个偏移量(从载波频率)885千赫和1.98兆赫，测量值为30千赫。</p>
<p>ACLR也称为邻道功率比(ACPR).</p>
<p><a href="https://www.everythingrf.com/community/what-is-acpr-or-aclr">https://www.everythingrf.com/community/what-is-acpr-or-aclr</a></p>
</blockquote>
<blockquote>
<p>The ratio of the transmitted power on the assigned channel to the power received on the adjacent channel after passing through a root raised-cosine filter. </p>
</blockquote>
<br/>

<h4 id="AM-distortion"><a href="#AM-distortion" class="headerlink" title="AM distortion"></a>AM distortion</h4><p>由通信系统中的幅度变化引起的不期望的失真。</p>
<blockquote>
<p>调幅失真被定义为包含在解调的调幅波形的谐波中的功率与解调波形的基本分量的功率之比的平方根。</p>
<p><a href="https://cal.software.keysight.com/ESG/Help/Content/Performance_Tests/AM_Distortion_PT.htm">https://cal.software.keysight.com/ESG/Help/Content/Performance_Tests&#x2F;AM_Distortion_PT.htm</a></p>
</blockquote>
<blockquote>
<p>Undesirable distortion caused by amplitude variation in a communications system.</p>
</blockquote>
<br/>

<h4 id="AMF-–-Access-and-mobility-management-function"><a href="#AMF-–-Access-and-mobility-management-function" class="headerlink" title="AMF – Access and mobility management function"></a>AMF – Access and mobility management function</h4><p>接入和移动性管理功能</p>
<p>3GPP核心网络架构的一个组件，用于管理用户设备注册、身份验证、标识和移动性。AMF还终止非接入层信令。</p>
<blockquote>
<p>随着4 g 移动性管理实体(MME)功能的分解，5 g 核心访问和移动性管理功能(AMF)从用户设备(UE)(n 1 &#x2F; n  2)接收所有连接和会话相关信息，但只负责处理连接和移动性管理任务。 与会话管理相关的所有消息都通过  N11引用接口转发到会话管理功能(Session Management Function，SMF)。</p>
<p>移动网络由多个 AMF 实例组成，因此采用全局唯一的 AMF 标识符(GUAMI)。 UE  在它发送的第一条非接入层消息(NAS)中指定了这一点，这条消息通过无线接入网络(RAN)路由到所需的 AMF。 适用于3GPP 接入和非3GPP 接入，GUAMI 还确保来自一个 UE 的消息，通过两个接入网络注册，被转发到同一个 AMF。 非3gpp 互通功能(N3IWF)负责路由5G RAN 之外的消息。</p>
<p>从而终止来自 N1或 N2参考接口的 RAN 控制平面和 UE 流量，AMF 实现 NAS 加密和完整性保护算法。 在初始 NAS 消息之后，AMF  以等效的方式向演化包核心(EPC)基础结构中的 MME 发送身份验证和密钥协议(AKA)请求。 这先于 UE 授权过程，其中基于5G  核心服务的体系结构(SBA)统一数据管理(UDM)功能取代了家庭订阅服务器(HSS)。 这是通过 N8引用接口执行的，因此使用了基于 http &#x2F; 2服务的接口(SBI)消息总线。 最后，为了发送适用的和适当的事件信息，AMF 连接到守序拦截(LI)系统。</p>
<p>虽然信息可以以另一种方式存储，但是 AMF 通常会查询5G 基于服务架构(SBA’s)的网络存储库功能(NRF)来发现和选择可用的 SMF 实例。 这些可以通过 IP 地址或频繁限定域名(FQDN)来标识。</p>
<p>这个过程在这里有进一步的详细描述。假设负责下一代无线接入网络，AMF 负责管理下一代无线接入网络中 gNodeB (gNB)之间的移交移动性管理。 形式上称为 X2交接，在5G 中称为 Xn 交接。 这代表了  gNB 基站之间使用的更新的参考接口应用程序协议(XnAP) ，该协议在3GPP 的技术规范(TS)38.423中定义。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gffhhfr6wnj217a0itdi1.jpg" alt="image"></p>
<p><em>UE handover between source and target gNB’s within 5G infrastructures</em></p>
<p>无线资源控制(RRC)信令通过源 gNB 将数据从 UE 传输到5G 核的数据平面(用户平面 &#x2F; UPF) ，实现对信号质量的连续测量和报告。  当源节点检测到需要切换时，它将连接到目标 gNB 以开始切换过程。 一旦将隧道移动到目标 gNB，UE 就执行切换并连接到同一个目标节点。  从目标 gNB 到 AMF 发出路径切换请求，一旦确认，数据就可以从 UE 流过该目标节点，然后流到指定的 UPF。</p>
<p><a href="https://www.metaswitch.com/knowledge-center/reference/what-is-the-5g-access-and-mobility-management-function-amf">What is the 5G Access and Mobility Management Function (AMF)?</a></p>
</blockquote>
<blockquote>
<p>The Core Access and Mobility Management Function is part of the 3GPP 5G  Architecture. Its primary tasks include: Registration Management,  Connection Management, Reachability Management, Mobility Management and  various function relating to security and access management and  authorization.</p>
<p>核心访问和移动性管理功能是3GPP 5 g 架构的一部分。 它的主要任务包括: 注册管理、连接管理、可达性管理、移动性管理管理和各种与安全、访问管理和授权相关的功能。</p>
<p><a href="https://www.mpirical.com/glossary/amf-core-access-and-mobility-management-function">https://www.mpirical.com/glossary/amf-core-access-and-mobility-management-function</a></p>
</blockquote>
<blockquote>
<p>A component of the 3GPP core network architecture that<br>manages user equipment registration, authentication,<br>identification, and mobility. AMF also terminates non-access<br>stratum signaling.</p>
</blockquote>
<br/>

<h4 id="AM-PM-distortion"><a href="#AM-PM-distortion" class="headerlink" title="AM&#x2F;PM distortion"></a>AM&#x2F;PM distortion</h4><p>通常由于放大器的相位响应和输入信号的功率电平(或幅度)之间的相互作用而导致通信系统中的信号劣化的不期望失真。</p>
<blockquote>
<p>Undesirable distortion that causes signal degradation in a communications system, typically as the result of the<br>interaction between an amplifier’ s phase response and the power level (or amplitude) of the input signal.</p>
</blockquote>
<br/>

<h4 id="Antenna-reciprocity"><a href="#Antenna-reciprocity" class="headerlink" title="Antenna reciprocity"></a>Antenna reciprocity</h4><p>天线互易性指出在给定的介质中，天线的发射特性与接收特性相同。</p>
<blockquote>
<p>天线既可以用作发射天线，也可以用作接收天线。 在使用时，我们可能会遇到一个问题，即天线的性能是否会随着其工作模式的改变而改变。 幸运的是，我们不必担心这个问题。 天线不变的特性称为互易特性。</p>
<p><a href="https://www.tutorialspoint.com/antenna_theory/antenna_theory_reciprocity.htm">https://www.tutorialspoint.com/antenna_theory/antenna_theory_reciprocity.htm</a></p>
</blockquote>
<blockquote>
<p>A theory that states that the transmit properties of an antenna<br>will be identical to the receive properties of that antenna in a<br>given medium. </p>
</blockquote>
<br />

<p>AUSF – Authentication server function</p>
<p>鉴权服务器功是 5G核心网络的主要组成部分，用于促进安全流程。 AUSF对UE进行身份验证并存储身份验证密钥。</p>
<blockquote>
<p>认证和密钥管理是蜂窝网络安全的基础，因为它们在用户和网络之间提供相互认证，并派生密钥来保护信令和用户面数据。 每一代蜂窝网络始终定义至少一种身份验证方法。 例如，4G 定义了 4G 的 EPS-AKA ，5G定义了三种认证方式：5G-AKA、EAP-AKA 和 EAP-TLS 。分析显示，5G 认证通过一系列功能在 4G 认证的基础上进行了改进，包括可以支持更多用户案例的统一认证框架，更好的用户设备身份保护，增强的家庭网络控制，以及密钥派生中更多的密钥分离等。</p>
<p><a href="https://www.cablelabs.com/insights/a-comparative-introduction-to-4g-and-5g-authentication">A Comparative Introduction to 4G and 5G Authentication 4G 认证与5G 认证的比较</a></p>
</blockquote>
<blockquote>
<p>A major component of the 5G core network used to facilitate security processes. The AUSF authenticates UEs and stores authentication keys</p>
</blockquote>
<br />

<h4 id="AWG-–-Arbitrary-waveform-generator"><a href="#AWG-–-Arbitrary-waveform-generator" class="headerlink" title="AWG – Arbitrary waveform generator"></a>AWG – Arbitrary waveform generator</h4><p>任意波形发生器，用于产生信号以便注入被测装置(DUT)以表征其性能的电子设备。是一种特殊形式的函数生成器，能够根据输入的一组值生成波形。</p>
<blockquote>
<p>任意波形发生器(AWG)是一种用于产生电波形的电子测试设备。 这些波形既可以是重复的，也可以是单脉冲的(只有一次) ，在这种情况下，需要某种形式的触发源(内部或外部)。 由此产生的波形可以注入到一个设备在测试和分析，因为他们通过它的进展，确认设备的正确运行或精确定位故障。</p>
<p>与函数生成器不同，AWG可以生成任意定义的波形作为其输出。 波形通常定义为一系列“waypoints”(沿波形的特定时间出现的特定电压目标)，AWG可以跳到这些电平，也可以使用几种方法中的任何一种在这些电平之间进行插值。</p>
<p><a href="https://www.wikiwand.com/en/Arbitrary_waveform_generator">https://www.wikiwand.com/en/Arbitrary_waveform_generator</a></p>
</blockquote>
<blockquote>
<p>Electronic equipment used to generate signals for injection into a device under test (DUT) to characterize its performance.</p>
</blockquote>
<br />

<h4 id="Backhaul"><a href="#Backhaul" class="headerlink" title="Backhaul"></a>Backhaul</h4><p>回程线路， 负责在基带单元(BBU)和核心网络之间传输通信数据的网络部分。 用核心网络连接较小的外围网络。 回程在早期的蜂窝网络时代通常是专有的，但是在5G 时代正在转移到以太网。</p>
<blockquote>
<p>在分层电信网络中，网络的回程部分包括核心网络或骨干网络与网络边缘的小型子网之间的中间链路。</p>
<p>将整个等级网络可视化为一个人体骨架，核心网络将代表脊椎，回程链接将是肢体，边缘网络将是手和脚，这些边缘网络中的单个链接将是手指和脚趾。</p>
<p><a href="https://www.wikiwand.com/en/Backhaul_(telecommunications)">https://www.wikiwand.com/en/Backhaul_(telecommunications)</a></p>
</blockquote>
<blockquote>
<p>The part of the network responsible for transporting communication data between the baseband unit (BBU) and  the core network. Connects smaller outlying networks with the  core network. Backhaul was often proprietary in earlier cellular generations but is moving to ethernet in 5G. </p>
</blockquote>
<br />



<h4 id="Base-station-network-emulator"><a href="#Base-station-network-emulator" class="headerlink" title="Base station network emulator"></a>Base station network emulator</h4><p>基站网络仿真器,</p>
<p>用于在测试环境中模拟协议和网络流量的工具。与UE仿真和信道仿真协同工作，提供端到端系统，用于大规模测试和测量5G网络性能。</p>
<blockquote>
<p>A tool for simulating protocol and network traffic in a test environment. Works in concert with UE emulation and channel emulation to provide an end-to-end system for testing and  measuring 5G network performance at scale. </p>
</blockquote>
<br />

<h4 id="BBU-–-Baseband-unit"><a href="#BBU-–-Baseband-unit" class="headerlink" title="BBU – Baseband unit"></a>BBU – Baseband unit</h4><p>基带单元，基站的一个组件。处理无线电通信和无线电控制处理功能的设备。基带单元将数据转换为数字信号，并将其发送到远程无线电报头(RRH)，远程无线电报头(RRH)随后将其转换为模拟信号。在C-RAN架构中，基带单元通常在地理上与无线电报头分开。</p>
<blockquote>
<p>基带单元 (BBU) 是电信系统的基带处理单元。 BBU 具有模块化设计的优势，体积小巧、集成度高、功耗低且易于部署。 典型的无线基站由基带处理单元 (BBU) 和射频处理单元（远端射频单元 - RRU）组成。 BBU 放置在机房，通过光纤与 RRU 连接。 BBU 负责通过物理接口进行通信。</p>
</blockquote>
<blockquote>
<p>一个基站，通常包括BBU（主要负责信号调制）、RRU（主要负责射频处理），馈线（连接RRU和天线），天线（主要负责线缆上导行波和空气中空间波之间的转换）。在最早期的时候，BBU，RRU和供电单元等设备，是打包塞在一个柜子或一个机房里的。后来，慢慢开始发生变化。</p>
<p>怎么变化呢？通信砖家们把它们拆分了。首先，就是把RRU和BBU先给拆分了。硬件上不再放在一起，RRU通常会挂在机房的墙上。BBU有时候挂墙，不过大部分时候是在机柜里。再到后来，RRU不再放在室内，而是被搬到了天线的身边（所谓的“<strong>RRU拉远</strong>”）。这样，我们的RAN就变成了<strong>D-RAN</strong>，也就是<strong>Distributed RAN</strong>（分布式无线接入网）。<strong>这样做有什么好处呢？</strong></p>
<p>一方面，大大缩短了RRU和天线之间馈线的长度，可以减少信号损耗，也可以降低馈线的成本。</p>
<p>另一方面，可以让网络规划更加灵活。毕竟RRU加天线比较小，想怎么放，就怎么放。</p>
<p><a href="https://zhuanlan.zhihu.com/p/59654520">https://zhuanlan.zhihu.com/p/59654520</a></p>
</blockquote>
<blockquote>
<p>A component of the base station. Equipment which handles radio communications and radio control processing functions. The baseband unit converts data into a digital signal and sends it on to the remote radio head (RRH), which then converts it into an analog signal. In a C-RAN architecture, the baseband unit is usually geographically separated from the radio head. </p>
</blockquote>
<br />

<h4 id="Beam-acquisition"><a href="#Beam-acquisition" class="headerlink" title="Beam acquisition"></a>Beam acquisition</h4><p>波束捕获</p>
<p>发现UE并与UE连接的过程。随着高方向性天线阵列和波束成形技术的部署，这一过程在5G中正在发生实质性变化。</p>
<blockquote>
<p>The process of discovering and connecting with UEs. This process is substantially changing in 5G with the deployment of  highly directional antenna arrays and beamforming techniques. </p>
</blockquote>
<br />

<p>20200808更新以下内容</p>
<h4 id="Beamforming"><a href="#Beamforming" class="headerlink" title="Beamforming"></a>Beamforming</h4><p>波束赋形</p>
<p>　　<strong>波束赋形</strong>（Beamforming）又叫<strong>波束成型</strong>、<strong>空域滤波</strong>，是一种使用传感器阵列定向发送和接收信号的<a href="https://www.wikiwand.com/zh-hans/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">信号处理</a>技术。 波束赋形技术通过调整相位阵列的基本单元的参数，使得某些角度的信号获得相长干涉，而另一些角度的信号获得相消干涉。波束赋形既可以用于信号发射端，又可以用于信号接收端。</p>
<p>　　在发射端，波束赋形器控制每一个发射装置的相位和信号幅度，从而在发射出的信号波阵中获得需要相长和相消干涉模式。在接收端，不同接收器接收到的信号被以一种恰当的方式组合起来，从而获得期盼中的信号辐射模式。</p>
<p>　　以水下声纳发射为例，我们希望向远处的船只发送一束集中尖锐的声纳信号。如果声纳发射装置的每个声纳发生器同时向一艘船发声纳信号，由于远方船只的方位角度，有的声纳发射器的信号先到达船只，有的声纳发射器的信号后到达船只，无法做到让所有声纳信号发生器的信号同时到达这条船只。有了波束赋形技术，就可以调整不同声纳发生器的信号发射时间（离船远的先发信号，离船近的后发信号），这样，所有的声纳信号就能同时击中船只，获得一个强大的声纳脉冲信号击中船只的效果。</p>
<p>　　在被动式声纳系统或者主动式声纳的接收端，波束赋形技术为不同的水下听音器收集到的信号加上不同的时延（离开目标最近的水下听音器加上最长的时延），这样就能同时听到所有水下听音器的声音，就像声音是来自同一个水下听音器，从而获得最佳的效果。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/440px-Beamforming.jpg" alt="波束赋形"></p>
<p>－－　<a href="https://www.wikiwand.com/zh-hans/%E6%B3%A2%E6%9D%9F%E8%B5%8B%E5%BD%A2">维基百科</a></p>
<blockquote>
<p>The method of applying relative phase and amplitude shifts to each antenna element to shape and provide discrete control  of the direction of a transmitted beam. Beamforming requires communication channel feedback to implement real-time control of the beam. </p>
</blockquote>
<p>＜br&#x2F;＞</p>
<h4 id="Beam-steering"><a href="#Beam-steering" class="headerlink" title="Beam steering"></a>Beam steering</h4><p>波束控制</p>
<p>用于聚焦辐射图案的方向和形状的一组技术。在无线通信中，波束控制通常通过操纵通过多个天线单元阵列的信号的相对相位和幅度移位来改变信号的方向并缩小发射信号的宽度。</p>
<blockquote>
<p>A set of techniques used to focus the direction and shape of a  radiation pattern. In wireless communications, beam steering  changes the direction of the signal and narrows the width of the transmitted signal, typically by manipulating relative phase<br>and amplitude shifts of the signal through an array of multiple antenna elements. </p>
</blockquote>
<br/>

<h4 id="Carrier-aggregation"><a href="#Carrier-aggregation" class="headerlink" title="Carrier aggregation"></a>Carrier aggregation</h4><p>载波聚合</p>
<p>LTE-Advanced引入的一项主要功能，使移动网络运营商能够将分段频段中的多个载波组合在一起，以提高峰值用户数据速率和网络的整体容量。</p>
<blockquote>
<p>A major feature introduced with LTE-Advanced, enabling  mobile network operators to combine multiple carriers in fragmented spectrum bands to increase peak user data rates and overall capacity of the network. </p>
</blockquote>
<br/>



<h4 id="CATR-–-Compact-antenna-test-range"><a href="#CATR-–-Compact-antenna-test-range" class="headerlink" title="CATR – Compact antenna test range"></a>CATR – Compact antenna test range</h4><p>CATR-紧凑型天线测试范围</p>
<p>在难以获得远场间距时测试频率上的天线的设备。CATR使用3GPP认可的间接远场(IFF)测试方法来克服与5G蜂窝通信相关的路径损耗和过大的远场距离问题。</p>
<blockquote>
<p>Equipment for testing of antennas at frequencies when difficult to obtain far-field spacing. The CATR uses the 3GPP-approved indirect far-field (IFF) test method to overcome the path loss and excessive far-field distance issues associated with 5G<br>cellular communications. </p>
</blockquote>
<p>其他内容正在整理…</p>
<p>（逃 ）</p>
<br />]]></content>
      <categories>
        <category>技术</category>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>5G NR</tag>
      </tags>
  </entry>
  <entry>
    <title>更改hosts加速访问Github</title>
    <url>/posts/32023.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/github2.jpg"></p>
<p>更改 hosts 加速访问Github</p>
<span id="more"></span>





<h2 id="更改hosts"><a href="#更改hosts" class="headerlink" title="更改hosts"></a>更改hosts</h2><p>hosts文件所在路径为 <code>C:\Windows\System32\drivers\etc</code></p>
<p>利用火绒或者 <a href="https://github.com/oldj/SwitchHosts/releases/tag/v3.5.4">SwitchHosts</a>  可以很方便的更改<code>hosts</code> 。</p>
<p>在 <code>hosts</code> 中增加如下内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">140.82</span><span class="number">.112</span><span class="number">.3</span> github.com</span><br><span class="line"><span class="number">140.82</span><span class="number">.114</span><span class="number">.4</span> gist.github.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> assets-cdn.github.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> gist.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> cloud.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> camo.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars0.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars1.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars3.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars4.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars5.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars6.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars7.githubusercontent.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.68</span><span class="number">.133</span> avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>

<p>可以通过以下网站获取 Github 域名所对应的 IP 地址</p>
<p><a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604210831289.png"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>若你使用火绒或者 <a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a>  以管理员打开还是提示 hosts 更改错误。那么是因为 hosts 文件为只读属性，解决方案是手动去除 hosts 文件的只读属性。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604210742953.png"></p>
<br />

<br />

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote class="blockquote-center">
<p>梅子留酸软齿牙，芭蕉分绿与窗纱。<br>日长睡起无情思，闲看儿童捉柳花。</p>
<p>–杨万里《闲居初夏午睡起》</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>问题</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐生成外链播放器</title>
    <url>/posts/20372.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/river-between-trees-in-aerial-photography-1916736s.jpg"></p>
<center><font size=1>pexels </center>

<p>网易云音乐生成外链，嵌入到网页当中。</p>
<span id="more"></span>

<p>从前在网易云音乐的网页端还可以生成外链播放器，嵌入到自己的markdown 当中。但现在会出现“ 由于版权保护，无法生成外链”。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604174219087.png"></p>
<p>解决方法如下：</p>
<p>在你想要生成外链的页面中 ，按下 <kbd>F12</kbd> ，如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200604195123.png" alt="按F12后"></p>
<br />

<p>然后在 <code>搜索HTML</code> 当中输入 **生成外链 **四个字，回车 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200604195338.png" alt="找到这里"></p>
<p>复制其中的 <code>/outchain/2/449649034/</code> 这些字符。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604175000469.png" alt="复制它"></p>
<br />

<p>然后在<a href="https://music.163.com/">网易云音乐</a>的主页网址后面加上这串字符，回车，在新的网页就可以复制外链了。</p>
<p>比如打开： </p>
<p><a href="https://music.163.com/outchain/2/449649034/">https://music.163.com/outchain/2/449649034/</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604180235929.png"></p>
<p>调整大小、是否自动播放以后，复制代码，粘贴到 Markdown 中即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200604180449646.png"></p>
<br />

<p>将那串 HTML 代码粘贴在 Markdown 当中，效果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=449649034&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>



<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=449649034&auto=0&height=66"></iframe>



<br />

<br />



<blockquote class="blockquote-center">
<p>张可久 《人月圆·山中书事》</p>
<p>兴亡千古繁华梦，诗眼倦天涯。孔林乔木，吴宫蔓草，楚庙寒鸦。<br>数间茅舍，藏书万卷，投老村家。山中何事？松花酿酒，春水煎茶。</p>

</blockquote>



<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>C# VS Code launch:program … does not exist 不存在</title>
    <url>/posts/59557.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200607145346.jpg" alt="🍃"></p>
<p>解决 VS Code 中调试C# 出现 C# VS Code launch:program … does not exist 不存在的问题。</p>
<span id="more"></span>





<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 VS Code 中安装了一个名为 <code>C# for Visual Studio Code (powered by OmniSharp)</code> 的拓展，然后在在终端中输入  <code>dotnet run</code> 就可以成功运行代码了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607135745335.png" alt="拓展"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607135919220.png" alt="运行成功"></p>
<p>我试图在 VS Code 中调试一个简单的“ Hello world”应用程序，但是，当我按下 <kbd>F5</kbd> 时，会出现以下错误:</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607135306339.png" alt="报错截图"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">launch:程序”</span><br><span class="line">D:\Project_ codeing\VisualStudioCode\C#\The _1_2..\&lt;insert-project-name-here&gt;.dll <span class="string">&quot;不存在</span></span><br></pre></td></tr></table></figure>

<br/>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法是动将 launch.json 中的路径更改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/Debug/netcoreapp3.1/the_1_2.dll&quot;,</span><br></pre></td></tr></table></figure>

<p>当然这个路径是根据你项目名称进行更改的，具体要看你自己的路径还有<code>dll</code>文件的名称。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607140127597.png" alt="更改路径"></p>
<p>更改后，按下 <kbd>F5</kbd>  ，即可正常调试，在左侧还可以看见变量、监视、断点等 🥛</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607140616360.png" alt="成功调试🌞"></p>
<br/>

<p>一些常见的快捷键：</p>
<table>
<thead>
<tr>
<th>启动调试</th>
<th>F5</th>
</tr>
</thead>
<tbody><tr>
<td>以非调试模式运行</td>
<td>Ctrl+F5</td>
</tr>
<tr>
<td>停止调试</td>
<td>Shift+F5</td>
</tr>
<tr>
<td>重启调试</td>
<td>Ctrl+Shift+F5</td>
</tr>
<tr>
<td>🍓</td>
<td>🍦</td>
</tr>
<tr>
<td>单步跳过</td>
<td>F10</td>
</tr>
<tr>
<td>单步执行</td>
<td>F11</td>
</tr>
<tr>
<td>单补停止</td>
<td>Shift+F11</td>
</tr>
<tr>
<td>继续</td>
<td>F5</td>
</tr>
<tr>
<td>切换断点</td>
<td>F9</td>
</tr>
</tbody></table>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200607141917414.png" alt="常用调试快捷键"></p>
<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://stackoverflow.com/questions/52391861/c-sharp-vs-code-launchprogram-does-not-exist">stackoverflow-C# - VS Code - launch:program … does not exist</a></p>
</blockquote>
<br />

<br />





<blockquote class="blockquote-center">
<p>杨万里 《夏夜追凉》</p>
<p>夜热依然午热同，开门小立月明中。<br>竹深树密虫鸣处，时有微凉不是风。</p>

</blockquote>



<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>编程</category>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>问题</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】搜狗输入法强制推广“618红包广告” 用户不堪其扰</title>
    <url>/posts/1128.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20200610193140774.png" alt="火绒安全日志"></p>
<p> 临近6.18电商促销日，火绒在官方微博、微信等平台收到不少用户反馈，称电脑不断出现托盘闪烁弹窗，点击后即为淘宝天猫的6.18促销网页。火绒工程师溯源调查后发现，该弹窗均来自于常用软件“搜狗输入法”，该广告配置通过云控下发，无法通过设置关闭。进一步分析发现，该软件除了疯狂弹窗，还存在统计用户浏览器浏览历史数据等越位行为，符合广告程序的定义。目前，火绒已对该软件中广告模块进行拦截查杀。</p>
<blockquote>
<p>病毒名称：Adware&#x2F;Sogou.a   病毒ID：DFFE5437C89E3403</p>
</blockquote>
<p>本文转载自 <a href="http://bbs.huorong.cn/thread-72058-1-1.html">火绒安全论坛</a> <a href="http://bbs.huorong.cn/thread-72058-1-1.html">http://bbs.huorong.cn/thread-72058-1-1.html</a></p>
<span id="more"></span>





<h2 id="流氓搜狗"><a href="#流氓搜狗" class="headerlink" title="流氓搜狗"></a>流氓搜狗</h2><p>临近6.18电商促销日，火绒在官方微博、微信等平台收到不少用户反馈，称电脑不断出现托盘闪烁弹窗，点击后即为淘宝天猫的6.18促销网页。火绒工程师溯源调查后发现，该弹窗均来自于常用软件“搜狗输入法”，该广告配置通过云控下发，无法通过设置关闭。进一步分析发现，该软件除了疯狂弹窗，还存在统计用户浏览器浏览历史数据等越位行为，符合广告程序的定义。目前，火绒已对该软件中广告模块进行拦截查杀。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200610193432.png" alt="查杀图 "></p>
<p>根据分析，“搜狗输入法”通过云控，向用户下发专门添加了用以在6.18期间弹窗的相关组件，该组件与“搜狗输入法”主程序功能之间并无任何关联作用。用户安装运行“搜狗输入法”后，就会频繁收到托盘闪烁弹窗，如果不小心点击，就会打开关于天猫6.18整个推广促销网页。    虽然右键可暂时退出该弹窗，但根据其云控下发的配置，5小时后仍旧会再次顽固弹出，循环往复，严重影响了用户的正常上网及工作。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200610193903.png"></p>
<p>​       除此之外，更为严重的是“搜狗输入法”还会收集用户本地的安全软件、广告拦截工具的运行状态，甚至搜集用户IE浏览器和搜狗浏览器历史记录数量和页面标题数量，并回传至后台服务器，推测用以制作用户画像进行精准推广。该行为涉及隐私数据，严重越位。存在损害用户权益的风险。    由于该软件下载量较多，导致受影响的用户范围较大，火绒在用户群、论坛、微博、微信、邮箱等各平台均收到大量的相关反馈与私信求助。目前，火绒最新版已对“搜狗输入法”内的弹窗与搜集用户信息的模块进行拦截查杀。需要注意的是，火绒查杀该广告模块后或导致“搜狗输入法”的“工具”功能无法使用，但不影响键入文字等主要功能。   </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215210xooo7p7rk1q2qh72.jpg" alt="图：火绒各平台的私信求助"></p>
<p>​      </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215219oihl567ihvamhkgt.png" alt="图：火绒用户群的反馈情况  "></p>
<p>​    <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215228jmrj05zxv5kexlma.png" alt="图：火绒论坛反馈信息"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200610195113.jpg" alt="图：知乎相关话题讨论 "></p>
<p>​    弹窗问题由来已久，继去年人民日报点名批评弹窗乱象后，今年两会期间也有政协委员建议将过度弹窗的软件厂商列入失信名单。但随着流量经济愈发至上，部分软件厂商已然越过雷池，将弹窗流氓化、病毒化，对于此类软件和程序，火绒将会持续、及时进行拦截查杀，保护用户权益。同时我们也呼吁广大软件厂商抱表寝绳，合理逐利，注重用户体验才能长远发展。    </p>
<h2 id="附：【分析报告】"><a href="#附：【分析报告】" class="headerlink" title="附：【分析报告】"></a>附：【分析报告】</h2><h3 id="一、-详细分析"><a href="#一、-详细分析" class="headerlink" title="一、    详细分析"></a><strong>一、    详细分析</strong></h3><p>近期，搜狗输入法用户大量遇到6.18托盘广告弹窗的情况，该流氓推广行为通过云控下发，在搜狗输入法界面中未发现相关功能开关。广告弹窗程序showinfo.exe由sgutil.dll释放执行，sgutil.dll被sgtool.exe调用。相关代码，如下图所示：  </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnftq9wxjj20oz0lctag.jpg" alt="sgtool.exe加载执行sgutil.dll"></p>
<p>  sgutil.dll执行”StartPopupServer”导出函数后，会根据云端配置释放执行托盘广告模块showinfo.exe。相关代码，如下图所示： </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfuijz71j20se0dqq3x.jpg" alt="根据配置决定是否释放执行showinfo模块"></p>
<p><strong>showinfo模块</strong>  </p>
<p>showInfo.exe模块主要负责弹出桌面托盘广告图标及更新广告配置。当此模块运行之后，首先会对存放于%Appdata%\LocalLow\SogouPY\Popup\traynet\目录下的配置资源config.ini进行AES解密并读取其中的配置信息，相关信息如下图所示：     </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfvbj3b1j20jd0gugmo.jpg" alt="AES解密并读取配置信息"></p>
<p>   解密后的config.ini配置信息如下图所示：   </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfw5gi2vj206e03l0sk.jpg" alt="解密后的config.ini信息  "></p>
<p>解密并读取配置信息无误之后，showInfo.exe模块便会收集：系统硬件签名、主机运行的安全软件等信息，连同搜狗输入法的版本信息一起回传。收集的安全软件信息如下图所示：      </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfwpbwxgj20l407gq2z.jpg" alt="收集的安全软件信息 "></p>
<p>​    收集安全软件运行信息相关代码如下图所示：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfxj617lj20eb0nzq9k.jpg" alt="收集安全软件信息  "></p>
<p>   收集的安全软件信息以标记位形式发送给服务器（sfsw及sfw参数中0,1代表各家安全软件运行状态。0代表未运行，1代表正在运行），相关信息如下图所示：   </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfy7pedjj210q0mswgk.jpg" alt="收集的主机信息内容"></p>
<p>  收集完所需的主机信息之后，程序便会将其与“<a href="http://api.pinyin.sogou.com/v1/bubble/ad%E2%80%9C%E5%8A%A0%E5%AF%86%E5%8F%91%E9%80%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%9Chttp://get.sogou.com/q%E2%80%9D%EF%BC%8C">http://api.pinyin.sogou.com/v1/bubble/ad“加密发送给服务器“http://get.sogou.com/q”，</a> 发送加密信息相关代码如下图所示 ： </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfnfzemjtpj20l50vu772.jpg" alt="发送加密信息"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215335p4vd2addagg3knnl.png" alt="传输的数据信息 ">   </p>
<p> 服务器根据发送信息，返回加密数据。程序通过AES算法解密之后便得到托盘广告所需的配置信息，解密数据相关代码如下图所示：  </p>
<p>  <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215335jtxb225i50wi5vi0.png" alt="AES解密返回数据 ">   </p>
<p> 解密后的配置数据如下图所示：</p>
<p>​    <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215335ur5risr4r424r4v1.png" alt="解密后的配置数据">   </p>
<p>当得到所需的托盘广告配置信息以后，程序便将其AES加密并更新到<code>%Appdata%\LocalLow\SogouPY\Popup\traynet\</code>目录下的net.ini文件中。之后，开始检查当前系统时间是否在net.ini配置中所规定的“sdate”到“edate”时间范围之内，并且查询当前系统时间距离上次关闭广告托盘的时间（config.ini中的lastclose字段值）是否大于5个小时（net.ini中的interval字段值），满足上述两个条件则弹出托盘广告，相关代码如下图所示：</p>
<p>​    <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215335sdefpgo2rn22n2nz.png" alt="时间检测"></p>
<p>弹出广告托盘相关现象如下图所示： </p>
<p>​     <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336sf6yuafsfy64ex21.png" alt="广告托盘">   </p>
<p>  <strong>sgutil模块</strong></p>
<p>  在sgutil.dll加载执行后会根据云端返回的配置决定是否弹出托盘广告,广告弹窗的功能开关只能由云控页面控制（hxxp:&#x2F;&#x2F;api.pinyin.sogou.com&#x2F;v1&#x2F;config&#x2F;netswitch_pc），在搜狗输入法界面中，未发现相关弹窗功能开关。从云端请求的配置信息中“trayad”为弹出开关标记位，如下图所示：</p>
<p>​      <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336vrjgxfjxxgxf4fe8.png" alt="云端配置">     当“trayad”标记位为1时，sgutil.dll会从资源中释放执行showinfo模块。相关代码，如下图所示：     </p>
<p>  <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336t0dvwk6djwvjz5dj.png" alt="从资源中释放showinfo模块">     sgutil.dll会间隔6个小时取最新云端开关的状态。相关代码，如下图所示：</p>
<p>​    <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336aparhnvlh25qtn2n.png" alt="请求云端开关配置">     </p>
<p>并且根据不同地区多次测试发现，请求到的开关配置会有所不同。相关现象如下图所示：     </p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336vmfh434ttr6as4ws.png" alt="不同地区多次测试得到不同的配置 ">   </p>
<p> sgutil.dll除了会释放showInfo.exe外，还会收集Chrome内核浏览器和IE浏览器的历史记录信息。虽然历史记录中的URL、标题等数据也会进行收集，但是尚未发现上传上述数据的相关代码逻辑，现阶段仅会上传历史记录条目数量。在获取Chrome内核浏览器历史记录信息时，首先会根据预留的浏览器历史记录数据库路径找到数据库所在位置，如果预留路径为空，则不会执行任何操作。除IE浏览器外，现阶段最新的sgutil.dll模块只会获取搜狗浏览器的历史记录信息。获取Chrome内核浏览器历史记录信息，相关代码如下图所示： </p>
<p>   <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336gyyhp8z68nxdn9od.png" alt="搜集用户浏览器历史中的标题个数">   </p>
<p> 获取搜狗浏览器历史记录信息相关代码，如下图所示： </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gfngf7mcs9j20mg0to0uv.jpg" alt="获取搜狗浏览器历史记录信息"></p>
<p>​      </p>
<p> 获取其他浏览器历史信息相关代码，如下图所示：</p>
<p>​    <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336puwkiyhn3x7ir76n.png" alt="获取其他Chomre内核浏览器历史记录信息"></p>
<p>​     在搜集历史记录信息结束后，会将搜狗浏览器历史记录条目数拼接到HTTP请求参数中。相关代码，如下图所示：    </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215336ts200fpy2z2wspii.png" alt="将收集到的浏览器历史信息拼接为HTTP请求参数"></p>
<p>​     获取IE浏览器中历史记录条目数和标题数相关代码，如下图所示：    </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img215337aoyqy0lxkkcrlzqr.png" alt="IE浏览器历史记录信息收集"></p>
<p>上述收集到的浏览器历史记录条目数量和标题数量，会被拼接为回传数据的请求链接地址，回传地址为：hxxp:&#x2F;&#x2F;ping.pinyin.sogou.com&#x2F;webtitlequery.gif。相关代码，如下图所示：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200610201643.png" alt="拼接上传浏览器历史信息的请求参数"></p>
<p>​     </p>
<p>​       由于在目前最新模块中发现了疑似查找360安全浏览器等其他浏览器相关逻辑，但统计这些浏览器浏览历史的代码逻辑无法激活，所以推测以往版本中该模块曾安插过统计其他浏览器浏览历史的代码逻辑。通过分析发现，在2015年的sgutil.dll模块中，我们发现该模块会收集更多不同浏览器的历史记录信息，包括：360安全浏览器、搜狗浏览器、Chrome浏览器、360极速浏览器、猎豹浏览器和淘宝浏览器。相关代码及数据，如下图所示 ：     </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200610201721.png" alt="早期的sgutil.dll模块历史记录信息收集代码"></p>
<p>​    </p>
<p> 2015年的sgutil.dll模块文件信息及数字签名信息，如下图所示：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200610201808.png" alt="2015年的sgutil.dll模块文件信息及数字签名信息"></p>
<h3 id="二、-附录"><a href="#二、-附录" class="headerlink" title="二、    附录"></a><strong>二、    附录</strong></h3><p>相关文件hash  </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200610201903.png"></p>
<p>​      </p>
<p>本文转载自 <a href="http://bbs.huorong.cn/thread-72058-1-1.html">火绒安全论坛</a> <a href="http://bbs.huorong.cn/thread-72058-1-1.html">http://bbs.huorong.cn/thread-72058-1-1.html</a></p>
<br />

<br />

<br />







<blockquote class="blockquote-center">
<p>用户不是上帝，用户只是任人宰割 ！</p>

</blockquote>

<br />

<br />

<br />]]></content>
      <categories>
        <category>技术</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>向下就是天空</title>
    <url>/posts/45421.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/mountains-with-crepuscular-ray-1403550.jpg"></p>
<center> 那是去年的景象，我们奔跑在雨季  
<center>入夜，在世界里漫游</center>

<span id="more"></span>

<br />

<p>分享 奇怪的日子  · 《向下就是天空》🎵</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=371929&auto=0&height=66"></iframe>

<blockquote class="blockquote-center">
<p>奇怪的日子 · 《向下就是天空》</p>
<p>那是去年的景象，我们奔跑在雨季<br>入夜，在世界里漫游<br>你问我的小说《落日青春》写得怎样了<br>我笑说这城市的改造让我迷路了<br>入夜，在梦中醒来，车灯在窗前一闪而过<br>你不会说漂亮的情话，但你是个固执的女人<br>死亡占据了整个童年<br>你也并不害怕确认和期待什么<br>说说你，说说你的爱情，你的过去，你常这样问我<br>天空像蓝色的孩子，田野上的小路有动物的足迹<br>叶子的故乡受到土地和阳光的恩宠，笑声传遍山谷<br>我们为了寻找幻想之光<br>在城市的最高处却看到了一片汪洋</p>
<p>你的快乐来自夏天的每一阵雨<br>虽然有时候会独自哭泣<br>我说喜欢看你坐在门前的石头上<br>一支烟的功夫，黄昏就来了<br>你问我小说里是不是有旧时的风物<br>我说那只是消失的记忆<br>真的那么崭新和伟大吗？<br>没有，只是时间流过，连痕迹也没有留下<br>我们生活在失信最猛的时代<br>新生的儿童都被称作了天才<br>在拥挤混乱的空间里，小丑们高歌说，我们来了！<br>路边的小铁门上写着“彼此相爱”四个字，夕阳照在上面特别美<br>忽然你说想要喝酒，还要阳光和不孤独<br>我们整夜地念诗，在宿醉的夜晚寻找向下的方式<br>也许音乐会从左边响起<br>无节奏的声音在城市上空弥漫<br>寻欢作乐的人们以为时代复兴了，用干瘪的腔调说<br>来一段我想要的！<br>我说，嘿，朋友，别忘了我们是行走在这荒凉之城的大街上<br>我们从夜里醒来，相互给予了温暖的信号<br>我的文字里有故乡的记忆<br>这也是我们讨论多次的话题<br>现在我还生活一个承诺<br>在结伴而行的日子里<br>道路虽被淹没，但向下就是天空……</p>

</blockquote>



<br />

<br />



<br />


]]></content>
      <categories>
        <category>生活</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移搜狗输入法词库至微软拼音/手心输入法</title>
    <url>/posts/1380.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/close-up-photography-of-person-holding-crystal-ball-1071249.jpg"></p>
<p>鉴于搜狗输入法的<a href="https://www.lifeee.top/posts/1128.html"><strong>越权行为</strong></a>，严重侵害用户的利益与隐私。因此我卸载了搜狗输入法，并迁移词库至微软拼音与手心输入法。 😾</p>
<span id="more"></span>



<p>卸载搜狗输入法前，需要导出词库。然后转换词库，最后导入其它输入法。详细步骤请继续往下看。🌞</p>
<h2 id="导出词库"><a href="#导出词库" class="headerlink" title="导出词库"></a>导出词库</h2><p>在使用搜狗输入法打字时，在其界面上右击，选择属性设置。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200616100036338.png" alt="属性设置" style="zoom: 80%;" />

<p>选择词库，然后在基础词库一栏中选择导出&#x2F;备份，见下图。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200616100232273.png" alt="导出词库" style="zoom:80%;" />



<p>导出后的词库如下图所示，后缀为<code>bin</code> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200619_221600_1081_625_Clover.png" alt="导出的词库"></p>
<p>导出后就可以卸载该输入法了，然后将搜狗词库转换为其它输入法的词库，导入即可。导入方法见本文后面的内容。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200617_093133_1328_902_UninstallTool_x64.dat.png" alt="卸载搜狗输入法"></p>
<blockquote>
<p> 卸载搜狗，才能提升用户体验</p>
</blockquote>
<br/>

<h2 id="词库文件转换"><a href="#词库文件转换" class="headerlink" title="词库文件转换"></a>词库文件转换</h2><p>由于各个输入的词库文件格式不尽相同，一直没有标准化。因此需要通过工具来转换文件以导入其它输入法。</p>
<p>首先，下载 深蓝词库转换工具。这是一款开源免费的输入法词库转换程序    。可在 <a href="https://github.com/studyzy/imewlconverter/releases">Github</a> 下载 或 <a href="https://yours.lanzous.com/iG9Ufdu8vzc">蓝奏云</a> 下载，提取码 <code>summer</code>。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200619_222426_1233_712_firefox.png" alt="github"></p>
<p>解压后运行 <code>深蓝词库转换.exe</code> ，开始进行词库转换。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200619_222623_688_567_%E6%B7%B1%E8%93%9D%E8%AF%8D%E5%BA%93%E8%BD%AC%E6%8D%A2.png" alt="主界面"></p>
<p>打开刚刚搜狗导出的词库文件。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200619_222745_968_772_深蓝词库转换.png" alt="" style="zoom:67%;" />

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200619_222813_688_567_%E6%B7%B1%E8%93%9D%E8%AF%8D%E5%BA%93%E8%BD%AC%E6%8D%A2.png"></p>
<p>在界面中选择导出的输入法类型，这里以微软拼音与手心为例。</p>
<br/>

<h3 id="微软拼音"><a href="#微软拼音" class="headerlink" title="微软拼音"></a>微软拼音</h3><p>微软拼音自学习词库对词库的支持是2W个词条，所以如果源词库太大，则无法导入，所以本转换工具也做了限制，只支持2W条内的词库转换，如果源词库太大，可以通过高级设置中的词条长度、词频等过滤条件，将词库控制在2W内。</p>
<p>点击高级设置的“词条过滤设置”，设置一个合理的词频或者其他过滤，让最终文件词条小于2W。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619223235996.png"></p>
<p>然后点击转换即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619223308015.png" alt="转换"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619223402419.png" alt="转换后的文件"></p>
<p>然后切换按住 Shift + Ctrl 切换至微软拼音输入法，在右下角语言右击选择设置，然后选择词库和自学习。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619223804894.png"></p>
<p>打开微软拼音的自学习词库导入页面，选择刚才生成的dat文件，进行导入，几秒后提示导入成功。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619224103878.png"></p>
<br/>

<h3 id="手心"><a href="#手心" class="headerlink" title="手心"></a>手心</h3><p>同样选择手心输入法，然后选择高级设置，词条过滤设置</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619223235996.png"></p>
<p>点击转换，预览一下词库，觉得差不多的话点击是，导出至硬盘。若感觉有偏差，可重新设置词库过滤。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200619230449.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619224703668.png"></p>
<p>安装<a href="http://www.xinshuru.com/">手心输入法</a>后，切换至手心输入法，右击语言栏，选择设置属性，选择词库导入转换后的词库即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619224743796.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200619224929596.png"></p>
<p>当然可以将词库导入到其它输入法，比如： QQ拼音 、谷歌拼音、极点五笔等等。看个人喜好迁移词库，清爽上网。（逃）</p>
<p>🍻</p>
<br />

<br />

<br />

 



<blockquote class="blockquote-center">
<p>向浅洲远渚，亭亭清绝。</p>
<p>– 张炎《疏影·咏荷叶》</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado与VS Code:强强联手1</title>
    <url>/posts/54594.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626210532.jpg"></p>
<p>  Vivado带有自己的文本编辑器，可以编写代码；但是若说用起来效果较好的，还是要提到VS Code；接下来从Vivado自带的文本编辑器改用VS Code聊起，接着谈些对VS Code的简单设置，以便更好的进行程序编写。🍻</p>
<span id="more"></span>



<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        Vivado带有自己的文本编辑器，可以编写代码；但是若说用起来效果较好的，还是要提到VS Code；</p>
<p>接下来从Vivado自带的文本编辑器改用VS Code聊起，接着谈些对VS Code的简单设置，以便更好的进行程序编写。</p>
<p>​        说明：后续的设置等都是在以下的Windows系统及软件版本下完成的。</p>
<p>​        系统：<strong>Windows 10 专业版</strong></p>
<p>​        Vivado版本：<strong>2018.3</strong>     </p>
<p>​        VS Code版本：<strong>1.46.0</strong>  </p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>VS Code替换<strong>Vivado</strong>自带的文本编辑器大致步骤如下：</p>
<p>（1）VS Code替换Vivado自带的文本编辑器</p>
<p>（2） 安装 Verilog HDL&#x2F;SystemVerilog 插件</p>
<p>（3）配置xvlog</p>
<h3 id="（1）VS-Code替换Vivado自带的文本编辑器"><a href="#（1）VS-Code替换Vivado自带的文本编辑器" class="headerlink" title="（1）VS Code替换Vivado自带的文本编辑器"></a>（1）VS Code替换Vivado自带的文本编辑器</h3><p>打开软件Vivado 2018.3 ，在上面的菜单栏找到 <strong>Tools</strong> ，进入 <strong>Settings</strong>  ;</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jpaab46j309m0ak3yl.jpg" alt="img"></p>
<p>点击选项 <strong>Text Editor</strong> ，可以看到 <strong>Current Editor</strong>。</p>
<p>点击下拉箭头，选择 <strong>Custom Editor</strong>。</p>
<p>对应的输入 VS Code的安装路径，后面需要加上  **[file name] -[line number]**。比如我的设置路径：</p>
<p><strong><code>D:\Microsoft\Microsoft VS Code\Code.exe [file name] -[line number]</code></strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jqmco8cj30n60jrwfh.jpg" alt="img"></p>
<p>点击确定即可。</p>
<h3 id="（2）VS-Code-实现语法高亮、自动纠错等"><a href="#（2）VS-Code-实现语法高亮、自动纠错等" class="headerlink" title="（2）VS Code 实现语法高亮、自动纠错等"></a>（2）VS Code 实现语法高亮、自动纠错等</h3><h4 id="2-1、安装-Verilog-HDL-SystemVerilog-插件"><a href="#2-1、安装-Verilog-HDL-SystemVerilog-插件" class="headerlink" title="2.1、安装 Verilog HDL&#x2F;SystemVerilog 插件"></a>2.1、安装 Verilog HDL&#x2F;SystemVerilog 插件</h4><p>​        插件 Verilog HDL&#x2F;SystemVerilog 可以实现代码高亮，自动补全等，在VS Code插件库中，搜索 <strong>Verilog HDL&#x2F;SystemVerilog</strong> ，如下图所示，选择第一个，点击安装。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jrxzsw0j30se05s750.jpg" alt="img"></p>
<h4 id="2-2、配置xvlog"><a href="#2-2、配置xvlog" class="headerlink" title="2.2、配置xvlog"></a>2.2、配置xvlog</h4><p>大体步骤如下</p>
<p>以Vivado自带的语法纠错工具 xvlog 为例：</p>
<p>1）安装好Vivado2018.3；</p>
<p>2）将xvlog所在路径添加到系统的环境变量中；</p>
<p>vivado自带的语法纠错工具 xvlog ，将这个工具所在的目录放置在系统的环境变量，以便VS Code能够方便的调用它。具体目录是：</p>
<p>Vivado2018.3 安装路径下的 bin 文件夹。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jsqajiqj30h60ibq3g.jpg" alt="img"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jtaqxfhj30en0fnaal.jpg" alt="img"></p>
<p>仅需要添加自己安装的 Vivado 版本对应的路径即可；</p>
<p>3）在VS Code的设置中，选择<strong>xvlog</strong>；</p>
<p>打开 VS Code ，找到之前安装的插件 <strong>Verilog HDL&#x2F;SystemVerilog</strong> 。</p>
<p>在插件上右键 -&gt; 配置扩展设置 , 找到 <strong>linter</strong> , 选择 <strong>xvlog</strong>；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5jtv4rlfj30b80b5mxc.jpg" alt="img"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5juaqwh9j30fd03c3ye.jpg" alt="img"></p>
<p>4）重启VS Code；</p>
<p>说明：编译器在手动保存之后，才会进行 xvlog 解析，即就是保存最新的代码之后，才会出现最新的错误。</p>
<br />

<br />

<blockquote>
<p>本文来自实验室同学 <a href="https://weibo.com/u/5733142591">@WanTwoWan</a> ，在此表示感谢 🍗</p>
</blockquote>
<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado与VS Code:强强联手2-自动生成 Testbench</title>
    <url>/posts/54635.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626211322.jpg"></p>
<p>  在对 Verilog 代码进行 行为级仿真 时，测试文件是必不可少的。可以自己写测试文件，但也会花费一些时间。利用 VS Code 可以自动生成测试文件，快速例化对应的模块，仅需要我们自己初始化时钟复位等信号，添加测试文件的运行时间等。</p>
<span id="more"></span>



<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        在对 Verilog 代码进行 行为级仿真 时，测试文件是必不可少的。可以自己写测试文件，但也会花费一些时间。利用 VS Code 可以自动生成测试文件，快速例化对应的模块，仅需要我们自己初始化时钟复位等信号，添加测试文件的运行时间等。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>自动生成 <strong>Testbench</strong> 的大致步骤如下：</p>
<p>（1）在VS Code中安装插件  <strong>Verilog_Testbench</strong> 。</p>
<p>（2）给电脑安装 <strong>python3</strong> 及以上的环境。 </p>
<p>（3）为确保VS Code中的插件可用，安装 <strong>chardet</strong> 。 </p>
<p>（4）修改插件的<strong>原始py文件</strong>。</p>
<p>（5）效果展示。</p>
<h3 id="（1）安装插件-Verilog-Testbench"><a href="#（1）安装插件-Verilog-Testbench" class="headerlink" title="（1）安装插件  Verilog_Testbench"></a>（1）安装插件  Verilog_Testbench</h3><p>具体的使用方法为：在快捷键 <strong>ctrl + shift + p</strong> 下打开命令行，输入 <strong>Testbench</strong>  或者 <strong>Instance</strong> 。</p>
<p>刚开始没有设置的时候效果如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5ln0jt6ej312006k3ys.jpg"></p>
<p>在 VS Code的应用商店搜索并安装插件 <strong>Verilog_Testbench</strong>；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lnhdcd0j30hw05w0sv.jpg"></p>
<h3 id="（2）给电脑安装-python3-及以上的环境"><a href="#（2）给电脑安装-python3-及以上的环境" class="headerlink" title="（2）给电脑安装 python3 及以上的环境"></a>（2）给电脑安装 python3 及以上的环境</h3><p>下载地址： <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lnw60x1j30wx0dmdkt.jpg"></p>
<p>进行安装；</p>
<p>说明：</p>
<p>​        1、安装时需要设置添加到系统变量的路径中。</p>
<p>​        2、记住 python 的安装路径，后面可用。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5loi3eo2j30ii0be0up.jpg"></p>
<p>或者根据安装地址添加两个环境变量到<strong>path</strong>下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lp0m9roj30h60ib756.jpg"></p>
<p>在运行窗口下，输入 <strong>cmd</strong> ，打开终端命令窗口，输入 <strong>python</strong> 进行验证是否安装成功！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lpnn4sbj30r705lglk.jpg"></p>
<p>出现该信息则为成功；</p>
<h3 id="（3）为确保VS-Code中的插件可用，安装-chardet"><a href="#（3）为确保VS-Code中的插件可用，安装-chardet" class="headerlink" title="（3）为确保VS Code中的插件可用，安装 chardet"></a>（3）为确保VS Code中的插件可用，安装 chardet</h3><p>说明：</p>
<p>​        需要使用 chardet 检测编码，是适用于 Python 2和3的通用编码检测器。chardet 支持检测中文、日文、韩文等多种语言。</p>
<p>下载地址：</p>
<p>​        <a href="https://pypi.org/project/chardet/">https://pypi.org/project/chardet/</a> </p>
<p>下载压缩文件 “ <strong>chardet-3.0.4.tar.gz</strong> ”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lq8tcmvj30wh0ja404.jpg"></p>
<p>解压该压缩文件到 python 安装位置下的 ‘<strong>site-packages</strong>’ 目录下，例如：”C:\Python\Python38-32\Lib\site-packages\chardet-3.0.4”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lqw7uu3j30ik09bt9a.jpg"></p>
<p>在运行窗口下，输入 <strong>cmd</strong> ，打开终端命令窗口，进入解压的 ‘<strong>chardet</strong>’ 目录下，执行命令：<strong>python setup.py install</strong> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lrh4376j30r70e8q3f.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lrw665oj30r70e8jrx.jpg"></p>
<p>显示出如此的信息即可。</p>
<h3 id="（4）修改插件的原始py文件"><a href="#（4）修改插件的原始py文件" class="headerlink" title="（4）修改插件的原始py文件"></a>（4）修改插件的原始py文件</h3><p>在打开 .v 文件的 VS Code 下按 <strong>ctrl+p</strong>，输入 <strong>instance</strong> 可出现下述界面。  </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lu94p5tj311z06y3yv.jpg"></p>
<p>使用 <strong>Ctrl +单击</strong> 打开该链接，复制以下的代码来替换原文件中的代码，保存，重启  VS Code。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">vTbgenerator.py -- generate verilog module Testbench</span></span><br><span class="line"><span class="string">generated bench file like this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        fifo_sc #(</span></span><br><span class="line"><span class="string">            .DATA_WIDTH ( 8 ),</span></span><br><span class="line"><span class="string">            .ADDR_WIDTH ( 8 )</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">         u_fifo_sc (</span></span><br><span class="line"><span class="string">            .CLK   ( CLK                     ),</span></span><br><span class="line"><span class="string">            .RST_N ( RST_N                   ),</span></span><br><span class="line"><span class="string">            .RD_EN ( RD_EN                   ),</span></span><br><span class="line"><span class="string">            .WR_EN ( WR_EN                   ),</span></span><br><span class="line"><span class="string">            .DIN   ( DIN   [DATA_WIDTH-1 :0] ),</span></span><br><span class="line"><span class="string">            .DOUT  ( DOUT  [DATA_WIDTH-1 :0] ),</span></span><br><span class="line"><span class="string">            .EMPTY ( EMPTY                   ),</span></span><br><span class="line"><span class="string">            .FULL  ( FULL                    )</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">      python vTbgenerator.py ModuleFileName.v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delComment</span>(<span class="params">Text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; removed comment &quot;&quot;&quot;</span></span><br><span class="line">    single_line_comment = re.<span class="built_in">compile</span>(<span class="string">r&quot;//(.*)$&quot;</span>, re.MULTILINE)</span><br><span class="line">    multi_line_comment = re.<span class="built_in">compile</span>(<span class="string">r&quot;/\*(.*?)\*/&quot;</span>, re.DOTALL)</span><br><span class="line">    Text = multi_line_comment.sub(<span class="string">&#x27;\n&#x27;</span>, Text)</span><br><span class="line">    Text = single_line_comment.sub(<span class="string">&#x27;\n&#x27;</span>, Text)</span><br><span class="line">    <span class="keyword">return</span> Text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delBlock</span>(<span class="params">Text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; removed task and function block &quot;&quot;&quot;</span></span><br><span class="line">    Text = re.sub(<span class="string">r&#x27;\Wtask\W[\W\w]*?\Wendtask\W&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, Text)</span><br><span class="line">    Text = re.sub(<span class="string">r&#x27;\Wfunction\W[\W\w]*?\Wendfunction\W&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, Text)</span><br><span class="line">    <span class="keyword">return</span> Text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findName</span>(<span class="params">inText</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; find module name and port list&quot;&quot;&quot;</span></span><br><span class="line">    p = re.search(<span class="string">r&#x27;([a-zA-Z_][a-zA-Z_0-9]*)\s*&#x27;</span>, inText)</span><br><span class="line">    mo_Name = p.group(<span class="number">0</span>).strip()</span><br><span class="line">    <span class="keyword">return</span> mo_Name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paraDeclare</span>(<span class="params">inText, portArr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; find parameter declare &quot;&quot;&quot;</span></span><br><span class="line">    pat = <span class="string">r&#x27;\s&#x27;</span> + portArr + <span class="string">r&#x27;\s[\w\W]*?[;,)]&#x27;</span></span><br><span class="line">    ParaList = re.findall(pat, inText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ParaList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">portDeclare</span>(<span class="params">inText, portArr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;find port declare, Syntax:</span></span><br><span class="line"><span class="string">       input [ net_type ] [ signed ] [ range ] list_of_port_identifiers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       return list as : (port, [range])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    port_definition = re.<span class="built_in">compile</span>(</span><br><span class="line">        <span class="string">r&#x27;\b&#x27;</span> + portArr +</span><br><span class="line">        <span class="string">r&#x27;&#x27;&#x27; (\s+(wire|reg)\s+)* (\s*signed\s+)*  (\s*\[.*?:.*?\]\s*)*</span></span><br><span class="line"><span class="string">        (?P&lt;port_list&gt;.*?)</span></span><br><span class="line"><span class="string">        (?= \binput\b | \boutput\b | \binout\b | ; | \) )</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>,</span><br><span class="line">        re.VERBOSE | re.MULTILINE | re.DOTALL</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    pList = port_definition.findall(inText)</span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> ls <span class="keyword">in</span> pList:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ls) &gt;= <span class="number">2</span>:</span><br><span class="line">            t = t + portDic(ls[-<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">portDic</span>(<span class="params">port</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;delet as : input a =c &amp;d;</span></span><br><span class="line"><span class="string">        return list as : (port, [range])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pRe = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(.*?)\s*=.*&#x27;</span>, re.DOTALL)</span><br><span class="line"></span><br><span class="line">    pRange = port[<span class="number">0</span>]</span><br><span class="line">    pList = port[<span class="number">1</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    pList = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> pList <span class="keyword">if</span> i.strip() != <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    pList = [(pRe.sub(<span class="string">r&#x27;\1&#x27;</span>, p), pRange.strip()) <span class="keyword">for</span> p <span class="keyword">in</span> pList]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatPort</span>(<span class="params">AllPortList, isPortRange=<span class="number">1</span></span>):</span><br><span class="line">    PortList = AllPortList</span><br><span class="line"></span><br><span class="line">    <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> PortList != []:</span><br><span class="line">        l1 = <span class="built_in">max</span>([<span class="built_in">len</span>(i[<span class="number">0</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> PortList])+<span class="number">2</span></span><br><span class="line">        l3 = <span class="built_in">max</span>(<span class="number">18</span>, l1)</span><br><span class="line"></span><br><span class="line">        strList = []</span><br><span class="line">        <span class="built_in">str</span> = <span class="string">&#x27;,\n&#x27;</span>.join([<span class="string">&#x27; &#x27;</span> * <span class="number">4</span> + <span class="string">&#x27;.&#x27;</span> + i[<span class="number">0</span>].ljust(l3)</span><br><span class="line">                          + <span class="string">&#x27;(&#x27;</span> + (i[<span class="number">0</span>]) + <span class="string">&#x27;)&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> AllPortList])</span><br><span class="line">        strList = strList + [<span class="built_in">str</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">str</span> = <span class="string">&#x27;,\n\n&#x27;</span>.join(strList)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatDeclare</span>(<span class="params">PortList, portArr, initial=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> PortList != []:</span><br><span class="line">        <span class="built_in">str</span> = <span class="string">&#x27;\n&#x27;</span>.join([portArr.ljust(<span class="number">4</span>) + <span class="string">&#x27;  &#x27;</span>+(i[<span class="number">1</span>]+<span class="built_in">min</span>(<span class="built_in">len</span>(i[<span class="number">1</span>]), <span class="number">1</span>)*<span class="string">&#x27;  &#x27;</span></span><br><span class="line">                                                  + i[<span class="number">0</span>]) + <span class="string">&#x27;;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> PortList])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatPara</span>(<span class="params">ParaList</span>):</span><br><span class="line">    paraDec = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    paraDef = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> ParaList != []:</span><br><span class="line">        s = <span class="string">&#x27;\n&#x27;</span>.join(ParaList)</span><br><span class="line">        pat = <span class="string">r&#x27;([a-zA-Z_][a-zA-Z_0-9]*)\s*=\s*([\w\W]*?)\s*[;,)]&#x27;</span></span><br><span class="line">        p = re.findall(pat, s)</span><br><span class="line"></span><br><span class="line">        l1 = <span class="built_in">max</span>([<span class="built_in">len</span>(i[<span class="number">0</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> p])</span><br><span class="line">        l2 = <span class="built_in">max</span>([<span class="built_in">len</span>(i[<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> p])</span><br><span class="line">        paraDec = <span class="string">&#x27;\n&#x27;</span>.join([<span class="string">&#x27;parameter %s = %s;&#x27;</span></span><br><span class="line">                             % (i[<span class="number">0</span>].ljust(l1 + <span class="number">1</span>), i[<span class="number">1</span>].ljust(l2))</span><br><span class="line">                             <span class="keyword">for</span> i <span class="keyword">in</span> p])</span><br><span class="line">        paraDef = <span class="string">&#x27;#(\n&#x27;</span> + <span class="string">&#x27;,\n&#x27;</span>.join([<span class="string">&#x27;    .&#x27;</span> + i[<span class="number">0</span>].ljust(l1 + <span class="number">1</span>)</span><br><span class="line">                                       + <span class="string">&#x27;( &#x27;</span> + i[<span class="number">1</span>].ljust(l2)+<span class="string">&#x27; )&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> p]) + <span class="string">&#x27;)\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> paraDec, paraDef</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">portT</span>(<span class="params">inText, ioPadAttr</span>):</span><br><span class="line">    x = &#123;&#125;</span><br><span class="line">    count_list = []</span><br><span class="line">    order_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ioPadAttr:</span><br><span class="line">        p = port_index_list(inText, i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> p:</span><br><span class="line">            count_list.append(j)</span><br><span class="line">            x[j] = i</span><br><span class="line">    count_list = quick_sort(count_list, <span class="number">0</span>, <span class="built_in">len</span>(count_list)-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> count_list:</span><br><span class="line">        order_list.append(x.get(c))</span><br><span class="line">    <span class="keyword">return</span> order_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">myList, start, end</span>):</span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        i, j = start, end</span><br><span class="line">        base = myList[i]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) <span class="keyword">and</span> (myList[j] &gt;= base):</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            myList[i] = myList[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) <span class="keyword">and</span> (myList[i] &lt;= base):</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            myList[j] = myList[i]</span><br><span class="line">        myList[i] = base</span><br><span class="line"></span><br><span class="line">        quick_sort(myList, start, i - <span class="number">1</span>)</span><br><span class="line">        quick_sort(myList, j + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> myList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">formatPort_order</span>(<span class="params">padAttr, orderList</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> padAttr:</span><br><span class="line">        q = Queue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> padAttr.get(p):</span><br><span class="line">            q.put(i)</span><br><span class="line">        padAttr[p] = q</span><br><span class="line">    AllPortList = []</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> orderList:</span><br><span class="line">        AllPortList.append(padAttr.get(o).get())</span><br><span class="line">    <span class="keyword">return</span> AllPortList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">port_index_list</span>(<span class="params">intext, text</span>):</span><br><span class="line">    l = []</span><br><span class="line">    t = intext</span><br><span class="line">    index = t.find(text)</span><br><span class="line">    <span class="keyword">while</span> index &gt; -<span class="number">1</span>:</span><br><span class="line">        t = t.replace(text, random_str(<span class="built_in">len</span>(text)), <span class="number">1</span>)</span><br><span class="line">        l.append(index)</span><br><span class="line">        index = t.find(text)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_str</span>(<span class="params">size</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        s += <span class="built_in">str</span>(random.randint(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPortMap</span>(<span class="params">AllPortList, ioPadAttr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(AllPortList) != <span class="built_in">len</span>(ioPadAttr):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    p_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(AllPortList)):</span><br><span class="line">        p_map[ioPadAttr[i]] = AllPortList[i]</span><br><span class="line">    <span class="keyword">return</span> p_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writeTestBench</span>(<span class="params">input_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; write testbench to file &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_info = chardet.detect(f.read())</span><br><span class="line">        f_encoding = f_info[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, encoding=f_encoding) <span class="keyword">as</span> inFile:</span><br><span class="line">        inText = inFile.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># removed comment,task,function</span></span><br><span class="line">    inText = delComment(inText)</span><br><span class="line">    inText = delBlock(inText)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># moduel ... endmodule  #</span></span><br><span class="line">    moPos_begin = re.search(<span class="string">r&#x27;(\b|^)module\b&#x27;</span>, inText).end()</span><br><span class="line">    moPos_end = re.search(<span class="string">r&#x27;\bendmodule\b&#x27;</span>, inText).start()</span><br><span class="line">    inText = inText[moPos_begin:moPos_end]</span><br><span class="line"></span><br><span class="line">    name = findName(inText)</span><br><span class="line">    paraList = paraDeclare(inText, <span class="string">&#x27;parameter&#x27;</span>)</span><br><span class="line">    paraDec, paraDef = formatPara(paraList)</span><br><span class="line"></span><br><span class="line">    ioPadAttr = [<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;inout&#x27;</span>]</span><br><span class="line">    orlder = portT(inText, ioPadAttr)</span><br><span class="line">    <span class="built_in">input</span> = portDeclare(inText, ioPadAttr[<span class="number">0</span>])</span><br><span class="line">    output = portDeclare(inText, ioPadAttr[<span class="number">1</span>])</span><br><span class="line">    inout = portDeclare(inText, ioPadAttr[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    portList = formatPort(formatPort_order(</span><br><span class="line">        getPortMap([<span class="built_in">input</span>, output, inout], ioPadAttr), orlder))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span> = formatDeclare(<span class="built_in">input</span>, <span class="string">&#x27;reg&#x27;</span>)</span><br><span class="line">    output = formatDeclare(output, <span class="string">&#x27;wire&#x27;</span>)</span><br><span class="line">    inout = formatDeclare(inout, <span class="string">&#x27;wire&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write Instance</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># module_parameter_port_list</span></span><br><span class="line">    <span class="keyword">if</span>(paraDec != <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;// %s Parameters\n%s\n&quot;</span> % (name, paraDec))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># list_of_port_declarations</span></span><br><span class="line">    <span class="comment">#print(&quot;// %s Inputs\n%s\n&quot; % (name, input))</span></span><br><span class="line">    <span class="comment">#print(&quot;// %s Outputs\n%s\n&quot; % (name, output))</span></span><br><span class="line">    <span class="comment">#if(inout != &#x27;&#x27;):</span></span><br><span class="line">    <span class="comment">#    print(&quot;// %s Bidirs\n%s\n&quot; % (name, inout))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="comment"># UUT</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s %s inst_%s (\n%s\n);&quot;</span> % (name, paraDef, name, portList))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     writeTestBench(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>


<h3 id="（5）效果展示"><a href="#（5）效果展示" class="headerlink" title="（5）效果展示"></a>（5）效果展示</h3><p>在快捷键 <strong>ctrl + shift + p</strong> 下打开命令行，输入 <strong>Testbench</strong>  或者 <strong>Instance</strong> 。</p>
<p>输入 Instance，仅仅是对该 .v 文件模块的快速例化；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lupqhr0j312406zq36.jpg"></p>
<p>输入 Testbench，可以得到一个更为完整的测试文件；</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/sinat_28631741/article/details/80483064">python–“chardet”安装方式</a></p>
<p><a href="https://www.cnblogs.com/kingstacker/p/9944259.html">Vscode自动生成verilog例化</a></p>
</blockquote>
<br />

<blockquote>
<p> 本文来自实验室同学 <a href="https://weibo.com/u/5733142591">@WanTwoWan</a> 投稿，在此表示感谢 🍰</p>
</blockquote>
<br />

<br />

<br />

]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado与VS Code:强强联手3-自动对齐代码</title>
    <url>/posts/5546.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626212130.jpg"></p>
<p>写程序的过程中，有时候难免要从网上直接寻找一些代码来修改。但经常会碰到代码格式不规范的情况，所以如果能够自动将代码格式规范化，或者对齐代码来符合自身的编程习惯，就很方便后续的修改等工作。此次就来在 VS Code上实现这一功能。🥤</p>
<span id="more"></span>



<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        写程序的过程中，有时候难免要从网上直接寻找一些代码来修改。但经常会碰到代码格式不规范的情况，所以如果能够自动将代码格式规范化，或者对齐代码来符合自身的编程习惯，就很方便后续的修改等工作。此次就来在 VS Code上实现这一功能。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>自动对其代码的大致步骤如下：</p>
<p>（1）在VS Code中安装插件  <strong>Verilog Format</strong> ；</p>
<p>（2）在插件  Verilog Format 中打开链接下载 压缩包：<strong>verilog-format-WIN.zip</strong>；</p>
<p>（3）<strong>Java</strong>环境配置 ； </p>
<p>（4）添加到系统变量及验证；</p>
<p>（5）效果展示。</p>
<h3 id="（1）在VS-Code中安装插件-Verilog-Format"><a href="#（1）在VS-Code中安装插件-Verilog-Format" class="headerlink" title="（1）在VS Code中安装插件  Verilog Format"></a>（1）在VS Code中安装插件  Verilog Format</h3><p>具体的使用方法为：快捷键 Alt+Shift+F </p>
<p>全选代码，并按 <strong>Alt+Shift+F</strong> 对齐代码时，弹出提示安装插件，点击install安装；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lw8qq5hj30d7031mx1.jpg"></p>
<p>可以直接点击该提示，或者在 VS Code的应用商店搜索并安装插件  Verilog Format ；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwd87mcj30j5097wf9.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwaegzzj30sj0gimz0.jpg"></p>
<h3 id="（2）在插件-Verilog-Format中打开链接下载-压缩包：verilog-format-WIN-zip"><a href="#（2）在插件-Verilog-Format中打开链接下载-压缩包：verilog-format-WIN-zip" class="headerlink" title="（2）在插件 Verilog Format中打开链接下载 压缩包：verilog-format-WIN.zip"></a>（2）在插件 Verilog Format中打开链接下载 压缩包：verilog-format-WIN.zip</h3><p>按如下的图示进行操作：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwf23v2j30sd0ab0u6.jpg"></p>
<p>找到如下所示的 Install verilog-format ，点击进入</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwhfsjej30r20gldhb.jpg"></p>
<p>找到如下所示的压缩包文件，点击链接进入：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwiy3jzj30f104at8u.jpg"></p>
<p>下载：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwl5b0jj30se0cst9v.jpg"></p>
<p>下载之后解压到自己设定的路径下，后续的设置会用到该路径。</p>
<p>在VS Code中，进入插件 <strong>verilog-format</strong> 的设置下，这里的路径填写压缩包的解压路径。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwo4xjxj30ku09vaab.jpg"></p>
<h3 id="（3）-Java环境配置"><a href="#（3）-Java环境配置" class="headerlink" title="（3） Java环境配置"></a>（3） Java环境配置</h3><p>缺少Java环境时，使用快捷键 <strong>Alt+Shift+F</strong> 对齐代码时，会自动跳转到 Java 的下载界面，该地址下载的是在线安装包。<br>换个地址，下载离线包来安装，</p>
<p>下载地址：<a href="https://www.java.com/zh_CN/download/windows_offline.jsp">https://www.java.com/zh_CN/download/windows_offline.jsp</a></p>
<p>进行 Java 的安装，安装过程如下，如果已安装，则跳过该安装过程。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwpxh6nj30ji0alt9f.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwrikuyj30ji0al74g.jpg"></p>
<p>默认安装系统盘，建议安装非系统盘；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwtkc0nj30ji0alglr.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwv2lzuj30ji0alq3w.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwx2idoj30ji0alaa8.jpg"></p>
<h3 id="（4）添加到系统变量及验证"><a href="#（4）添加到系统变量及验证" class="headerlink" title="（4）添加到系统变量及验证"></a>（4）添加到系统变量及验证</h3><p>安装 Java 会自动添加一个环境变量；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lwyup0sj30h60ib3z8.jpg"></p>
<p>然后根据安装地址将 Java 添加到系统变量下：</p>
<p>变量名不变，变量值根据路径来确定。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lx0snomj30h80ibgm6.jpg"></p>
<p>在运行窗口下，输入 <strong>cmd</strong> ，打开终端命令窗口，进行验证！</p>
<p>cmd下依次运行:<br><strong>java</strong><br><strong>java -version</strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lx2udkjj30r70e83yf.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lx4jgu2j30r70e8wez.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lx5n7btj30r70e874s.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lx8tvarj30r70e8mxn.jpg"></p>
<p>出现该信息则为成功；</p>
<h3 id="（5）效果展示"><a href="#（5）效果展示" class="headerlink" title="（5）效果展示"></a>（5）效果展示</h3><p>没有对齐效果时：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lxa71gfj30bz0av74i.jpg"></p>
<p>在快捷键 <strong>Alt+Shift+F</strong> 下，对齐代码时效果如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/006fZGhNly1gg5lxbryqlj30bz0avdfy.jpg"></p>
<br />

<br />

<blockquote>
<p>本文来自实验室同学 <a href="https://weibo.com/u/5733142591">@WanTwoWan</a> 投稿，在此表示感谢 ，若您有更多问题可以联系他哦 </p>
</blockquote>
<br />

<br />

<br />]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>周志华教授谈如何做研究与写论文</title>
    <url>/posts/23515.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626181450.jpg"></p>
<p>无意间看到“西瓜书”的作者 周志华老师 的一次报告，题目是《如何做研究与写论文？》。觉得分享的内容很有帮助，值得读一读，因此贴在了本篇博文中。 🍉</p>
<span id="more"></span>



<blockquote>
<p>每个人从本科到硕士，再到博士、博士后，甚至工作以后，都会遇到做研究、写论文这个差事。论文通常是对现有工作的一个总结和展示，特别对于博士和做研究的人来说，论文则显得更加重要。</p>
<p>那么该如果做突出研究，并写出高水平的论文呢？</p>
<p>本文整理了著名人工智能学者<strong>周志华</strong>教授《做研究与写论文》的PPT(时间比较早，但方法永远不会过时)。其详细介绍了关于为什么要做研究？如何做研究，选择研究方向、选择研究课题(Topic)，学习领域知识、选期刊投稿、稿件处理过程、写高水平论文的方法与技巧等方面的知识，是一份非常优秀的做研究和写论文指南，值得每个人细读！</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0001.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175323.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175347.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175401.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175417.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175427.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175441.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175459.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0009.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0010.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0011.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0012.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0013.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0014.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0015.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0016.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175839.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175914.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0019.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0020.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/0021.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626175939.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180001.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180009.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180020.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180032.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180043.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180051.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180107.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180115.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180123.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180144.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180153.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180159.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180207.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180217.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180223.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180232.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180240.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180254.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180301.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180307.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180316.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180324.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180331.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180339.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180346.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180354.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180402.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180412.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180421.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180429.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180437.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180444.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180450.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180502.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180510.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180517.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180525.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200626180533.png"></p>
<br />

<p>报告的PPT下载（PDF版）：</p>
<p><a href="https://www.lanzous.com/igOsqe2088h">https://www.lanzous.com/igOsqe2088h</a></p>
<br />

<br />







<blockquote class="blockquote-center">
<p>学而不思则罔，思而不学则殆。</p>
<p>–《论语》</p>

</blockquote>

<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>分享</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>全平台开源绘图利器 Draw.io</title>
    <url>/posts/18175.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628210339.jpg"></p>
<p>Draw.io 是一款优秀的全平台开源绘图软件，支持在线绘图，而且还支持在 VS Code 中绘图。操作简便，内置模板丰富，支持导出 <code>png </code>、<code>svg</code> 、<code>VSDX</code>(Visio格式) 、<code>PDF</code> 等格式的文件。简直优秀至极，赶快去试一试吧。😉</p>
<span id="more"></span>



<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>首先看一下各个平台的 Draw io 🍻</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628203416.png" alt="桌面端演示"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628203255.png" alt="VS Code 演示"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628203341.png" alt="导出后用Visio打开"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628203649.png" alt="网页端演示"></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>根据自身喜好选择在线绘图，或者下载桌面端。</p>
<p>在线绘图: <a href="https://www.draw.io/?lang=zh">https://www.draw.io/?lang=zh</a></p>
<p>下载(Github Release) : <a href="https://github.com/jgraph/drawio/releases">https://github.com/jgraph/drawio/releases</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628171718.png"></p>
<p>下载时可根据 OS 选择不同的版本，windows平台有安装版与免安装版。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628172208.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628171940.png" alt="在线绘图示例"></p>
<h2 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h2><p>不论在windows、mac、还是透过浏览器使用draw.io，第一次使用时会出现下面的画面，可以选择Google Drive（google云端）、OneDrive（Microsoft云端）或Device（本机硬盘），依自已的喜好点选，如果真的不知道要选什么，请使用Device（本机硬盘），直接将档案存放在所操作的电脑中</p>
<p>右下角的「Language」点击后可以切换，点击要使用的语言后，使用浏览器的在线版请点击「重新加载」或直接按「F5」键，使用桌面版请关闭程序后再重新启动即可</p>
<p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LdydZP_hsYeTeVUpPcf%2F-Ldyd_rCCzK2yvYaWEI3%2F-LdydgnPX-THlkkORiQ3%2F1-1.png?alt=media" alt="img"></p>
<h3 id="保存在本地硬盘"><a href="#保存在本地硬盘" class="headerlink" title="保存在本地硬盘"></a>保存在本地硬盘</h3><p>填入文件名，然后选择一个模板，也可以选择空白。选择一个合适的模板，会提高绘图效率。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628173111.png"></p>
<h3 id="保存在云端"><a href="#保存在云端" class="headerlink" title="保存在云端"></a>保存在云端</h3><p>若如果点选Google Drive的话会出现如下的画面，需要点选「Authorize」授权</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8aeout4ej20av07gdfy.jpg" alt="image"></p>
<p>按顺输入 google 账户和密码</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8aexvr33j20h30iyjs6.jpg" alt="image"></p>
<p>登录成功会看到如下的画面，如果之后不想用Google Drive，可以选「change storage」做切换</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8af5nz6nj20bo09ijrr.jpg" alt="image"></p>
<p>点击 “Create New Diagram”后会出现如下的画面，可以选现有的模板或者空白图表，选好后，请点击右下角的「新增」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628173111.png"></p>
<p>「Use root folder？」 这是问您是否要在google drive的根目录（google drive的第一层文件夹）做新增，如果要在根目录新增请点击「是」，若想要放在自订的文件夹中，请选择「No， pick folder…」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8afotzkhj20jd0ejaao.jpg" alt="image"></p>
<p>点击「No， pick folder…」的用户会看到如下图的google driver的「选择目录」页面，请点击要储存的文件夹后，点击左下方的「选取」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8afwshudj20tp0in751.jpg" alt="image"></p>
<p>点击”选取”后，此文件就直接储存在 google drive 中，可以通过左上角的图案，点选后会打开目前档案所存放在 google drive 的目录页面</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8ag531spj211b08a75a.jpg" alt="image"></p>
<p>系统预设只有Google Drive（google云端）、OneDrive（Microsoft云端）或Device（本机硬盘），但其实还有更多的选择，如果选择Device（本机硬盘）的话，点选画面最上方的「档案-&gt;另存新档」就会出现如下的画面，可以存放在地方，例如github及dropbox等… 这部分有空时后可以试试</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg8agbw9s9j20ex0d3q3n.jpg" alt="image"></p>
<h2 id="操作界面简介"><a href="#操作界面简介" class="headerlink" title="操作界面简介"></a>操作界面简介</h2><p>draw.io打开后，会看到如下的画面，和一般的软件操作区块差不多</p>
<ul>
<li>功能菜单：最上方有”文件、编辑、查看”等</li>
<li>工具栏：位于功能菜单的下方，主要提供放大、缩小、删除、等功能，都是图标，看不懂可以将鼠标移过去后会有提示说明</li>
<li>图形库：在软件的最左方为可以使用的图形库，可在最下方的「+更多图形…」去新增或删除，自定义要显示的图形库内容</li>
<li>格式面版：在软件的最右方，当鼠标点击到某图形、文字、图表时会自动切换成被选取组件可以设置的参数内容</li>
<li>编辑区：软件正中间，要编辑的块，点击图形库内的图形后，会自动把所点选的图形插入到编辑区中</li>
<li>标签：位于编辑区的最下方，有一个像excel的页面功能，可以建立不同的标签在同一个文件中</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628192901.png"></p>
<h2 id="简单的操作帮助"><a href="#简单的操作帮助" class="headerlink" title="简单的操作帮助"></a>简单的操作帮助</h2><h3 id="添加文本框"><a href="#添加文本框" class="headerlink" title="添加文本框"></a>添加文本框</h3><ul>
<li>图形说明文字：直接在图片、图形上用鼠标快点左键两下就会出现文字输入的光标”|」 在闪，这个位置不一定，有的会在图形的中间、有的会在下方、右方…，如果不清楚就先输入要显示的文字就看得到了</li>
<li>纯文本区块：新增的方式就在图表空白的地方直接用鼠标快点左键两下就会新增一个文字块</li>
</ul>
<h3 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h3><p>一般来说点选图形后会出现三个页面，分别为</p>
<ul>
<li><p>对象样式：可修改图形的颜色、边线、透明度及一些特效（圆角、手绘等）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628204828.png"></p>
</li>
<li><p>文字：文字的设定就和word差不多，而且图标都一样，但字体的部分目前中文字是没办法俢改的</p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628204848.png"></p>
<p>不论是在图形上的文字还是纯文字区块，別头串的方式都一样，直接用鼠标点选要配置的文字区块或图形后再到右方的格式面版设定，点选鼠标一下所设定的文字是全部文字一起修改。 如果要部分文字修改，请改用鼠标快点左键两下就会切换成文字输入模式，用鼠标拉选要设定的文字内容，然后再到右方的格式面版去做设定，这部分要注意一下，要先选取要设定的文字后设定才有用，可以设定每一个文字的大小、颜色格式等… 如下图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628205015.png"></p>
<ul>
<li>调整：在此设定该图形的大小和位置和角度</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628205036.png"></p>
<p>一般来说除非要特别去设定，要不然都是在点选图形后，会出现如下图在周围会有蓝色的点，可以去拉动改变大小，而上方黑军的像一个圈的图，可以拉动改变角度</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628205135.png"></p>
<h3 id="查看图表内容"><a href="#查看图表内容" class="headerlink" title="查看图表内容"></a>查看图表内容</h3><p>检查图表，一般来说都可以用鼠标去点选工具栏上有+、-符号的放大镜来放大或缩小，上下左右移则可以拉动图表编辑区的右方及下方的滚轴去观看，那下方主要是透过键盘及鼠标来快速浏览</p>
<ul>
<li>放大：先按ctrl或alt键后，鼠标滚轮往上推</li>
<li>缩小：先按ctrl或alt键后，鼠标滚轮往下推</li>
<li>看图表的上方：鼠标滚轮往上推</li>
<li>看图表的下方：鼠标滚轮往下推</li>
<li>看图表的左方：先按shift键后，鼠标滚轮往上推</li>
<li>看图表的右方：先按shift键后，鼠标滚轮往下推</li>
<li>重置：ctrl+h 键</li>
<li>自由移动：真的很不习惯鼠标滚来滚去的人，可以通过按住鼠标右键，然后拉动即可，如果鼠标的滚轮有支持点选功能的，也可以按住鼠标滚轮来移动</li>
<li>画略图：当画面的内容很多，然后又需要放很大来俢改时，可以通过画略图来看目前编辑的块在整个图表的那个区块，可以拉动画略图中蓝色的方框移到想看的位置，右下角的蓝点可以改变观看的范围</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628204703.png"></p>
<h3 id="线条连接点在图形中任意位置"><a href="#线条连接点在图形中任意位置" class="headerlink" title="线条连接点在图形中任意位置"></a>线条连接点在图形中任意位置</h3><p>因为图形或线条在拉动时会有吸附及固定距离移动，当要把线条拉动到图形的中间时一般的拉动是没办法的，此时可以透过先拉动线条后再按alt键就可以自由移动</p>
<h3 id="快速复制"><a href="#快速复制" class="headerlink" title="快速复制"></a>快速复制</h3><p>一般快速复制就是ctrl+c（复制）然后再ctrl+v（贴上）然后再把新复制的东西移到要放的位置，如果要再快一点，例如要复制很多的个同样的图形或文字到不同的位置，可以先按键 ctrl 键，然后再用鼠标点选中图形、文字不放，接着拉动，在拉动时会有该图形的外框，移到要放的位置后，再放开鼠标（ctrl键不放），可以一直随意拉动复制</p>
<h3 id="图形对齐和等距"><a href="#图形对齐和等距" class="headerlink" title="图形对齐和等距"></a>图形对齐和等距</h3><p>当图形有很多，就会需要用到对齐及等距，让画面看起来比较漂亮，可以透过最上方的功能菜单「调整-&gt;对齐」及「调整-&gt; 等距分布」来处理，在点选前需要先把要处理的图形先选取起来，选取的方式可以用鼠标拉动一个范围来圈选，另外也可以透过按住ctrl或shift后去点选要的图形，这边建议使用shift，因为ctrl按着后再用鼠标点选图形不小心拉动后就变成复制的功能</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628204625.png"></p>
<h2 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h2><p>Draw.io操作画面的最左方就是图库，里面有几个区块，如下图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628193354.png"></p>
<h3 id="搜索形状"><a href="#搜索形状" class="headerlink" title="搜索形状"></a>搜索形状</h3><p>可以通过这个区块，用关键字去寻找是否有可以使用的图形，但需要输入英文字，目前测试中文字是无法找到内容，如下图测试使用「爱心」及「fheart」</p>
<ul>
<li><p>爱心：未找到相关结果</p>
</li>
<li><p>heart：相关内容会显示在下方，最下面还有「更多结果」，可点击观看</p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628193719.png"></p>
<h3 id="便笺本"><a href="#便笺本" class="headerlink" title="便笺本"></a>便笺本</h3><p>这东西有点像便利贴的功能，该区块的底字「把元件拖到这里」，使用的方式就是如此简单，把自已设计好而且需要重复使用的元件，拖到此区块，之后要使用时就可以直接点选加入，如下图自已建立了一个防火墙的图，然后加文字改颜色，然后把此组件点选拖到便签本区块后就会自已建立，之后要使用时，直接点选就会加到中间的图表编辑区了</p>
<p>注意看在便签本的右方有一个「？」 这是帮助的功能，会打开官方的说明文件，里面还有动画，看了就知道如何使用，网址如下</p>
<p><a href="https://desk.draw.io/support/solutions/articles/16000042367">https://desk.draw.io/support/solutions/articles/16000042367</a>     </p>
<p>新增只要把图形拖到区块中即可，那删除就没办法直接del，需要点选右方「笔」编辑的图案，点击后会出现如下的编辑视窗，直接点击该图形右上角的「x」图，就可以删除，点选右下角的「储存」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628193927.png"></p>
<h3 id="其它图形库"><a href="#其它图形库" class="headerlink" title="其它图形库"></a>其它图形库</h3><p>其他看到通用、杂项、高级….. 很多的图形都是通过下方的”+更多图形…”来新增，可点击名称展开或收合</p>
<h3 id="更多图形…"><a href="#更多图形…" class="headerlink" title="+更多图形…"></a>+更多图形…</h3><p>可以通过此选项，去设定要显示在左方图形库中的内容，依自已的需求设定新增或删除，点击「+更多图形…」后会出现如下图的窗口，可以点选左边的项目，右边会出现该项目的图形内容，想要 使用的话就在前方的方框点选打勾，再点击右下角的「套用」，注意一下，下方有个「记住设定」，有勾选的话，下次再开起软件，所选的图形库就会一起载入</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194217.png"></p>
<h3 id="添加图库"><a href="#添加图库" class="headerlink" title="添加图库"></a>添加图库</h3><p>如果要创建像模板中的Mikrotik.xml图库，可以从功能菜单的「档案-&gt;新增图库」来新增，如下图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194332.png"></p>
<p>点击”文件-&gt;添加图库”后会出现如下的窗口，先修改文件名称，然后依图面上的文字「把图片或链接干到这里」，就可以加入到图库中</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194401.png"></p>
<p>从电脑文件夹中选取要的图片，点击然后拖拉到此区块中就会自动加入，点击下方文字可以编名图档名称，确认好后，点击右下角的「保存」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194529.png"></p>
<p>保存好后，回到draw.io的操作画面，就会在左方的图形库中看到刚刚所建立的「未命名图库.xml」</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194635.png"></p>
<h3 id="打开图库"><a href="#打开图库" class="headerlink" title="打开图库"></a>打开图库</h3><p>要載入自訂的圖庫，可以從功能選單的「檔案-&gt;開啟圖庫」，選取xml圖庫檔後，就會自動載入，可在左方的圖形庫中找到</p>
<p>要导入自定义的图库，可以从功能菜单的「文件-&gt;打开图库」，选取xml图库文件后，就会自动加载，可在左方的图形库中找到</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628194829.png"></p>
<h2 id="底图"><a href="#底图" class="headerlink" title="底图"></a>底图</h2><p>添加底图当前有2种方式</p>
<ol>
<li>页面设置</li>
<li>直接将文件拖曳到编辑画面</li>
</ol>
<h3 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h3><p>可以从功能功中的”文件-&gt;页面设置”，如下图，点击图片旁边的”变更”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628195032.png"></p>
<p>按画面中的提示「把图片或链接拖到这里」，然后点选套用后，就可以看到图片加载到画面中，但无法点选到底图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628195105.png"></p>
<p>直接点选底图然后拖曳到draw.io中的编辑画面，底图就会出现在画面中，接着点选底图，右边就会出现如下图的功能列，请点击「调整图形」分页，然后点击移到最后，背景就出现啦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628195652.png"></p>
<p>页面设定方式，不会将底图加入图层中，真的只是背景，所以通过图层（查看-&gt;图层 Ctrl+Shift+L），去把目前的图层的勾勾取消时，背景还是显示在画面中，但通过「直接将背景图片拖曳到编辑画面」的方式时，该底图就是存在于图层中，所以可以控制是否显示底图。当然我们可以利用图层来放背景图，另一个图层画图形。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628200036.png"></p>
<h3 id="背景底图总结"><a href="#背景底图总结" class="headerlink" title="背景底图总结"></a>背景底图总结</h3><p>使用「页面设定」的方式加入底图，在画图加物件时，不会移动到底图，因为它只是背景，但使用「直接将背景图片拖曳到编辑画面」这种方式，加物件拉动时可能不小心移动到底图，那处理方式就是先点底图，然后在编辑中选择锁定，或者用快捷键 Ctrl + L 锁定住背景图。这样就不会造成对象和底图的位置跑掉。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628202125.png"></p>
<p>另一个比较好的方式就是使用「直接将背景图片拖曳到编辑画面」+「图层」，意思就是把底图就设定为一个图层，其它对象就新增图层去处理，然后可以把底图的图层做锁定，如下图，背景为底图的图层，然后前方有一个锁的图案，点选后可以「锁定&#x2F;解锁」，锁定后就不会再点选到底图喽！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200628202407.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Draw.io 十分好用，上手容易，绘制的图形美观简介。 关于其它没有讲解到的内容与用法可以在网络上搜一下就有啦 🌞</p>
<br />

<br />

<p>参考</p>
<blockquote>
<p><a href="https://github.com/jgraph/drawio">https://github.com/jgraph/drawio</a></p>
<p><a href="https://gxiangco.gitbook.io/draw-io/">gitbook Draw.io</a></p>
</blockquote>
<br />

<br />

<h2 id=""><a href="#" class="headerlink" title=""></a><br /></h2><blockquote class="blockquote-center">
<p>深夜无风新雨歇，凉月，露迎珠颗入圆荷。</p>
<p>–《定风波·江水沉沉帆影过》</p>

</blockquote>



<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>善用佳软</tag>
        <tag>开源</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 控件自适应窗口大小布局</title>
    <url>/posts/52368.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/landscape-mountains-nature-sky-129105_compressed.jpg"></p>
<p>Qt Creator 中为 UI 界面的窗体控件设置自适应窗口大小布局</p>
<span id="more"></span>

<p>一般的应用软件除了最大化最小化外都会让窗体中的控件能够自适应的改变大小。C#、Android以及Qt 中都有自己的一套布局方案。而在Qt中我却扰了弯路，确切的说应该是忘记了以前怎样布局的。网上很多人都是去用代码布局的，我觉得既然有了界面布局那就得用起来，所见即所得，改需求也会方便不少。</p>
<h2 id="布局概述"><a href="#布局概述" class="headerlink" title="布局概述"></a>布局概述</h2><p>Qt 布局系统提供了一种简单而强大的方法，可以在一个 widget 中自动排列子 widget ，以确保它们充分利用可用空间。</p>
<p>Qt 包括一组布局管理类，用于描述 widget  如何在应用程序的界面中布局。当可用空间变化时，这些布局可以自动定位和调整窗口 widget  的大小，确保它们的布局一致。</p>
<p>所有 QWidget 子类都可以使用布局来管理它们的子类。<code> QWidget::setLayout()</code>函数的作用是: 将布局应用于小部件。当一个布局以这种方式设置在一个小部件上时，它将负责以下任务:</p>
<ul>
<li>Positioning of child widgets  子窗口widget 的位置</li>
<li>Sensible default sizes for windows 合理的默认窗口大小</li>
<li>Sensible minimum sizes for windows 合理的窗户最小尺寸</li>
<li>Resize handling 调整尺寸</li>
<li>Automatic updates when contents change 内容更改时自动更新:</li>
<li>Font size, text or other contents of child widgets 字体大小，文本或其他内容的子部件</li>
<li>Hiding or showing a child widget 隐藏或显示子窗口小部件</li>
<li>Removal of child widgets 删除子窗口部件</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/graphicsanchorlayout-example.png"></p>
<h2 id="常用布局方式"><a href="#常用布局方式" class="headerlink" title="常用布局方式"></a>常用布局方式</h2><p>常用的布局方式有 Horizontal  水平, Vertical 垂直, Grid 网格, 和 Form Layouts 窗体布局 。善于结合多种布局方式不能界面美观大方，而且也能够使维护或修改布局变得十分惬意。</p>
<p>为 widgets 提供良好布局的最简单方法是使用内置布局管理器：QHBoxLayout、QVBoxLayout、QGridLayout和QFormLayout。这些类继承自QLayout，而QLayout又派生自QObject(而不是QWidget)。要创建更复杂的布局，可以将布局管理器嵌套在彼此内部。为了将界面上的各个组件的分布设计得更加美观，经常使用一些容器类，如 QgoupBox、QtabWidget、QFrame 等。</p>
<table>
<thead>
<tr>
<th>布局组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Vertical Layout</td>
<td>垂直方向布局，组件自动在垂直方向上分布</td>
</tr>
<tr>
<td>Horizontal Layout</td>
<td>水平方向布局，组件自动在水平方向上分布</td>
</tr>
<tr>
<td>Grid Layout</td>
<td>网格状布局，网状布局大小改变时，每个网格的大小都改变</td>
</tr>
<tr>
<td>Form Layout</td>
<td>窗体布局，与网格状布局类似，但是只有最右侧的一列网格会改变大小</td>
</tr>
<tr>
<td>Horizontal Spacer</td>
<td>一个用于水平分隔的空格</td>
</tr>
<tr>
<td>Vertical Spacer</td>
<td>一个用于垂直分隔的空格</td>
</tr>
</tbody></table>
<h2 id="布局示例"><a href="#布局示例" class="headerlink" title="布局示例"></a>布局示例</h2><p>新建一个项目后，拖进去两个QTextEdit ，如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200714213057149.png" alt="🍧"></p>
<p>然后运行起来，发现更改窗体大小时这两个控件不会自适应更改大小，因为我们并没有做布局设计。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E6%9C%AA%E8%BF%9B%E8%A1%8C%E5%B8%83%E5%B1%80.gif" alt="未进行布局"></p>
<p>那么怎么办呢？</p>
<p>其实很简单只需做个简单的布局即可。在空白处右击，然后选择布局，然后选择栅格布局。重新编译运行一下，就会发现可以动态调整大小啦。😁</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200714214040589.png" alt="🍼"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B8%83%E5%B1%80.gif" alt="🌿"></p>
<p>这次是一个简单的演示，当你的控件很多的时候，你应该进行水平布局、垂直布局、网格布局等操作。</p>
<p>看我瞎拖几个控件，随便布局一下的效果吧。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200714215641676.png" alt="🍗"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E7%AE%80%E5%8D%95%E5%B8%83%E5%B1%802.gif" alt="😎"></p>
<p>另外，若只需要改变便某方向的缩放与否 以及 缩放比例，可以选中界面中的控件，然后在有下角这里就能进行设置。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200714220148683.png" alt="🍒"></p>
<blockquote>
<p>控件的sizePolicy说明控件在布局管理中的缩放方式。Qt提供的控件都有一个合理的缺省sizePolicy，但是这个缺省值有时不能适合所有的布局，开发人员经常需要改变窗体上的某些控件的sizePolicy。一个QSizePolicy的所有变量对水平方向和垂直方向都适用。下面列举了一些最长用的值：</p>
<p>A. Fixed：控件不能放大或者缩小，控件的大小就是它的sizeHint。</p>
<p>B. Minimum：控件的sizeHint为控件的最小尺寸。控件不能小于这个sizeHint，但是可以</p>
<p>放大。</p>
<p>C. Maximum：控件的sizeHint为控件的最大尺寸，控件不能放大，但是可以缩小到它的最小</p>
<p>的允许尺寸。</p>
<p>D. Preferred：控件的sizeHint是它的sizeHint，但是可以放大或者缩小</p>
<p>E. Expandint：控件可以自行增大或者缩小</p>
<p>注：sizeHint（布局管理中的控件默认尺寸，如果控件不在布局管理中就为无效的值）</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一要设置顶级布局，即前面说的右击后设置栅格布局。</p>
<p>第二设置好控件的SizePolicy属性，以达到预期希望。</p>
<br />

<br />

<br />




]]></content>
      <categories>
        <category>编程</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>问题</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT概述</title>
    <url>/posts/qt_abandon.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200713225904_%E7%9C%8B%E5%9B%BE%E7%8E%8B.jpg"></p>
<p>介绍了Qt常用操作，包括创建项目、信号与槽、窗口、绘图、socket、多线程以及程序打包等。</p>
<span id="more"></span>



<h1 id="1-Qt概述"><a href="#1-Qt概述" class="headerlink" title="1    Qt概述"></a>1    Qt概述</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>Qt是一个<strong>跨平台</strong>的C++<strong>图形用户界面应用程序框架</strong>。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p>
<h2 id="1-2-Qt的发展史"><a href="#1-2-Qt的发展史" class="headerlink" title="1.2 Qt的发展史"></a>1.2 Qt的发展史</h2><p>1991年 Qt最早由奇趣科技开发</p>
<p>1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础</p>
<p>2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言</p>
<p>2012年 Qt又被Digia公司收购</p>
<p>2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。</p>
<p>当前Qt最新版本为 5.5.0</p>
<h2 id="1-3-支持的平台"><a href="#1-3-支持的平台" class="headerlink" title="1.3 支持的平台"></a>1.3 支持的平台</h2><p>l  Windows – XP、Vista、Win7、Win8、Win2008、Win10</p>
<p>l  Uinux&#x2F;X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD&#x2F;OS、和其他很多X11平台</p>
<p>l  Macintosh – Mac OS X</p>
<p>l  Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE</p>
<h2 id="1-4-Qt版本"><a href="#1-4-Qt版本" class="headerlink" title="1.4 Qt版本"></a>1.4 Qt版本</h2><p>Qt按照不同的版本发行，分为商业版和开源版</p>
<p>l  商业版</p>
<p>为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</p>
<p>l  开源的LGPL版本：</p>
<p>为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。</p>
<h2 id="1-5-Qt的安装"><a href="#1-5-Qt的安装" class="headerlink" title="1.5 Qt的安装"></a>1.5 Qt的安装</h2><p>Qt offline installer is a stand-alone binary package including Qt libraries and Qt Creator.</p>
<p>Linux Host</p>
<ul>
<li><a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-linux-x64-5.12.9.run">Qt 5.12.9 for Linux 64-bit (1.3 GB)</a> <a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-linux-x64-5.12.9.run.mirrorlist">  (info)</a></li>
</ul>
<p>macOS Host</p>
<ul>
<li><a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-mac-x64-5.12.9.dmg">Qt 5.12.9 for macOS (2.7 GB)</a> <a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-mac-x64-5.12.9.dmg.mirrorlist">  (info)</a></li>
</ul>
<p>Windows Host</p>
<ul>
<li><a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-windows-x86-5.12.9.exe">Qt 5.12.9 for Windows (3.7 GB)</a> <a href="http://download.qt.io/official_releases/qt/5.12/5.12.9/qt-opensource-windows-x86-5.12.9.exe.mirrorlist">  (info)</a></li>
</ul>
<p>想要下载快一点可以在 Tuna 下载 。</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/#">https://mirrors.tuna.tsinghua.edu.cn/#</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713231443699.png" alt="image-20200713231443699"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713231423382.png" alt="image-20200713231423382"></p>
<p>Qt对不同的平台提供了不同版本的安装包，本文使用下图所示的版本。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713231120055.png" alt="image-20200713231120055"></p>
<h2 id="1-6-Qt的优点"><a href="#1-6-Qt的优点" class="headerlink" title="1.6 Qt的优点"></a>1.6 Qt的优点</h2><ul>
<li><p>l  跨平台，几乎支持所有的平台</p>
</li>
<li><p>l  接口简单，容易上手，学习QT框架对学习其他框架有参考意义。 </p>
</li>
<li><p>l  一定程度上简化了内存回收机制 </p>
</li>
<li><p>l  开发效率高，能够快速的构建应用程序。</p>
</li>
<li><p>l  有很好的社区氛围，市场份额在缓慢上升。</p>
</li>
<li><p>l  可以进行嵌入式开发。</p>
</li>
</ul>
<h1 id="2-创建Qt项目"><a href="#2-创建Qt项目" class="headerlink" title="2    创建Qt项目"></a>2    创建Qt项目</h1><h2 id="2-1-使用向导创建"><a href="#2-1-使用向导创建" class="headerlink" title="2.1 使用向导创建"></a>2.1 使用向导创建</h2><p>打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223409634.png" alt="image-20200713223409634"></p>
<p>弹出New Project对话框，选择Application，然后选择Qt Widgets Application</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223523790.png" alt="image-20200713223523790"></p>
<p>选择【Choose】按钮，弹出如下对话框，填写项目名称以及存放路径。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223629175.png" alt="image-20200713223629175"></p>
<p>设置项目名称和路径，按照向导进行下一步，</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223726638.png" alt="选择qmake"></p>
<p>向导会默认添加一个继承自QMainWindow的类，可以在此修改类的名字和基类。这里我选择默认，继续下一步。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223752992.png" alt="默认即可"></p>
<p>可按需选择开发中用到的编译套件，当然也可以都选择。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223811639.png" alt="选择编译套件"></p>
<p>选择编译套件后点击完成</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713223926803.png" alt="image-20200713223926803"></p>
<p>即可创建出一个Qt桌面程序。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200713224217116.png" alt="image-20200713224217116"></p>
<h2 id="2-2-手动创建"><a href="#2-2-手动创建" class="headerlink" title="2.2      手动创建"></a>2.2      手动创建</h2><p>添加一个空项目</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image014.jpg" alt="img"></p>
<p>选择【choose】进行下一步。设置项目名称和路径 —&gt; 选择编译套件 –&gt; 修改类信息 –&gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image016.jpg" alt="img"></p>
<p>弹出新建文件对话框</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image018.jpg" alt="img"></p>
<p>在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。</p>
<h2 id="2-3-pro文件"><a href="#2-3-pro文件" class="headerlink" title="2.3      .pro文件"></a>2.3      .pro文件</h2><p>在使用Qt向导生成的应用程序.pro文件格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QT  += core gui   <span class="comment">//模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"></span><br><span class="line">TARGET = test  <span class="comment">//应用程序名</span></span><br><span class="line"></span><br><span class="line">TEMPLATE = app <span class="comment">//生成的makefile的模板类型</span></span><br><span class="line">        <span class="comment">//源文件</span></span><br><span class="line"> SOURCES += main.cpp\mainwindow.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"> HEADERS  += mainwindow.h</span><br><span class="line"><span class="comment">//窗口设计文件</span></span><br><span class="line">FORMS    += mainwindow.ui</span><br></pre></td></tr></table></figure>

<p><strong>.pro</strong>就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：</p>
<blockquote>
<p>l  注释</p>
<p>从“#”开始，到这一行结束。</p>
<p>l  模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：<strong>TEMPLATE</strong> &#x3D; app</p>
<ul>
<li><p>n  app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</p>
</li>
<li><p>n  lib - 建立一个库的makefile。</p>
</li>
<li><p>n  vcapp - 建立一个应用程序的VisualStudio项目文件。</p>
</li>
<li><p>n  vclib - 建立一个库的VisualStudio项目文件。</p>
</li>
<li><p>n  subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</p>
</li>
</ul>
<p>l  #指定生成的应用程序名： </p>
<p><strong>TARGET</strong> &#x3D; QtDemo</p>
<p>l  #工程中包含的头文件</p>
<p><strong>HEADERS</strong> +&#x3D; include&#x2F;painter.h</p>
<p>l  #工程中包含的.ui设计文件</p>
<p><strong>FORMS</strong> +&#x3D; forms&#x2F;painter.ui</p>
<p>l  #工程中包含的源文件</p>
<p><strong>SOURCES</strong> +&#x3D; sources&#x2F;main.cpp sources&#x2F;painter.cpp</p>
<p>l  #工程中包含的资源文件</p>
<p><strong>RESOURCES</strong> +&#x3D; qrc&#x2F;painter.qrc</p>
<p>l  <strong>greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets</strong></p>
<p><strong>这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT +&#x3D; widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</strong></p>
<p>l  #配置信息</p>
<p>CONFIG用来告诉qmake关于应用程序的配置信息。</p>
<p>CONFIG +&#x3D; c++11   &#x2F;&#x2F;使用c++11的特性</p>
<p>在这里使用“+&#x3D;”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“&#x3D;”那样替换已经指定的所有选项更安全。</p>
</blockquote>
<h2 id="2-4-一个最简单的Qt应用程序"><a href="#2-4-一个最简单的Qt应用程序" class="headerlink" title="2.4      一个最简单的Qt应用程序"></a>2.4      一个最简单的Qt应用程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget w;</span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<blockquote>
<p>l  Qt头文件没有.h后缀</p>
<p>l  Qt一个类对应一个头文件，类名就是头文件名</p>
<p>l  QApplication应用程序类</p>
<p>n  管理图形用户界面应用程序的控制流和主要设置。</p>
<p>n  是Qt的整个后台管理的命脉它<strong>包含主事件循环</strong>，在其中来自窗口系统和其它资源的<strong>所有事件处理和调度</strong>。它也处理<strong>应用程序的初始化和结束</strong>，并且<strong>提供对话管理</strong>。</p>
<p>n  对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。</p>
<p>l  a.exec()</p>
<p>程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。<strong>在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。</strong></p>
</blockquote>
<h1 id="3-信号和槽机制-listener"><a href="#3-信号和槽机制-listener" class="headerlink" title="3      信号和槽机制(listener)"></a>3      信号和槽机制(listener)</h1><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。<strong>当某个事件发生之后</strong>，比如，按钮检测到自己被点击了一下，<strong>它就会发出一个信号（signal）</strong>。这种发出是没有目的的，类似广播。<strong>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数</strong>，意思是，<strong>将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号</strong>。也就是说，<strong>当信号发出时，被连接的槽函数会自动被回调</strong>。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，<strong>Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式</strong>。）</p>
<h2 id="3-1-信号和槽"><a href="#3-1-信号和槽" class="headerlink" title="3.1 信号和槽"></a>3.1 信号和槽</h2><p>为了体验一下信号槽的使用，我们以一段简单的代码说明：</p>
<p>l  Qt5 的书写方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">	QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked,&amp;app, &amp;QApplication::quit);</span><br><span class="line"></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们按照前面文章中介绍的在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。</p>
<p>connect()函数最常用的一般形式：<code>connect(sender, signal, receiver, slot);</code></p>
<p>参数：</p>
<ul>
<li>n  sender：发出信号的对象</li>
<li>n  signal：发送对象发出的信号</li>
<li>n  receiver：接收信号的对象</li>
<li>n  slot：接收对象在接收到信号之后所需要调用的函数</li>
</ul>
<p><strong>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</strong></p>
<p>如果信号槽不符合，或者根本找不到这个信号或者槽函数，比如我们改成：</p>
<p><code>connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit2);</code></p>
<p>由于 QApplication 没有 quit2 这样的函数，因此在编译时会有编译错误：</p>
<p><code>&#39;quit2&#39; is not a member of QApplication</code></p>
<p>这样，使用成员函数指针我们就不会担心在编写信号槽的时候出现函数错误。</p>
<p>l  Qt4 的书写方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123; </span><br><span class="line">        QApplication a(argc, argv); </span><br><span class="line"></span><br><span class="line">        QPushButton *button = new QPushButton(&quot;Quit&quot;); </span><br><span class="line"></span><br><span class="line">        connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit())); </span><br><span class="line"></span><br><span class="line">        button-&gt;show(); </span><br><span class="line"></span><br><span class="line">        return a.exec(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了<strong>SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串</strong>。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，<strong>Qt4是没有编译错误的</strong>（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。</p>
<p>l  Qt5在语法上完全兼容Qt4</p>
<h2 id="3-2-自定义信号槽"><a href="#3-2-自定义信号槽" class="headerlink" title="3.2 自定义信号槽"></a>3.2 自定义信号槽</h2><p>使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。</p>
<p>下面我们看看使用 Qt 的信号槽，实现一个报纸和订阅者的例子：</p>
<p>有一个报纸类Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。</p>
<p>#include <QObject></p>
<p> &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; newspaper.h &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Newspaper : public QObject</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    Newspaper(const QString &amp; name) :</span><br><span class="line"></span><br><span class="line">        m_name(name)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void send()</span><br><span class="line">    &#123;</span><br><span class="line">        emit newPaper(m_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">    void newPaper(const QString &amp;name);</span><br><span class="line">private:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; reader.h &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">class Reader : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Reader() &#123;&#125;</span><br><span class="line">    void receiveNewspaper(const QString &amp; name)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Receives Newspaper: &quot; &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; main.cpp &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;newspaper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">&quot;Newspaper A&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Reader reader;</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;newspaper, &amp;Newspaper::newPaper, &amp;reader,    &amp;Reader::receiveNewspaper);</span><br><span class="line"></span><br><span class="line">    newspaper.<span class="built_in">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>首先看Newspaper这个类。这个类继承了QObject类。<strong>只有继承了QObject类的类，才具有信号槽的能力。</strong>所以，为了使用信号槽，必须继承QObject。<strong>凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT</strong>。不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。</p>
</li>
<li><p>Newspaper类的 public 和 private 代码块都比较简单，只不过它新加了一个 signals。signals 块所列出的，就是该类的信号。<strong>信号就是一个个的函数名，返回值是 void（因为无法获得信号的返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。信号作为函数名，不需要在 cpp 函数中添加任何实现。</strong></p>
</li>
<li><p>Newspaper类的send()函数比较简单，只有一个语句emit newPaper(m_name);。emit 是 Qt 对 C++ 的扩展，是一个关键字（其实也是一个宏）。emit 的含义是发出，也就是发出newPaper()信号。感兴趣的接收者会关注这个信号，可能还需要知道是哪份报纸发出的信号？所以，我们将实际的报纸名字m_name当做参数传给这个信号。当接收者连接这个信号时，就可以通过槽函数获得实际值。这样就完成了数据从发出者到接收者的一个转移。</p>
</li>
<li><p>Reader类更简单。因为这个类需要接受信号，所以我们将其继承了QObject，并且添加了Q_OBJECT宏。后面则是默认构造函数和一个普通的成员函数。<strong>Qt 5 中，任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</strong>与信号函数不同，槽函数必须自己完成实现代码。槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。（如果信号是 private 的，这个信号就不能在类的外面连接，也就没有任何意义。）</p>
</li>
</ul>
</blockquote>
<h3 id="自定义信号槽需要注意的事项"><a href="#自定义信号槽需要注意的事项" class="headerlink" title="自定义信号槽需要注意的事项"></a>自定义信号槽需要注意的事项</h3><blockquote>
<ul>
<li><p>l<strong>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</strong></p>
</li>
<li><p><strong>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</strong></p>
</li>
<li><p><strong>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</strong></p>
</li>
<li><p><strong>使用 emit 在恰当的位置发送信号；</strong></p>
</li>
<li><p><strong>使用QObject::connect()函数连接信号和槽。</strong></p>
</li>
<li><p><strong>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</strong></p>
</li>
</ul>
</blockquote>
<h3 id="信号槽的更多用法"><a href="#信号槽的更多用法" class="headerlink" title="信号槽的更多用法"></a>信号槽的更多用法</h3><blockquote>
<ul>
<li><p>一个信号可以和多个槽相连</p>
<p><strong>如果是这种情况，这些槽会一个接一个的被调用，但是它们的</strong>调用顺序是不确定的。</p>
</li>
<li><p>多个信号可以连接到一个槽</p>
<p><strong>只要任意一个信号发出，这个槽就会被调用</strong>。</p>
</li>
<li><p>一个信号可以连接到另外的一个信号</p>
<p><strong>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</strong></p>
</li>
<li><p>槽可以被取消链接</p>
<p>这种情况并不经常出现，因为<strong>当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽</strong>。</p>
</li>
<li><p>使用Lambda 表达式</p>
<p>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。</p>
<p>我们的代码可以写成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)</span><br><span class="line"></span><br><span class="line">(const QString &amp;)&gt;(&amp;Newspaper::newPaper),=](const QString &amp;name) </span><br><span class="line"></span><br><span class="line">&#123; /* Your code here. */ &#125;);</span><br></pre></td></tr></table></figure>

<p>在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。</p>
</li>
</ul>
</blockquote>
<h2 id="3-3-Lambda表达式"><a href="#3-3-Lambda表达式" class="headerlink" title="3.3 Lambda表达式"></a>3.3 Lambda表达式</h2><p>C++11中的Lambda表达式<strong>用于定义并创建匿名的函数对象</strong>，以简化编程工作。首先看一下Lambda表达式的基本构成：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image020.jpg" alt="img"></p>
<p><a href="%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数对象参数</a>mutable或exception -&gt;返回值{函数体}</p>
<p>① <strong>函数对象参数</strong>；</p>
<p>[]，标识一个<strong>Lambda的开始</strong>，这部分必须存在，<strong>不能省略</strong>。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：</p>
<ul>
<li><p>空，没有使用任何函数对象参数。</p>
</li>
<li><p>&#x3D;，函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>值传递方式</strong>（相当于编译器自动为我们按值传递了<strong>所有局部变量</strong>）。</p>
</li>
<li><p>&amp;，函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>引用传递方式</strong>（相当于编译器自动为我们按引用传递了所有局部变量）。</p>
</li>
<li><p>this，函数体内可以使用Lambda所在类中的成员变量。</p>
</li>
<li><p>a，将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</p>
</li>
<li><p>&amp;a，将a按引用进行传递。</p>
</li>
<li><p>a, &amp;b，将a按值进行传递，b按引用进行传递。</p>
</li>
<li><p>&#x3D;，&amp;a, &amp;b，除a和b按引用进行传递外，其他参数都按值进行传递。</p>
</li>
<li><p>&amp;, a, b，除a和b按值进行传递外，其他参数都按引用进行传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[=] (<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[&amp;] (<span class="type">int</span> a) &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[=,&amp;m] (<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[&amp;,m] (<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[m,n] (<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[&amp;m,&amp;n] (<span class="type">int</span> a) &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>② 操作符重载函数参数；</p>
<p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p>
<p>③ 可修改标示符；</p>
<p>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p>
<p>④ 错误抛出标示符；</p>
<p>exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)</p>
<p>⑤ 函数返回值；</p>
<p>返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
<p>⑥ 是函数体；</p>
<p>​    {}，标识函数的实现，这部分不能省略，但函数体可以为空。</p>
<h1 id="4-Qt窗口系统"><a href="#4-Qt窗口系统" class="headerlink" title="4 Qt窗口系统"></a>4 Qt窗口系统</h1><h2 id="4-1-Qt窗口坐标体系"><a href="#4-1-Qt窗口坐标体系" class="headerlink" title="4.1 Qt窗口坐标体系"></a>4.1 Qt窗口坐标体系</h2><h3 id="坐标体系"><a href="#坐标体系" class="headerlink" title="坐标体系"></a>坐标体系</h3><p>以左上角为原点，X向右增加，Y向下增加。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image022.jpg" alt="img"></p>
<p>对于嵌套窗口，其坐标是<strong>相对于父窗口</strong>来说的。</p>
<h2 id="4-2-QWidget"><a href="#4-2-QWidget" class="headerlink" title="4.2 QWidget"></a>4.2 QWidget</h2><p><strong>所有窗口及窗口控件都是从QWidget直接或间接派生出来的。</strong></p>
<h3 id="4-2-1-对象模型"><a href="#4-2-1-对象模型" class="headerlink" title="4.2.1 对象模型"></a>4.2.1 对象模型</h3><p>在Qt中创建对象的时候会提供一个<strong>Parent对象指针</strong>，下面来解释这个parent到底是干什么的。</p>
<ol>
<li><p><strong>QObject是以对象树的形式组织起来的</strong>。</p>
<blockquote>
<p>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。这相当于，<strong>在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。</strong></p>
<p>​	 <strong>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</strong>这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p>
</blockquote>
</li>
<li><p><strong>QWidget是能够在屏幕上显示的一切组件的父类。</strong></p>
<blockquote>
<p>​	 <strong>QWidget</strong>继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p>
<p>​	当然，<strong>我们也可以自己删除子对象，它们会自动从其父对象列表中删除。</strong>比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p>
</blockquote>
</li>
</ol>
<p><strong>Qt 引入对象树的概念，在一定程度上解决了内存问题。</strong></p>
<ol>
<li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</p>
</li>
<li><p>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。<strong>Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</strong></p>
<p> ​	如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：</p>
</li>
</ol>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;QWidget window;</span><br><span class="line">&gt;<span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>​	作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，<strong>局部对象的析构顺序应该按照其创建顺序的相反过程</strong>。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</p>
<p>但是，如果我们使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">&gt;QWidget window;</span><br><span class="line">&gt;quit.<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>​	情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，<strong>C++ 不允许调用两次析构函数</strong>，因此，程序崩溃了。</p>
<p>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，<strong>尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建</strong>。</p>
</blockquote>
<h2 id="4-3-QMainWindow"><a href="#4-3-QMainWindow" class="headerlink" title="4.3 QMainWindow"></a>4.3 QMainWindow</h2><p>​	QMainWindow是一个<strong>为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础</strong>，如文本编辑器，图片编辑器等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image024.gif" alt="img"></p>
<h3 id="4-3-1-菜单栏"><a href="#4-3-1-菜单栏" class="headerlink" title="4.3.1 菜单栏"></a>4.3.1 菜单栏</h3><p>一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。</p>
<ul>
<li><p>创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针</p>
<p><code>QMenuBar * menuBar() const</code></p>
</li>
<li><p>创建菜单，调用QMenu的成员函数addMenu来添加菜单</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QAction* <span class="title">addMenu</span><span class="params">(QMenu * menu)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QString &amp; title)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; title)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建菜单项，调用QMenu的成员函数addAction来添加菜单项</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QAction* activeAction() const</span><br><span class="line"></span><br><span class="line">QAction* addAction(const QString &amp; text)</span><br><span class="line"></span><br><span class="line">QAction* addAction(const QIcon &amp; icon, const QString &amp; text)</span><br><span class="line"></span><br><span class="line">QAction* addAction(const QString &amp; text, const QObject * receiver,</span><br><span class="line"></span><br><span class="line">const char * member, const QKeySequence &amp; shortcut = 0)</span><br><span class="line"></span><br><span class="line">QAction* addAction(const QIcon &amp; icon, const QString &amp; text, </span><br><span class="line"></span><br><span class="line">const QObject * receiver, const char * member, </span><br><span class="line"></span><br><span class="line">const QKeySequence &amp; shortcut = 0)</span><br></pre></td></tr></table></figure>

<p>​	Qt 并没有专门的菜单项类，只是<strong>使用一个QAction类，抽象出公共的动作</strong>。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p>
<h3 id="4-3-2-工具栏"><a href="#4-3-2-工具栏" class="headerlink" title="4.3.2 工具栏"></a>4.3.2 工具栏</h3><p>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</p>
<ul>
<li><p>直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</p>
</li>
<li><p>插入属于工具条的动作，即在工具条上添加操作。通过QToolBar类的addAction函数添加。</p>
</li>
<li><p>工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</p>
</li>
</ul>
<blockquote>
<p>Qt::LeftToolBarArea      停靠在左侧</p>
<p>Qt::RightToolBarArea     停靠在右侧</p>
<p>Qt::TopToolBarArea       停靠在顶部</p>
<p>Qt::BottomToolBarArea    停靠在底部</p>
<p>Qt::AllToolBarAreas      以上四个位置都可停靠</p>
<p><strong>使用setAllowedAreas（）函数指定停靠区域：</strong></p>
<p>setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）</p>
<p><strong>使用setMoveable（）函数设定工具栏的可移动性：</strong></p>
<p>setMoveable（false）&#x2F;&#x2F;工具条不可移动, 只能停靠在初始化的位置上</p>
</blockquote>
<h3 id="4-3-3-状态栏"><a href="#4-3-3-状态栏" class="headerlink" title="4.3.3 状态栏"></a>4.3.3 状态栏</h3><p>派生自QWidget类，使用方法与QWidget类似，<strong>QStatusBar</strong>类常用成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加小部件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWidget</span><span class="params">(QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//插入小部件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//删除小部件</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeWidget</span><span class="params">(QWidget * widget)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-资源文件-有问题"><a href="#4-4-资源文件-有问题" class="headerlink" title="4.4 资源文件(有问题)"></a>4.4 资源文件(有问题)</h2><p>​	Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。</p>
<p>使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image026.jpg" alt="img"></p>
<p>点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image028.gif" alt="img"></p>
<p>点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image030.gif" alt="img"></p>
<p>右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image031.gif" alt="img"></p>
<p>接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 &#x2F;images，文件是 document-open.png，那么就可以使用:&#x2F;images&#x2F;document-open.png找到这个文件。</p>
<p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image033.gif" alt="img"></p>
<p>这样，我们可以直接使用:&#x2F;images&#x2F;doc-open引用到这个资源，无需关心图片的真实文件名。</p>
<p>如果我们使用文本编辑器打开 res.qrc 文件，就会看到一下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;/images&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">&quot;doc-open&quot;</span>&gt;</span>document-open.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;/images/fr&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">&quot;doc-open&quot;</span>&gt;</span>document-open-fr.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以对比一下，看看 Qt Creator 帮我们生成的是怎样的 qrc 文件。当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。</p>
<h2 id="4-5-对话框QDialog"><a href="#4-5-对话框QDialog" class="headerlink" title="4.5 对话框QDialog"></a>4.5 对话框<strong>QDialog</strong></h2><h3 id="4-5-1-基本概念"><a href="#4-5-1-基本概念" class="headerlink" title="4.5.1 基本概念"></a>4.5.1 基本概念</h3><blockquote>
<p>​	对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。</p>
<p>​	Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：<strong>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</strong> <strong>对话框分为模态对话框和非模态对话框。</strong></p>
<ul>
<li><p>模态对话框，就是会<strong>阻塞同一应用程序中其它窗口的输入</strong>。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p>
</li>
<li><p>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p>
</li>
</ul>
</blockquote>
<h3 id="4-5-2-标准对话框"><a href="#4-5-2-标准对话框" class="headerlink" title="4.5.2 标准对话框"></a>4.5.2 标准对话框</h3><p>​	所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。</p>
<p>Qt 的内置对话框大致分为以下几类：</p>
<ul>
<li>QColorDialog：       选择颜色；</li>
<li>QFileDialog：        选择文件或者目录；</li>
<li>QFontDialog：        选择字体；</li>
<li>QInputDialog：       允许用户输入一个值，并将其值返回；</li>
<li>QMessageBox：        模态对话框，用于显示信息、询问问题等；</li>
<li>QPageSetupDialog：   为打印机提供纸张相关的选项；</li>
<li>QPrintDialog：       打印机配置；</li>
<li>QPrintPreviewDialog：打印预览；</li>
<li>QProgressDialog：    显示操作过程。</li>
</ul>
<h3 id="4-5-3-自定义消息框"><a href="#4-5-3-自定义消息框" class="headerlink" title="4.5.3 自定义消息框"></a>4.5.3 自定义消息框</h3><p>Qt 支持模态对话框和非模态对话框。</p>
<p>模态与非模态的实现：</p>
<ul>
<li>使用QDialog::exec()实现应用程序级别的模态对话框</li>
<li>使用QDialog::open()实现窗口级别的模态对话框</li>
<li>使用QDialog::show()实现非模态对话框。</li>
</ul>
<h4 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h4><blockquote>
<p>​	Qt 有两种级别的模态对话框：</p>
<ul>
<li>应用程序级别的模态</li>
</ul>
<p>当该种模态的对话框出现时，用户必须<strong>首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口</strong>。</p>
<ul>
<li>窗口级别的模态</li>
</ul>
<p>该模态仅仅阻塞与对话框关联的窗口，但是<strong>依然允许用户与程序中其它窗口交互</strong>。窗口级别的模态尤其适用于多窗口模式。</p>
<p>一般默认是应用程序级别的模态。</p>
<p>在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       QDialog dialog;</span><br><span class="line">       dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">	   dialog.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非模态对话框"><a href="#非模态对话框" class="headerlink" title="非模态对话框"></a>非模态对话框</h4><p>下面我们试着将exec()修改为show()，看看非模态对话框：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	是不是事与愿违？对话框竟然一闪而过！这是因为，<strong>show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。</strong>注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果你足够细心，应该发现上面的代码是有问题的：<strong>dialog 存在内存泄露</strong>！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p>
<p>​	不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**setAttribute() ** <strong>函数设置对话框关闭时，自动销毁对话框。</strong></p>
<h3 id="4-5-4-消息对话框"><a href="#4-5-4-消息对话框" class="headerlink" title="4.5.4 消息对话框"></a>4.5.4 消息对话框</h3><p><strong>QMessageBox</strong>用于显示消息提示。我们一般会使用其提供的几个 static 函数：</p>
<ul>
<li>显示关于对话框。</li>
</ul>
<p>void about(QWidget * parent, const QString &amp; title, const QString &amp; text)</p>
<p>这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p>
<ul>
<li>显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</li>
</ul>
<p>void aboutQt(QWidget * parent, const QString &amp; title &#x3D; QString())： </p>
<ul>
<li>显示严重错误对话框。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">critical</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p>​	这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。</p>
<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">information</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">question</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton)</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">warning</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的代码来演示下如何使用QMessageBox。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (QMessageBox::Yes == QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Question&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Are you OK?&quot;</span>),</span><br><span class="line">QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes)) </span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m glad to hear that!&quot;</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m sorry!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用QMessageBox::question()来询问一个问题。</p>
<blockquote>
<ul>
<li><p>这个对话框的父窗口是 this。QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。</p>
</li>
<li><p>第二个参数是对话框的标题。</p>
</li>
<li><p>第三个参数是我们想要显示的内容。这里就是我们需要询问的文字。下面，我们使用或运算符（|）指定对话框应该出现的按钮。这里我们希望是一个 Yes 和一个 No。</p>
</li>
<li><p>最后一个参数指定默认选择的按钮。</p>
</li>
</ul>
</blockquote>
<p>​	这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。</p>
<p>​	QMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setInformativeText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Do you want to save your changes?&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setDetailedText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Differences here...&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setStandardButtons</span>(QMessageBox::Save | QMessageBox::Discard| QMessageBox::Cancel);</span><br><span class="line">msgBox.<span class="built_in">setDefaultButton</span>(QMessageBox::Save);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = msgBox.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ret) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Save:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Save document!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Discard:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Discard changes!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Close document!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为“The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。</p>
<h3 id="4-5-5-标准文件对话框"><a href="#4-5-5-标准文件对话框" class="headerlink" title="4.5.5 标准文件对话框"></a>4.5.5 标准文件对话框</h3><p>​	QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。</p>
<p>​	首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">openAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-open&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;&amp;Open...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">openAction-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Open);</span><br><span class="line"></span><br><span class="line">openAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Open an existing file&quot;</span>));</span><br><span class="line"></span><br><span class="line">saveAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-save&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;&amp;Save...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">saveAction-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Save);</span><br><span class="line"></span><br><span class="line">saveAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Save a new file&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QMenu *file = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line"></span><br><span class="line">QToolBar *toolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line"></span><br><span class="line">textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setCentralWidget</span>(textEdit);</span><br></pre></td></tr></table></figure>

<p>​	我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。</p>
<p>我们使用connect()函数，为这两个QAction对象添加响应的动作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(openAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(saveAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::saveFile);</span><br></pre></td></tr></table></figure>

<p>下面是最主要的openFile()和saveFile()这两个函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) </span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Read File&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        textEdit-&gt;<span class="built_in">setText</span>(in.<span class="built_in">readAll</span>());</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::saveFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text)) </span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Write File&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; textEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">getOpenFileName</span><span class="params">(QWidget * parent = <span class="number">0</span>, <span class="type">const</span> QString &amp; caption = QString(), <span class="type">const</span> QString &amp; dir = QString(), <span class="type">const</span> QString &amp; filter = QString(), QString * selectedFilter = <span class="number">0</span>,Options options = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：</p>
<ul>
<li><p>parent：父窗口。Qt 的标准对话框提供静态函数，用于返回一个模态对话框；</p>
</li>
<li><p>caption：对话框标题；</p>
</li>
<li><p>dir：对话框打开时的默认目录</p>
</li>
</ul>
<blockquote>
<p> “.” 代表程序运行目录</p>
<p> “&#x2F;” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等；</p>
</blockquote>
<ul>
<li>filter：过滤器。</li>
</ul>
<blockquote>
<p>​	我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。<strong>过滤器就是用于过滤特定的后缀名</strong>。如果我们使用“Image Files(<em>.jpg <em>.png)”，则只能显示后缀名是 jpg 或者 png 的文件。<strong>如果需要多个过滤器，使用“;;”分割</strong>，比如“JPEG Files(</em>.jpg);;PNG Files(</em>.png)”；</p>
</blockquote>
<ul>
<li><p>selectedFilter：默认选择的过滤器；</p>
</li>
<li><p>options：对话框的一些参数设定。比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</p>
</li>
</ul>
<blockquote>
<p>​	 **QFileDialog::getOpenFileName() ** **返回值是选择的文件路径。 **我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。</p>
<p>​	在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。</p>
</blockquote>
<h2 id="4-6-常用控件"><a href="#4-6-常用控件" class="headerlink" title="4.6 常用控件"></a>4.6 常用控件</h2><p>Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用的两种，所有控件的使用方法我们都可以通过帮助文档获取。</p>
<h3 id="4-6-1-QLabel控件使用"><a href="#4-6-1-QLabel控件使用" class="headerlink" title="4.6.1 QLabel控件使用"></a>4.6.1 QLabel控件使用</h3><p>QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。</p>
<h4 id="显示文字-（普通文本、html）"><a href="#显示文字-（普通文本、html）" class="headerlink" title="显示文字 （普通文本、html）"></a>显示文字 （普通文本、html）</h4><p>通过QLabel类的setText函数设置显示的内容:</p>
<p><code>void   setText(const QString &amp;)</code></p>
<ul>
<li>可以显示普通文本字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLable *label = <span class="keyword">new</span> QLable;</span><br><span class="line"></span><br><span class="line">label-&gt;<span class="built_in">setText</span>(“Hello, World!”);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以显示HTML格式的字符串。比如显示一个链接:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>​	其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，<strong>如果参数指定为true则会自动打开</strong>，如果设置为false，想要打开链接只能通过捕捉linkActivated()信号，在自定义的槽函数中使用**QDesktopServices::openUrl()**打开链接，该函数参数默认值为false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// label-&gt;setOpenExternalLinks(true);</span></span><br><span class="line"><span class="built_in">connect</span>(label, &amp;QLabel::linkActivated, <span class="keyword">this</span>, &amp;MyWidget::slotOpenUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//槽函数    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::slotOpenUrl</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDesktopServices::<span class="built_in">openUrl</span>(<span class="built_in">QUrl</span>(link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><blockquote>
<p>可以使用QLabel的成员函数setPixmap设置图片</p>
<p><code>void setPixmap(const QPixmap &amp;)</code></p>
<p>首先定义QPixmap对象</p>
<p><code>QPixmap pixmap;</code></p>
<p>然后加载图片</p>
<p><code>pixmap.load(&quot;:/Image/boat.jpg&quot;);</code></p>
<p>最后将图片设置到QLabel中</p>
<p><code>QLabel *label = new QLabel;</code></p>
<p><code>label.setPixmap(pixmap);</code></p>
</blockquote>
<h4 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h4><blockquote>
<p>可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件</p>
<p><code>void setMovie(QMovie * movie)</code></p>
<p>首先定义QMovied对象，并初始化:</p>
<p><code>QMovie *movie = new QMovie(&quot;:/Mario.gif&quot;);</code></p>
<p>播放加载的动画：</p>
<p><code>movie-&gt;start();</code></p>
<p>将动画设置到QLabel中：</p>
<p><code>QLabel *label = new QLabel；</code></p>
<p><code>label-&gt;setMovie(movie);</code></p>
</blockquote>
<h3 id="4-6-2-QLineEdit"><a href="#4-6-2-QLineEdit" class="headerlink" title="4.6.2 QLineEdit"></a>4.6.2 QLineEdit</h3><p>Qt提供的单行文本编辑框。</p>
<h4 id="设置-获取内容"><a href="#设置-获取内容" class="headerlink" title="设置&#x2F;获取内容"></a>设置&#x2F;获取内容</h4><ul>
<li>获取编辑框内容使用text（），函数声明如下：</li>
</ul>
<p><code>QString text() const</code></p>
<ul>
<li>设置编辑框内容</li>
</ul>
<p><code>void setText(const QString &amp;)</code></p>
<h4 id="设置显示模式"><a href="#设置显示模式" class="headerlink" title="设置显示模式"></a>设置显示模式</h4><p>使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:</p>
<p><code>void   setEchoMode(EchoMode mode)</code></p>
<p>EchoMode是一个枚举类型,一共定义了四种显示模式:</p>
<ul>
<li>QLineEdit::Normal  模式显示方式，按照输入的内容显示。</li>
<li>QLineEdit::NoEcho 不显示任何内容，此模式下无法看到用户的输入。</li>
<li>QLineEdit::Password  密码模式，输入的字符会根据平台转换为特殊字符。</li>
<li>QLineEdit::PasswordEchoOnEdit   编辑时显示字符否则显示字符作为密码。</li>
</ul>
<p>另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么就可以使用QLineEdit给我们提供的setTextMargins函数：</p>
<p><code>void setTextMargins(int left, int top, int right, int bottom)</code></p>
<p>用此函数可以<strong>指定显示的文本与输入框上下左右边界的间隔的像素数。</strong></p>
<h4 id="设置输入提示"><a href="#设置输入提示" class="headerlink" title="设置输入提示"></a>设置输入提示</h4><p>如果我们想实现一个与百度的搜索框类似的功能：输入一个或几个字符，下边会列出几个跟输入的字符相匹配的字符串，QLineEdit要实现这样的功能可以使用该类的成员函数setComleter()函数来实现:</p>
<p><code>void setCompleter(QCompleter * c)</code></p>
<p>创建QCompleter对象，并初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QStringList tipList;</span><br><span class="line">tipList&lt;&lt; “Hello” &lt;&lt; “how are you” &lt;&lt; “Haha” &lt;&lt; “oh, hello”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不区分大小写</span></span><br><span class="line">completer-&gt;<span class="built_in">setCaseSensitivity</span>(Qt::CaseInsensitive);</span><br><span class="line">QCompleter *completer = <span class="keyword">new</span> <span class="built_in">QCompleter</span>(tipList, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>QCompleter类的setCaseSensitivity()函数可以设置是否区分大小写，它的参数是一个枚举类型：</p>
<ul>
<li>Qt::CaseInsensitive  不区分大小写</li>
<li>Qt::CaseSensitive    区分大小写</li>
</ul>
<p>如果不设置该属性，默认匹配字符串时是区分大小写的。</p>
<p>另外我们还可以设置字符串其中某一部分匹配，此功能可通过QCompleter类的setFilterMode函数来实现,函数声明如下:</p>
<p><code>void setFilterMode(Qt::MatchFlags filterMode)</code></p>
<p>其参数为Qt定义的宏,有多重类型,具体可参考Qt帮助稳定，要实现我们上边提到的功能，参数可以使用 Qt::MatchContains：</p>
<p><code>completer-&gt;setFilterMode(Qt::MatchContains);</code></p>
<p>属性设置完成之后，将QCompleter对象设置到QLineEdit中：</p>
<p><code>QLineEdit *edit = new QLineEdit(this);</code></p>
<p><code>edit-&gt;setCompleter(completer);</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image035.jpg" alt="img"></p>
<h3 id="4-6-3-其他控件"><a href="#4-6-3-其他控件" class="headerlink" title="4.6.3 其他控件"></a>4.6.3 其他控件</h3><p>Qt中控件的使用方法可参考Qt提供的帮助文档。</p>
<h2 id="4-7-布局管理器"><a href="#4-7-布局管理器" class="headerlink" title="4.7 布局管理器"></a>4.7 布局管理器</h2><p>​	所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们<strong>必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染</strong>。这就涉及到组件定位的机制。<strong>Qt</strong> <strong>提供了两种组件定位机制：绝对定位和布局定位。</strong></p>
<ul>
<li>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</li>
</ul>
<blockquote>
<p>这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。</p>
</blockquote>
<ul>
<li>布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。</li>
</ul>
<blockquote>
<p>布局定位完美的解决了使用绝对定位的缺陷。</p>
<p>Qt 提供的布局中以下三种是我们最常用的：</p>
<ul>
<li>QHBoxLayout：按照水平方向从左到右布局；</li>
<li>QVBoxLayout：按照竖直方向从上到下布局；</li>
<li>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</li>
</ul>
</blockquote>
<h3 id="4-7-1-水平-垂直-网格布局"><a href="#4-7-1-水平-垂直-网格布局" class="headerlink" title="4.7.1 水平&#x2F;垂直&#x2F;网格布局"></a>4.7.1 水平&#x2F;垂直&#x2F;网格布局</h3><p>下面我们通过一个例子来学习以下水平布局管理器的使用方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">   </span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Enter your age&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    QSpinBox *spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(&amp;window);</span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, &amp;window);</span><br><span class="line"></span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line"></span><br><span class="line">	QObject::<span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, spinBox, &amp;QSpinBox::setValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (QSpinBox:: *spinBoxSignal)(<span class="type">int</span>) = &amp;QSpinBox::valueChanged;</span><br><span class="line"></span><br><span class="line">	QObject::<span class="built_in">connect</span>(spinBox, spinBoxSignal, slider, &amp;QSlider::setValue);</span><br><span class="line"></span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给控件设置布局</span></span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line"></span><br><span class="line">	window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在这段代码中引入了两个新的组件：QSpinBox和QSlider。<strong>QSpinBox就是只能输入数字的输入框，并且带有上下箭头的步进按钮。QSlider则是带有滑块的滑竿。</strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image037.jpg" alt="img"></p>
<p>上面的代码中<strong>window.setLayout(layout);</strong> 是将布局设置到窗口window中，在窗口中设置布局还有另一种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给控件设置布局</span></span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout（window）;</span><br><span class="line"></span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br></pre></td></tr></table></figure>

<p><strong>在创建布局对象的时候给新对象指定父窗口，就等于给传入的窗口设置了布局</strong>。</p>
<p>另外布局与布局之间是可以<strong>嵌套使用</strong>的，使用addLayout（）方法。QVBoxLayout的使用方法与QHBoxLayout完全相同。</p>
<p><strong>关于上述代码中信号和槽连接的解释：</strong></p>
<blockquote>
<p>   当数字输入框显示的内容发生改变的时候，会发出一股信息，滑块会接收这一信号，并作出改变。如果二者的信号槽连接写成下边这样：</p>
<p>   <code>QObject::connect(spinBox, &amp;QSpinBox::valueChanged, slider, &amp;QSlider::setValue);</code></p>
<p>   编译器却会报错</p>
<p>   <code>no matching function for call to &#39;QObject::connect(QSpinBox*&amp;, &lt;unresolved overloaded function type&gt;, QSlider*&amp;, void (QAbstractSlider::*)(int))&#39;</code></p>
<p>   ​    这是怎么回事呢？从出错信息可以看出，编译器认为QSpinBox::valueChanged是一个 overloaded 的函数。我们看一下QSpinBox的文档发现，QSpinBox的确有两个信号：</p>
<ul>
<li>void valueChanged(int)</li>
<li>void valueChanged(const QString &amp;)</li>
</ul>
<p>   ​    当我们使用&amp;QSpinBox::valueChanged取函数指针时，编译器不知道应该取哪一个函数（记住前面我们介绍过的，signal 也是一个普通的函数。）的地址，因此报错。解决的方法很简单，编译器不是不能确定哪一个函数吗？那么我们就显式指定一个函数。方法就是，我们创建一个函数指针，这个函数指针参数指定为 int：</p>
<p>   <code>void (QSpinBox:: *spinBoxSignal)(int) = &amp;QSpinBox::valueChanged;</code></p>
<p>   然后我们将这个函数指针作为 signal，与 QSlider 的函数连接：</p>
<p>   <code>QObject::connect(spinBox, spinBoxSignal, slider, &amp;QSlider::setValue);</code></p>
<p>   这样便避免了编译错误。</p>
</blockquote>
<h4 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h4><p>通过布局管理器搭建如下登陆界面：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image039.jpg" alt="img"></p>
<h3 id="4-7-2-自定义控件"><a href="#4-7-2-自定义控件" class="headerlink" title="4.7.2 自定义控件"></a>4.7.2 自定义控件</h3><p>在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。</p>
<p>在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？</p>
<p>例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// smallwidget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">SmallWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    signals:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QSpinBox* spin;</span><br><span class="line">        QSlider* slider;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// smallwidget.cpp</span></span><br><span class="line">SmallWidget::<span class="built_in">SmallWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    spin = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局对象</span></span><br><span class="line">    QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将控件添加到布局中</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spin);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将布局设置到窗口中</span></span><br><span class="line">    <span class="built_in">setLayout</span>(layout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加消息响应</span></span><br><span class="line">    <span class="built_in">connect</span>(spin, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (QSpinBox::*)(<span class="type">int</span>)&gt;(&amp;QSpinBox::valueChanged),slider, &amp;QSlider::setValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, spin, &amp;QSpinBox::setValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image040.jpg" alt="img"></p>
<p>那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：</p>
<p>打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image042.jpg" alt="img"></p>
<p>弹出提升窗口部件对话框</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image044.jpg" alt="img"></p>
<p>添加要提升的类的名字,然后选择 添加 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image046.jpg" alt="img"></p>
<p>添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.</p>
<p>我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image048.jpg" alt="img"></p>
<p>再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image050.jpg" alt="img"></p>
<h1 id="5-Qt消息机制和事件"><a href="#5-Qt消息机制和事件" class="headerlink" title="5 Qt消息机制和事件"></a>5 Qt消息机制和事件</h1><h2 id="5-1-事件"><a href="#5-1-事件" class="headerlink" title="5.1 事件"></a>5.1 事件</h2><p>​	事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p>​	在前面我们也曾经简单提到，<strong>Qt 程序</strong>需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。<strong>Qt 中所有事件类都继承于QEvent</strong>。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。<strong>event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数</strong>（event handler），关于这一点，会在后边详细说明。</p>
<p>在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如</p>
<ul>
<li>keyPressEvent()</li>
<li>keyReleaseEvent()</li>
<li>mouseDoubleClickEvent()</li>
<li>mouseMoveEvent()</li>
<li>mousePressEvent()</li>
<li>mouseReleaseEvent() 等。</li>
</ul>
<p>这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()), QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()),</span><br><span class="line">QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg;</span><br><span class="line">    msg.<span class="built_in">sprintf</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;&quot;</span>, event-&gt;<span class="built_in">x</span>(), event-&gt;<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    EventLabel *label = <span class="keyword">new</span> EventLabel;</span><br><span class="line"></span><br><span class="line">    label-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;MouseEvent Demo&quot;</span>);</span><br><span class="line">    label-&gt;<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。</p>
</li>
<li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。<code>QString(&quot;[%1, %2]&quot;).arg(x).arg(y);</code>语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。</p>
</li>
<li><p>在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。</p>
</li>
</ul>
<p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image052.gif" alt="img"></p>
<p>为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？</p>
<p><strong>这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</strong></p>
<p>知道了这一点，我们就可以在main()函数中添加如下代码：</p>
<p><code>label-&gt;setMouseTracking(true);</code></p>
<p>在运行程序就没有这个问题了。       </p>
<h2 id="5-2-event（）"><a href="#5-2-event（）" class="headerlink" title="5.2 event（）"></a>5.2 event（）</h2><p>​	事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。</p>
<p>​	如上所述，<strong>event()函数主要用于事件的分发</strong>。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。</p>
<blockquote>
<ul>
<li><p><strong>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件</strong>。</p>
</li>
<li><p><strong>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播</strong>。</p>
</li>
</ul>
</blockquote>
<p>​	我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomTextEdit::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) </span><br><span class="line">    &#123;</span><br><span class="line">       QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。</p>
<p>通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//!!! Qt5</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QObject::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::Timer:</span><br><span class="line">            <span class="built_in">timerEvent</span>((QTimerEvent*)e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildAdded:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildPolished:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildRemoved:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">childEvent</span>((QChildEvent*)e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() &gt;= QEvent::User) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">customEvent</span>(e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-&gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，<strong>event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。</strong></p>
<p>​	由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p>
<h2 id="5-3-事件过滤器"><a href="#5-3-事件过滤器" class="headerlink" title="5.3 事件过滤器"></a>5.3 事件过滤器</h2><p>​	有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p>
<p>​	通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p>
<p><code>virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );</code></p>
<p>​	这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，<strong>不想让它继续转发，就返回 true，否则返回 false。</strong>事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p>
<p>我们来看一段简单的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">         <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">         QTextEdit *textEdit;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line"> &#123;</span><br><span class="line">     textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">     <span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">     textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (obj == textEdit) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">             QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line"></span><br><span class="line">             <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Ate key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// pass the event on to the parent class</span></span><br><span class="line">         <span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</li>
<li>eventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：<code>void QObject::installEventFilter ( QObject * filterObj )</code>这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。</li>
<li>我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</li>
</ul>
<p>还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以给出一个使用事件过滤器的版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FilterObject::eventFilter</span><span class="params">(QObject *object, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) </span><br><span class="line">    &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。<strong>这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。</strong>因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p>
<p><strong>注意，</strong> <strong>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></p>
<h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h2><p>​	Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：</p>
<ul>
<li>所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：</li>
</ul>
<p><code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam,  LPARAM lParam)</code></p>
<p>在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制：</li>
</ul>
<p>mouseEvent()</p>
<p>keyPressEvent()</p>
<p>…</p>
<p>​	Qt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是**event()**。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。</p>
<p>event()函数会有两个问题：</p>
<ul>
<li>event()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？</li>
<li>event()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？</li>
</ul>
<p>这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：<strong>事件过滤器</strong>。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意QObject类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。</p>
<p><strong>事件过滤器可以解决刚刚我们提出的event()函数的两点不足：</strong></p>
<ul>
<li><strong>首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；</strong></li>
<li><strong>其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</strong></li>
</ul>
<p>事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，**最大的控制权实际上是重写QCoreApplication::notify()**。这个函数的声明是：</p>
<p><code>virtual bool QCoreApplication::notify ( QObject * receiver, QEvent * event );</code></p>
<p>该函数会将event发送给receiver，也就是调用receiver-&gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。</p>
<p><strong>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</strong></p>
<ul>
<li>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</li>
</ul>
<h2 id="5-5-不规则窗体"><a href="#5-5-不规则窗体" class="headerlink" title="5.5 不规则窗体"></a>5.5 不规则窗体</h2><p>常见的窗体是各种方形的对话框,但有时候也需要非方形的窗体,如圆形,椭圆甚至是不规则形状的对话框。</p>
<p>实现步骤：</p>
<ul>
<li>新建一个项目，比如项目名称叫做“ShapeWidget”，给此项目添加一个类“ShapeWidget”，基类选择“QWidget”。</li>
<li>为了使该不规则窗体可以通过鼠标随意拖拽，在类中重定义鼠标事件：mousePressEvent（）、mouseMoveEvent（）、以及绘制函数paintEvent（）</li>
<li>“ShapeWidget”的构造函数部分是实现该不规则窗体的关键，添加具体代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//新建一个Pixmap对象</span></span><br><span class="line">    QPixmap pixmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图片</span></span><br><span class="line">    pixmap.<span class="built_in">load</span>(<span class="string">&quot;:/new/prefix1/image/sunny.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//固定窗口大小，将窗口大小设置为图片大小</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>( pixmap.<span class="built_in">width</span>(), pixmap.<span class="built_in">height</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给窗口去掉边框，设置窗口的flags</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | <span class="built_in">windowFlags</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置透明背景</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  重新实现鼠标事件和绘制函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShareWidget::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出窗口移动之前的坐标</span></span><br><span class="line">        m_dragPoint = ev-&gt;<span class="built_in">globalPos</span>()-<span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::RightButton)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标右键关闭窗口</span></span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShareWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是鼠标左键拖动, 移动窗口</span></span><br><span class="line">        <span class="built_in">move</span>(ev-&gt;<span class="built_in">globalPos</span>() - m_dragPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShareWidget::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev)</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新绘制图片</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QPixmap</span>(<span class="string">&quot;:/ButterFly&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="6-绘图和绘图设备"><a href="#6-绘图和绘图设备" class="headerlink" title="6 绘图和绘图设备"></a>6 绘图和绘图设备</h1><h2 id="6-1-QPainter"><a href="#6-1-QPainter" class="headerlink" title="6.1 QPainter"></a>6.1 QPainter</h2><p>Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。</p>
<p><strong>QPainter</strong>用来执行绘制的操作；<strong>QPaintDevice</strong>是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；<strong>QPaintEngine</strong>提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。</p>
<p>下图给出了这三个类之间的层次结构:</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image054.jpg" alt="img"></p>
<p>上面的示意图告诉我们，<strong>Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</strong></p>
<p>下面我们通过一个实例来介绍QPainter的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaintedWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">   <span class="built_in">PaintedWidget</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意我们重写了QWidget的<span class="built_in">paintEvent</span>()函数。接下来就是PaintedWidget的源代码：</span><br><span class="line"></span><br><span class="line">PaintedWidget::<span class="built_in">PaintedWidget</span>(QWidget *parent) :</span><br><span class="line"></span><br><span class="line">   <span class="built_in">QWidget</span>(parent)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Paint Demo&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintedWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">drawLine</span>(<span class="number">80</span>, <span class="number">100</span>, <span class="number">650</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">drawRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::green, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">drawEllipse</span>(<span class="number">50</span>, <span class="number">150</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，这一点可能会引发某些细节问题：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。</p>
<p>QPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。</p>
<p>QPainter有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的drawLine()，drawRect()以及drawEllipse()等。当绘制轮廓线时，使用QPainter的pen()属性。比如，我们调用了painter.setPen(Qt::red)将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。</p>
<h2 id="6-2-绘图设备"><a href="#6-2-绘图设备" class="headerlink" title="6.2 绘图设备"></a>6.2 绘图设备</h2><p><strong>绘图设备是指继承QPainterDevice的子类。</strong>Qt一共提供了四个这样的类，分别是QPixmap、QBitmap、QImage和 QPicture。其中，</p>
<p>l  QPixmap专门为图像在屏幕上的显示做了优化</p>
<p>l  QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</p>
<p>l  QImage专门为图像的像素级访问做了优化。 </p>
<p>l  QPicture则可以记录和重现QPainter的各条命令。</p>
<h3 id="6-2-1-QPixmap、QBitmap、QImage"><a href="#6-2-1-QPixmap、QBitmap、QImage" class="headerlink" title="6.2.1 QPixmap、QBitmap、QImage"></a>6.2.1 QPixmap、QBitmap、QImage</h3><p>QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。<strong>QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。</strong>注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。</p>
<p><strong>QBitmap****继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像</strong>。QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，<strong>QBitmap实际上是只有黑白两色的图像数据。</strong></p>
<p><strong>由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。</strong></p>
<p>下面我们来看同一个图像文件在QPixmap和QBitmap下的不同表现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">QPixmap <span class="title">pixmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">QBitmap <span class="title">bitmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">QBitmap <span class="title">bitmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pixmap);</span><br><span class="line"></span><br><span class="line">   painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">0</span>, pixmap1);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">130</span>, bitmap);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">130</span>, bitmap1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image056.jpg" alt="img"></p>
<p>这里我们给出了两张png图片。butterfly1.png是没有透明色的纯白背景，而butterfly.png是具有透明色的背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。</p>
<p>QPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而<strong>QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。</strong></p>
<p>我们声明了一个QImage对象，大小是300 x 300，颜色模式是RGB32，即使用32位数值表示一个颜色的RGB值，也就是说每种颜色使用8位。然后我们对每个像素进行颜色赋值，从而构成了这个图像。我们可以把QImage想象成一个RGB颜色的二维数组，记录了每一像素的颜色。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">​    <span class="function">QImage <span class="title">image</span><span class="params">(<span class="number">300</span>, <span class="number">300</span>, QImage::Format_RGB32)</span></span>;</span><br><span class="line"></span><br><span class="line">​    QRgb value;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//将图片背景填充为白色</span></span><br><span class="line"></span><br><span class="line">​    image.<span class="built_in">fill</span>(Qt::white);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//改变指定区域的像素点的值</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>; i&lt;<span class="number">100</span>; ++i)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">50</span>; j&lt;<span class="number">100</span>; ++j)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            value = <span class="built_in">qRgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">​            image.<span class="built_in">setPixel</span>(i, j, value);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//将图片绘制到窗口中</span></span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">drawImage</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), image);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image058.jpg" alt="img"></p>
<p>QImage与QPixmap的区别</p>
<blockquote>
<p>l  QPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I&#x2F;O、图片访问和像素修改而设计的</p>
<p>l  QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果</p>
<p>l  由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。</p>
<p>l  QImage可通过setPixpel()和pixel()等方法直接存取指定的像素。</p>
<p>QImage与QPixmap之间的转换:</p>
<p>l  QImage转QPixmap</p>
<p>使用QPixmap的静态成员函数: fromImage()</p>
<p>QPixmap    fromImage(const QImage &amp; image, </p>
<p>Qt::ImageConversionFlags flags &#x3D; Qt::AutoColor)</p>
<p>l  QPixmap转QImage:</p>
<p>使用QPixmap类的成员函数: toImage()</p>
<p>QImage toImage() const</p>
</blockquote>
<h3 id="6-2-2-QPicture"><a href="#6-2-2-QPicture" class="headerlink" title="6.2.2 QPicture"></a>6.2.2 QPicture</h3><p>最后一个需要说明的是QPicture。<strong>这是一个可以记录和重现QPainter命令的绘图设备。</strong> <strong>QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。</strong>这种格式有时候会是“元文件(meta- files)”。Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。</p>
<p><strong>QPicture****是平台无关的</strong>，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。</p>
<p>如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    QPicture pic;</span><br><span class="line"></span><br><span class="line">​    QPainter painter;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//将图像绘制到QPicture中,并保存到文件</span></span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">begin</span>(&amp;pic);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">drawEllipse</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">fillRect</span>(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, Qt::red);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">​    pic.<span class="built_in">save</span>(<span class="string">&quot;D:\\drawing.pic&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//将保存的绘图动作重新绘制到设备上</span></span><br><span class="line"></span><br><span class="line">​    pic.<span class="built_in">load</span>(<span class="string">&quot;D:\\drawing.pic&quot;</span>);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">begin</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">drawPicture</span>(<span class="number">200</span>, <span class="number">200</span>, pic);</span><br><span class="line"></span><br><span class="line">​    painter.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-文件系统"><a href="#7-文件系统" class="headerlink" title="7 文件系统"></a>7 文件系统</h1><p>​	文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。Qt 通过<strong>QIODevice</strong>提供了对 I&#x2F;O 设备的抽象，这些设备具有读写字节块的能力。下面是 I&#x2F;O 设备的类图（Qt5）：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image060.gif" alt="img"></p>
<ul>
<li>QIODevice：所有 I&#x2F;O 设备类的父类，提供了字节块读写的通用操作以及基本接口；</li>
<li>QFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。</li>
<li>QFlie：访问本地文件或者嵌入资源；</li>
<li>QTemporaryFile：创建和访问本地文件系统的临时文件；</li>
<li>QBuffer：读写QbyteArray, 内存文件；</li>
<li>QProcess：运行外部程序，处理进程间通讯；</li>
<li>QAbstractSocket：所有套接字类的父类；</li>
<li>QTcpSocket：TCP协议网络数据传输；</li>
<li>QUdpSocket：传输 UDP 报文；</li>
<li>QSslSocket：使用 SSL&#x2F;TLS 传输数据；</li>
</ul>
<p><strong>文件系统分类:</strong></p>
<ul>
<li><p>顺序访问设备:</p>
<p>是<strong>指它们的数据只能访问一遍</strong>：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节，这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。</p>
</li>
<li><p>随机访问设备:</p>
<p>可以<strong>访问任意位置任意次数</strong>，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFile和QBuffer是随机访问设备，</p>
</li>
</ul>
<h2 id="7-1-基本文件操作"><a href="#7-1-基本文件操作" class="headerlink" title="7.1 基本文件操作"></a>7.1 基本文件操作</h2><p>​	文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。在所有的 I&#x2F;O 设备中，文件 I&#x2F;O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。<strong>QFile提供了从文件中读取和写入数据的能力。</strong></p>
<p>​	 <strong>我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改</strong>。QFile需要使用 &#x2F; 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:&#x2F;windows 这样的路径在 Windows 平台下同样是可以的。</p>
<p>​	QFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。<strong>我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。</strong>值得注意的是，<strong>有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取</strong>，而不是自己分析文件路径字符串。</p>
<p>下面我们使用一段代码来看看QFile的有关操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Open file failed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; file.<span class="built_in">readLine</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFileInfo <span class="title">info</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">isDir</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">isExecutable</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">baseName</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">completeBaseName</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">suffix</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">completeSuffix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们首先使用QFile创建了一个文件对象。</p>
<p>这个文件名字是 in.txt。如果你不知道应该把它放在哪里，可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。</p>
</li>
<li><p>使用open()函数打开这个文件，打开形式是只读方式，文本格式。</p>
<p>这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。</p>
</li>
<li><p>可以使用QFileInfo获取有关该文件的信息。</p>
</li>
</ul>
<blockquote>
<p>QFileInfo有很多类型的函数，我们只举出一些例子。比如：</p>
<ul>
<li>isDir()检查该文件是否是目录；</li>
<li>isExecutable()    检查该文件是否是可执行文件等。</li>
<li>baseName()    可以直接获得文件名；</li>
<li>completeBaseName()   获取完整的文件名</li>
<li>suffix()   则直接获取文件后缀名。</li>
<li>completeSuffix()  获取完整的文件后缀</li>
</ul>
<p>我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fi</span><span class="params">(<span class="string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">QString base  = fi.<span class="built_in">baseName</span>();  <span class="comment">// base = &quot;archive&quot;</span></span><br><span class="line"></span><br><span class="line">QString base  = fi.<span class="built_in">completeBaseName</span>();  <span class="comment">// base = &quot;archive.tar&quot;</span></span><br><span class="line"></span><br><span class="line">QString ext   = fi.<span class="built_in">suffix</span>();  <span class="comment">// ext = &quot;gz&quot;</span></span><br><span class="line"></span><br><span class="line">QString ext   = fi.<span class="built_in">completeSuffix</span>();  <span class="comment">// ext = &quot;tar.gz&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="7-2-二进制文件读写"><a href="#7-2-二进制文件读写" class="headerlink" title="7.2 二进制文件读写"></a>7.2 二进制文件读写</h2><p>​	 <strong>QDataStream</strong>提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流<strong>完全不依赖</strong>于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以<strong>直接读写没有编码的二进制数据，例如图像、视频、音频</strong>等。</p>
<p>​	 <strong>QDataStream</strong>  <strong>既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。</strong>结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line"></span><br><span class="line"><span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"></span><br><span class="line">out &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;the answer is&quot;</span>);</span><br><span class="line"></span><br><span class="line">out &lt;&lt; (qint32)<span class="number">42</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向&lt;&lt;运算符。后面的代码就很简单了：将“the answer is”和数字 42 输出到数据流。由于我们的 out 对象建立在file之上，因此相当于将问题和答案写入file。</li>
<li>需要指出一点：最好使用 Qt 整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。<strong>为性能起见，数据只有在文件关闭时才会真正写入</strong>。因此，我们必须在最后添加一行代码：</li>
</ul>
<p><code>file.close(); // 如果不想关闭文件，可以使用 file.flush();</code></p>
<p>接下来我们将存储到文件中的答案取出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line"></span><br><span class="line"><span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"></span><br><span class="line">QString str;</span><br><span class="line"></span><br><span class="line">qint32 a;</span><br><span class="line"></span><br><span class="line">in &gt;&gt; str &gt;&gt; a;</span><br></pre></td></tr></table></figure>

<p><strong>唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。</strong></p>
<p>那么，既然QIODevice提供了read()、readLine()之类的函数，为什么还要有<strong>QDataStream</strong>呢？QDataStream同QIODevice有什么区别？区别在于，<strong>QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。</strong>我们通过下面一段代码看看什么是流的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadWrite);</span><br><span class="line"></span><br><span class="line"><span class="function">QDataStream <span class="title">stream</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"></span><br><span class="line">QString str = <span class="string">&quot;the answer is 42&quot;</span>;</span><br><span class="line"></span><br><span class="line">stream &lt;&lt; str;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-文本文件读写"><a href="#7-3-文本文件读写" class="headerlink" title="7.3 文本文件读写"></a>7.3 文本文件读写</h2><p>​	上一节我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用<strong>QTextStream</strong>类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。</p>
<p>QTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。<strong>QTextStream使用 16 位的QChar作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。</strong></p>
<p>QTextStream同QDataStream的使用基本一致，例如下面的代码将把“The answer is 42”写入到 file.txt 文件中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">open</span>(QFile::WriteOnly | QIODevice::Truncate)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，我们在open()函数中增加了QIODevice::Truncate打开方式。我们可以从下表中看到这些打开方式的区别：</p>
<blockquote>
<p>枚举值                描述</p>
<p>QIODevice::NotOpen       未打开</p>
<p>QIODevice::ReadOnly      以只读方式打开</p>
<p>QIODevice::WriteOnly     以只写方式打开</p>
<p>QIODevice::ReadWrite     以读写方式打开</p>
<p>QIODevice::Append        以追加的方式打开，新增加的内容将被追加到文件末尾</p>
<p>QIODevice::Truncate      以重写的方式打开，在写入新的数据时会将原有数据全部清除，游标设置在文件开头。</p>
<p>QIODevice::Text          在读取时，将行结束符转换成 \n；在写入时，将行结束符转换成本地格式，例如 Win32 平台</p>
<p>上是 \r\n</p>
<p>QIODevice::Unbuffered    忽略缓存</p>
</blockquote>
<p>我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。虽然QTextStream的写入内容与QDataStream一致，但是读取时却会有些困难：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">open</span>(QFile::ReadOnly)) </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    QString str;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    in &gt;&gt; str &gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用QDataStream的时候，这样的代码很方便，但是使用了QTextStream时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为<strong>当使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而以文本形式写入数据，是没有数据之间的分隔的。</strong>因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如使用：</p>
<ul>
<li>QTextStream::readLine()  读取一行</li>
<li>QTextStream::readAll()读取所有文本</li>
</ul>
<p>这种函数之后再对获得的QString对象进行处理。</p>
<p>默认情况下，QTextStream的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用：</p>
<p><code>stream.setCodec(&quot;UTF-8&quot;);</code>这样的函数进行设置。</p>
<h1 id="8-Socket通信"><a href="#8-Socket通信" class="headerlink" title="8 Socket通信"></a>8 Socket通信</h1><p>Qt中提供的所有的Socket类都是非阻塞的。</p>
<p>Qt中常用的用于socket通信的套接字类:</p>
<p>l  QTcpServer</p>
<p>用于TCP&#x2F;IP通信, 作为服务器端套接字使用</p>
<p>l  QTcpSocket</p>
<p>用于TCP&#x2F;IP通信，作为客户端套接字使用。</p>
<p>l  QUdpSocket</p>
<p>用于UDP通信，服务器，客户端均使用此套接字。</p>
<h2 id="8-1-TCP-IP"><a href="#8-1-TCP-IP" class="headerlink" title="8.1 TCP&#x2F;IP"></a>8.1 TCP&#x2F;IP</h2><p>在Qt中实现TCP&#x2F;IP<strong>服务器端通信</strong>的流程:</p>
<blockquote>
<ol>
<li><p>创建套接字</p>
</li>
<li><p>将套接字设置为监听模式</p>
</li>
<li><p>等待并接受客户端请求</p>
<p>​	可以通过QTcpServer提供的void  **newConnection()*<em><strong>信号</strong>来检测是否有连接请求，如果有可以在对应的槽函数中调用nextPendingConnection函数获取到客户端的Socket信息（返回值为QTcpSocket</em>类型指针），通过此套接字与客户端之间进行通信。</p>
</li>
<li><p>接收或者向客户端发送数据</p>
<p>接收数据：使用read（）或者readAll（）函数</p>
<p> 发送数据：用write（）函数</p>
</li>
</ol>
</blockquote>
<p>客户端通信流程:</p>
<blockquote>
<ol>
<li><p>创建套接字</p>
</li>
<li><p>连接服务器</p>
</li>
<li><p>可以使用QTcpSocket类的<strong>connectToHost（）</strong>函数来连接服务器。</p>
</li>
<li><p>向服务器发送或者接受数据</p>
</li>
</ol>
</blockquote>
<p>下面例子为简单的TCP&#x2F;IP通信的实现:</p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>通过Qt提供的QTcpServer类实现服务器端的socket通信:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------- tcpserver.h ------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPServer</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPServer</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">TCPServer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotNewConnection</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotReadyRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::TCPServer *ui;</span><br><span class="line">    <span class="comment">// 负责监听的套接字</span></span><br><span class="line">    QTcpServer* m_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责通信的套接字</span></span><br><span class="line">    QTcpSocket* m_client;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- tcpserver.cpp ------------</span></span><br><span class="line">TCPServer::<span class="built_in">TCPServer</span>(QWidget *parent) :</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::TCPServer),</span><br><span class="line">    <span class="built_in">m_server</span>(<span class="literal">NULL</span>),</span><br><span class="line">    <span class="built_in">m_client</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//创建套接字对象</span></span><br><span class="line">    m_server = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字设置为监听模式</span></span><br><span class="line">    m_server-&gt;<span class="built_in">listen</span>(QHostAddress::Any, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过信号接收客户端请求</span></span><br><span class="line">    <span class="built_in">connect</span>(m_server, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, &amp;TCPServer::slotNewConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPServer::~<span class="built_in">TCPServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPServer::slotNewConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_client == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户端的连接请求</span></span><br><span class="line">        m_client = m_server-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        m_client-&gt;<span class="built_in">write</span>(<span class="string">&quot;服务器连接成功!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接信号, 接收客户端数据</span></span><br><span class="line">        <span class="built_in">connect</span>(m_client, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;TCPServer::slotReadyRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPServer::slotReadyRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    QByteArray array = m_client-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Client Message&quot;</span>, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端通过使用Qt提供的QTcpSocket类可以方便的实现与服务器端的通信。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- tcpclient.h ------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPClient</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPClient</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">TCPClient</span>();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotReadyRead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotSendMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::TCPClient *ui;</span><br><span class="line">    QTcpSocket* m_client;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- tcpclient.cpp --------------</span></span><br><span class="line"></span><br><span class="line">TCPClient::<span class="built_in">TCPClient</span>(QWidget *parent) :</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::TCPClient)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    m_client = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    m_client-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过信号接收服务器数据</span></span><br><span class="line">    <span class="built_in">connect</span>(m_client, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;TCPClient::slotReadyRead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送按钮</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnSend, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;TCPClient::slotSendMsg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">TCPClient::~<span class="built_in">TCPClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPClient::slotReadyRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    QByteArray array = m_client-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Server Message&quot;</span>, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPClient::slotSendMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString text = ui-&gt;textEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    m_client-&gt;<span class="built_in">write</span>(text.<span class="built_in">toUtf8</span>());</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-2-UDP"><a href="#8-2-UDP" class="headerlink" title="8.2 UDP"></a>8.2 UDP</h2><p>​	使用Qt提供的QUdpSocket进行UDP通信。<strong>在UDP方式下，客户端并不与服务器建立连接，它只负责调用发送函数向服务器发送数据</strong>。类似的<strong>服务器也不从客户端接收连接，只负责调用接收函数，等待来自客户端的数据的到达</strong>。</p>
<p>在UDP通信中，服务器端和客户端的概念已经显得有些淡化，两部分做的工作都大致相同：</p>
<ul>
<li><p>创建套接字</p>
</li>
<li><p>绑定套接字</p>
<p>在UDP中如果需要<strong>接收数据</strong>则<strong>需要对套接字进行绑定</strong>，只发送数据则不需要对套接字进行绑定。</p>
<p>通过调用bind（）函数将套接字绑定到指定端口上。</p>
</li>
<li><p>接收或者发送数据</p>
<p><strong>接收数据</strong>：使用readDatagram()接收数据,函数声明如下:</p>
<p><code>qint64 readDatagram(char * data, qint64 maxSize, QHostAddress * address = 0, quint16 * port = 0)</code></p>
</li>
</ul>
<blockquote>
<p>参数:</p>
<p>data: 接收数据的缓存地址</p>
<p>maxSize: 缓存接收的最大字节数</p>
<p>address: 数据发送方的地址（一般使用提供的默认值）</p>
<p>port: 数据发送方的端口号（一般使用提供的默认值）</p>
<p>使用<strong>pendingDatagramSize()可以获取到将要接收的数据的大小</strong>，根据该函数返回值来准备对应大小的内存空间存放将要接收的数据。</p>
</blockquote>
<p>​	 <strong>发送数据</strong>: 使用writeDatagram()函数发送数据，函数声明如下：</p>
<p><code>qint64 writeDatagram(const QByteArray &amp; datagram, const QHostAddress &amp; host, quint16 port)</code></p>
<blockquote>
<p>参数：</p>
<p>datagram：要发送的字符串</p>
<p>host：数据接收方的地址 </p>
<p>port：数据接收方的端口号</p>
</blockquote>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>​	在使用QUdpSocket类的writeDatagram()函数发送数据的时候，其中第二个参数host应该指定为广播地址：QHostAddress：：Broadcast此设置相当于QHostAddress(“255.255.255.255”)使用UDP广播的的特点：</p>
<blockquote>
<p> 使用UDP进行广播，局域网内的其他的UDP用户全部可以收到广播的消息</p>
<p> UDP广播只能在局域网范围内使用</p>
</blockquote>
<h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>​	我们再使用广播发送消息的时候会发送给所有用户，但是有些用户是不想接受消息的，这时候我们就应该使用组播，接收方只有先注册到组播地址中才能收到组播消息，否则则接受不到消息。另外组播是可以在Internet中使用的。</p>
<p>在使用QUdpSocket类的writeDatagram()函数发送数据的时候，其中第二个参数host应该指定为组播地址，关于组播地址的分类：</p>
<blockquote>
<p>  224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</p>
<p>  224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；</p>
<p>  224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</p>
<p>  239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</p>
<p>  注册加入到组播地址需要使用QUdpSocket类的成员函数：</p>
<p>  bool   joinMulticastGroup(const QHostAddress &amp; groupAddress)</p>
</blockquote>
<h2 id="8-3-TCP-IP-和-UDP的区别"><a href="#8-3-TCP-IP-和-UDP的区别" class="headerlink" title="8.3 TCP&#x2F;IP 和 UDP的区别"></a>8.3 TCP&#x2F;IP 和 UDP的区别</h2><table>
<thead>
<tr>
<th></th>
<th><strong>TCP&#x2F;IP</strong></th>
<th><strong>UDP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>传输方式</td>
<td>基于流</td>
<td>基于数据报</td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>传输效率</td>
<td>效率低</td>
<td>效率高</td>
</tr>
<tr>
<td>能否广播</td>
<td>不能</td>
<td>能</td>
</tr>
</tbody></table>
<h1 id="9-多线程"><a href="#9-多线程" class="headerlink" title="9 多线程"></a>9 多线程</h1><p>通常情况下，应用程序都是在一个线程中执行操作。但是，当调用一个耗时操作（例如，大批量I&#x2F;O或大量矩阵变换等CPU密集操作）时，用户界面常常会冻结。而使用多线程可以解决这一问题。</p>
<p>多线程有以下几个优势：</p>
<ul>
<li><p>提高应用程序响应速度。</p>
<p>这对于图形界面开发的程序尤为重要，当一个操作耗时很长时，整个系统都会等待这个操作，程序就不能响应键盘、鼠标、菜单等操作，而使用多线程技术可将耗时长的操作置于一个新的线程，避免以上问题。</p>
</li>
<li><p>使多CPU系统更加有效。</p>
<p>当前线程数不大于CPU数目时，操作系统可以调度不同的线程运行于不同的CPU上。</p>
</li>
<li><p>改善程序结构。</p>
<p>一个既长又复杂的进程可以考虑分为多个线程，成为独立或半独立的运行部分，这样有利于代码的理解和维护。</p>
<p>多线程程序有以下几个特点：</p>
</li>
<li><p>多线程程序的行为无法预期，当多次执行程序时，每一次的结果都可能不同。</p>
</li>
<li><p>多线程的执行顺序无法保证，它与操作系统的调度策略和线程优先级等因素有关。</p>
</li>
<li><p>多线程的切换可能发生在任何时刻、任何地点。</p>
</li>
<li><p>多线程对代码的敏感度高，对代码的细微修改都可能产生意想不到的结果。</p>
</li>
</ul>
<p>基于以上这些特点，为了有效的使用线程，开发人员必须对其进行控制。</p>
<h2 id="9-1-线程介绍"><a href="#9-1-线程介绍" class="headerlink" title="9.1 线程介绍"></a>9.1 线程介绍</h2><p>在Qt中使用QThread 来管理线程。下面来看一个简单的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    QLCDNumber *lcdNu<span class="comment">///mber = new QLCDNumber(this);</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lcdNumber);</span><br><span class="line"></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Start&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> sec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lcdNumber-&gt;<span class="built_in">display</span>(QString::<span class="built_in">number</span>(sec++));</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, [=]() &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000000</span>; i++);</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们的界面有一个用于显示时间的 LCD 数字面板还有一个用于启动任务的按钮。程序的目的是用户点击按钮，开始一个非常耗时的运算（程序中我们以一个 2000000000 次的循环来替代这个非常耗时的工作，在真实的程序中，这可能是一个网络访问，可能是需要复制一个很大的文件或者其它任务），同时 LCD 开始显示逝去的毫秒数。毫秒数通过一个计时器QTimer进行更新。计算完成后，计时器停止。这是一个很简单的应用，也看不出有任何问题。但是当我们开始运行程序时，问题就来了：点击按钮之后，程序界面直接停止响应，直到循环结束才开始重新更新。</p>
<p>​	有经验的开发者立即指出，这里需要使用线程。这是因为 Qt 中所有界面都是在 UI 线程中（也被称为主线程，就是执行了QApplication::exec()的线程），<strong>在这个线程中执行耗时的操作（比如那个循环），就会阻塞 UI 线程，从而让界面停止响应</strong>。界面停止响应，用户体验自然不好，不过更严重的是，有些窗口管理程序会检测到你的程序已经失去响应，可能会建议用户强制停止程序，这样一来你的程序可能就此终止，任务再也无法完成。所以，为了避免这一问题，我们要使用 QThread 开启一个新的线程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WorkerThread</span>(QObject *parent = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">QThread</span>(parent)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++);</span><br><span class="line">        <span class="function">emit <span class="title">done</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">done</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    lcdNumber = <span class="keyword">new</span> <span class="built_in">QLCDNumber</span>(<span class="keyword">this</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lcdNumber);</span><br><span class="line">    </span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Start&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]() &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> sec = <span class="number">0</span>;</span><br><span class="line">        lcdNumber-&gt;<span class="built_in">display</span>(QString::<span class="built_in">number</span>(sec++));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    WorkerThread *thread = <span class="keyword">new</span> <span class="built_in">WorkerThread</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;WorkerThread::done, timer, &amp;QTimer::stop);</span><br><span class="line">    <span class="built_in">connect</span>(thread, &amp;WorkerThread::finished, thread, &amp;WorkerThread::deleteLater);</span><br><span class="line">    <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, [=]() &#123;</span><br><span class="line"></span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1</span>);</span><br><span class="line">        thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	注意，我们增加一个WorkerThread类。WorkerThread继承自QThread类，重写了其run()函数。我们可以认为，<strong>run()函数就是新的线程需要执行的代码</strong>。在这里就是要执行这个循环，然后发出计算完成的信号。<strong>run()是线程的入口，就像main()对于应用程序的作用，使用QThread::start()函数启动一个线程</strong>（注意，这里不是run()函数）。再次运行程序，你会发现现在界面已经不会被阻塞了。另外，<strong>我们将WorkerThread::deleteLater()函数与WorkerThread::finished()信号连接起来，当线程完成时，系统可以帮我们清除线程实例。</strong>这里的finished()信号是系统发出的，与我们自定义的done()信号无关。</p>
<p>​	这是 Qt 线程的最基本的使用方式之一（确切的说，这种方式已经不大推荐使用，不过因为看起来很清晰，而且简单使用起来也没有什么问题，所以还是有必要介绍）。代码看起来很简单，不过，如果你认为 Qt 的多线程编程也很简单，那就大错特错了。Qt 多线程的优势设计使得它使用起来变得容易，但是坑很多，稍不留神就会被绊住，尤其是涉及到与 QObject 交互的情况。稍懂多线程开发的童鞋都会知道，调试多线程开发简直就是煎熬。</p>
<h2 id="9-2-多线程的使用"><a href="#9-2-多线程的使用" class="headerlink" title="9.2 多线程的使用"></a>9.2 多线程的使用</h2><p>​	在Qt4.7及以后版本推荐使用以下的工作方式。其主要特点就是利用Qt的事件驱动特性，将<strong>需要在次线程中处理的业务放在独立的模块（类）中，由主线程创建完该对象后，将其移交给指定的线程，且可以将多个类似的对象移交给同一个线程。</strong>在这个例子中，信号由主线程的QTimer对象发出，之后Qt会将关联的事件放到worker所属线程的事件队列。由于队列连接的作用，在不同线程间连接信号和槽是很安全的。</p>
<p>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Worker::onTimeout get called from?: &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;From main thread: &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line"></span><br><span class="line">    QThread t;</span><br><span class="line">    QTimer timer;</span><br><span class="line">    Worker worker;</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), &amp;worker, <span class="built_in">SLOT</span>(<span class="built_in">onTimeout</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动定时器</span></span><br><span class="line">    timer.<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象移交个线程</span></span><br><span class="line">    worker.<span class="built_in">moveToThread</span>(&amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    t.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于Qobject类的connect函数最后一个参数，连接类型：</p>
<ul>
<li><p>自动连接(AutoConnection)，默认的连接方式。</p>
<p>如果信号与槽，也就是发送者与接受者在同一线程，等同于直接连接;</p>
<p>如果发送者与接受者处在不同线程，等同于队列连接。</p>
</li>
<li><p>直接连接(DirectConnection)</p>
<p>当信号发射时，槽函数立即直接调用。<strong>无论槽函数所属对象在哪个线程，槽函数总在发送者所在线程执行。</strong></p>
</li>
<li><p>队列连接(QueuedConnection)</p>
<p>当控制权回到接受者所在线程的事件循环时，槽函数被调用。<strong>槽函数在接受者所在线程执行。</strong></p>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>队列连接：槽函数在接受者所在线程执行</strong>。</li>
<li><strong>直接连接：槽函数在发送者所在线程执行</strong>。</li>
<li><strong>自动连接：二者不在同一线程时，等同于队列连接</strong></li>
</ul>
<p><strong>多线程使用过程中注意事项：</strong></p>
<ul>
<li><strong>线程不能操作UI对象（从Qwidget直接或间接派生的窗口对象）</strong></li>
<li><strong>需要移动到子线程中处理的模块类，创建的对象的时候不能指定父对象。</strong></li>
</ul>
<h2 id="9-3-使用线程绘图"><a href="#9-3-使用线程绘图" class="headerlink" title="9.3 使用线程绘图"></a>9.3 使用线程绘图</h2><p>根据前面讲过的知识,实现以下案例:</p>
<p>在窗口中有一个按钮,当点击按钮之后,在线程中绘制一张图片,然后将绘制好的图片显示到当前窗口中。</p>
<p>实现步骤：</p>
<p>将需要房屋线程中的操作放入单独的一个类中去处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Work</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Work</span>(QObject *parent = <span class="number">0</span>) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotDrawImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">QImage <span class="title">image</span><span class="params">(<span class="number">600</span>, <span class="number">600</span>, QImage::Format_ARGB32)</span></span>;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;image)</span></span>;</span><br><span class="line">        QPoint pt[] =</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">QPoint</span>(<span class="built_in">qrand</span>()%<span class="number">590</span>, <span class="built_in">qrand</span>()%<span class="number">590</span>),</span><br><span class="line">            <span class="built_in">QPoint</span>(<span class="built_in">qrand</span>()%<span class="number">590</span>, <span class="built_in">qrand</span>()%<span class="number">590</span>),</span><br><span class="line">            <span class="built_in">QPoint</span>(<span class="built_in">qrand</span>()%<span class="number">590</span>, <span class="built_in">qrand</span>()%<span class="number">590</span>),</span><br><span class="line">            <span class="built_in">QPoint</span>(<span class="built_in">qrand</span>()%<span class="number">590</span>, <span class="built_in">qrand</span>()%<span class="number">590</span>),</span><br><span class="line">            <span class="built_in">QPoint</span>(<span class="built_in">qrand</span>()%<span class="number">590</span>, <span class="built_in">qrand</span>()%<span class="number">590</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        painter.<span class="built_in">drawPolygon</span>(pt, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将画好的图片通过信号发送出去</span></span><br><span class="line">        <span class="function">emit <span class="title">ImageDone</span><span class="params">(image)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImageDone</span><span class="params">(QImage image)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在UI线程中(主线程)中创建Work类对象, 并调用moveToThread函数将操作移入到子线程中取处理.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MyWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyWidget *ui;</span><br><span class="line">    QImage m_image;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 </span></span><br><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MyWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Work* pWork = <span class="keyword">new</span> Work;</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;draw, &amp;QPushButton::clicked, pWork, &amp;Work::slotDrawImage);</span><br><span class="line"></span><br><span class="line">    QThread * pthread = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将操作移入子线程中处理</span></span><br><span class="line">    pWork-&gt;<span class="built_in">moveToThread</span>(pthread);</span><br><span class="line">    <span class="comment">// 启动子线程</span></span><br><span class="line">    pthread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(pWork, &amp;Work::ImageDone, =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保存图片</span></span><br><span class="line">        m_image = image;</span><br><span class="line">        <span class="comment">// 刷新窗口</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MyWidget::destroyed, [=]()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出线程</span></span><br><span class="line">        pthread-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        pthread-&gt;<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">delete</span> pWork;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果需要在窗口中绘制图形,那么就需要重写paintEvent事件处理函数。通过QPainter对象将子线程中绘制的图片画到当前窗口中。如果需要刷新窗口可以调用update（）函数，时间处理器会自动被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::paintEvent</span><span class="params">(QPaintEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawImage</span>(<span class="number">0</span>, <span class="number">0</span>, m_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-数据库操作"><a href="#10-数据库操作" class="headerlink" title="10 数据库操作"></a>10 数据库操作</h1><h2 id="10-1-数据库操作"><a href="#10-1-数据库操作" class="headerlink" title="10.1 数据库操作"></a>10.1 数据库操作</h2><p>​	 <strong>Qt</strong> <strong>提供了 QtSql 模块来提供平台独立的基于 SQL 的数据库操作。</strong>这里我们所说的“平台独立”，既包括操作系统平台，有包括各个数据库平台。另外，我们强调了“基于 SQL”，因为 NoSQL 数据库至今没有一个通用查询方法，所以不可能提供一种通用的 NoSQL 数据库的操作。<strong>Qt 的数据库操作还可以很方便的与 model&#x2F;view 架构进行整合。</strong>通常来说，我们对数据库的操作更多地在于对数据库表的操作，而这正是 model&#x2F;view 架构的长项。</p>
<p><strong>Qt</strong> <strong>使用QSqlDatabase表示一个数据库连接。</strong>更底层上，Qt 使用驱动（drivers）来与不同的数据库 API 进行交互。Qt 桌面版本提供了如下几种驱动：</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>QDB2</td>
<td>IBM DB2 (7.1 或更新版本)</td>
</tr>
<tr>
<td>QIBASE</td>
<td>Borland InterBase</td>
</tr>
<tr>
<td>QMYSQL</td>
<td>MySQL</td>
</tr>
<tr>
<td>QOCI</td>
<td>Oracle Call Interface Driver</td>
</tr>
<tr>
<td>QODBC</td>
<td>Open Database Connectivity (ODBC) – Microsoft SQL Server 及其它兼容 ODBC 的数据库</td>
</tr>
<tr>
<td>QPSQL</td>
<td>PostgreSQL (7.3 或更新版本)</td>
</tr>
<tr>
<td>QSQLITE2</td>
<td>SQLite 2</td>
</tr>
<tr>
<td>QSQLITE</td>
<td>SQLite 3</td>
</tr>
<tr>
<td>QSYMSQL</td>
<td>针对 Symbian 平台的SQLite 3</td>
</tr>
<tr>
<td>QTDS</td>
<td>Sybase Adaptive Server (自   Qt 4.7 起废除)</td>
</tr>
</tbody></table>
<p>不过，由于受到协议的限制，Qt 开源版本并没有提供上面所有驱动的二进制版本，而仅仅以源代码的形式提供。通常，Qt 只默认搭载 QSqlite 驱动（这个驱动实际还包括 Sqlite 数据库，也就是说，如果需要使用 Sqlite 的话，只需要该驱动即可）。我们可以选择把这些驱动作为 Qt 的一部分进行编译，也可以当作插件编译。</p>
<p>如果习惯于使用 SQL 语句，我们可以选择<strong>QSqlQuery</strong>类；如果只需要使用高层次的数据库接口（不关心 SQL 语法），我们可以选择使用QsqlTableModel类。 </p>
<p>在使用时，我们可以通过</p>
<p><code>QSqlDatabase::drivers();</code></p>
<p>找到系统中所有可用的数据库驱动的名字列表。我们只能使用出现在列表中的驱动。由于默认情况下，QtSql 是作为 Qt 的一个模块提供的。为了使用有关数据库的类，我们必须早 .pro 文件中添加这么一句：</p>
<p><code>QT += sql</code></p>
<p>这表示，我们的程序需要使用 Qt 的 core、gui 以及 sql 三个模块。注意，如果需要同时使用 Qt4 和 Qt5 编译程序，通常我们的 .pro 文件是这样的：</p>
<p><code>QT += core gui sql</code></p>
<p><code>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</code></p>
<p>这两句也很明确：Qt 需要加载 core、gui 和 sql 三个模块，如果主板本大于 4，则再添加 widgets 模块。</p>
<p>下面来看一个简单的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> QString &amp;dbName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line"><span class="comment">//    db.setHostName(&quot;host&quot;);</span></span><br><span class="line"><span class="comment">//    db.setDatabaseName(&quot;dbname&quot;);</span></span><br><span class="line"><span class="comment">//    db.setUserName(&quot;username&quot;);</span></span><br><span class="line"><span class="comment">//    db.setPassword(&quot;password&quot;);</span></span><br><span class="line">    db.<span class="built_in">setDatabaseName</span>(dbName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="number">0</span>, QObject::<span class="built_in">tr</span>(<span class="string">&quot;Database Error&quot;</span>), db.<span class="built_in">lastError</span>().<span class="built_in">text</span>());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们使用connect()函数创建一个数据库连接。我们使用QSqlDatabase::addDatabase()静态函数完成这一请求，也就是创建了一个QSqlDatabase实例。注意，数据库连接使用自己的名字进行区分，而不是数据库的名字。例如，我们可以使用下面的语句：</p>
<p><code>QSqlDatabase db=QSqlDatabase::addDatabase(&quot;QSQLITE&quot;, QString(&quot;con%1&quot;).arg(dbName));</code></p>
<p>​	此时，我们是使用addDatabase()函数的第二个参数来给这个数据库连接一个名字。在这个例子中，用于区分这个数据库连接的名字是QString(“conn%1”).arg(dbName)，而不是 “QSQLITE”。这个参数是可选的，如果不指定，系统会给出一个默认的名字QSqlDatabase::defaultConnection，此时，Qt 会创建一个默认的连接。如果你给出的名字与已存在的名字相同，新的连接会替换掉已有的连接。通过这种设计，我们可以为一个数据库建立多个连接。</p>
<p>​	我们这里使用的是 sqlite 数据库，只需要指定数据库名字即可。如果是数据库服务器，比如 MySQL，我们还需要指定主机名、端口号、用户名和密码，这些语句使用注释进行了简单的说明。</p>
<p>​	接下来我们调用了<strong>QSqlDatabase类的open()函数，打开这个数据库连接</strong>。通过检查open()函数的返回值，我们可以判断数据库是不是正确打开。</p>
<p>​	QtSql 模块中的类大多具有lastError()函数，用于检查最新出现的错误。如果你发现数据库操作有任何问题，应该使用这个函数进行错误的检查。这一点我们也在上面的代码中进行了体现。当然，这只是最简单的实现，一般来说，更好的设计是，<strong>不要在数据库操作中混杂界面代码（并且将这个connect()函数放在一个专门的数据库操作类中）。</strong></p>
<p> 接下来我们可以在main()函数中使用这个connect()函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(<span class="string">&quot;demo.db&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        QSqlQuery query;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!query.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE student (&quot;</span><span class="string">&quot;id INT PRIMARY KEY AUTOINCREMENT,&quot;</span><span class="string">&quot;name VARCHAR(255),&quot;</span><span class="string">&quot;age INT)&quot;</span>)) </span><br><span class="line">		&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">critical</span>(<span class="number">0</span>, QObject::<span class="built_in">tr</span>(<span class="string">&quot;Database Error&quot;</span>),query.<span class="built_in">lastError</span>().<span class="built_in">text</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	main()函数中，我们调用这个connect()函数打开数据库。如果打开成功，我们<strong>通过一个QSqlQuery实例执行了 SQL 语句。同样，我们使用其lastError()函数检查了执行结果是否正确。</strong></p>
<p>​	注意这里的QSqlQuery实例的创建。我们并没有指定是为哪一个数据库连接创建查询对象，此时，系统会使用默认的连接，也就是使用没有第二个参数的addDatabase()函数创建的那个连接（其实就是名字为QSqlDatabase::defaultConnection的默认连接）。如果没有这么一个连接，系统就会报错。也就是说，如果没有默认连接，我们在创建QSqlQuery对象时必须指明是哪一个QSqlDatabase对象，也就是addDatabase()的返回值。</p>
<p>​	我们还可以通过使用QSqlQuery::isActive()函数检查语句执行正确与否。如果QSqlQuery对象是活动的，该函数返回 true。所谓“活动”，就是指该对象成功执行了exec()函数，但是还没有完成。这里需要注意的是，如果存在一个活动的 SELECT 语句，某些数据库系统不能成功完成connect()或者rollback()函数的调用。此时，我们必须首先将活动的 SELECT 语句设置成不活动的。</p>
<p>创建过数据库表 student 之后，我们开始插入数据，然后将其独取出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(<span class="string">&quot;demo.db&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO student (name, age) VALUES (?, ?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QVariantList names;</span><br><span class="line"></span><br><span class="line">    names &lt;&lt; <span class="string">&quot;Tom&quot;</span> &lt;&lt; <span class="string">&quot;Jack&quot;</span> &lt;&lt; <span class="string">&quot;Jane&quot;</span> &lt;&lt; <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">addBindValue</span>(names);</span><br><span class="line"></span><br><span class="line">    QVariantList ages;</span><br><span class="line"></span><br><span class="line">    ages &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="number">23</span> &lt;&lt; <span class="number">22</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">addBindValue</span>(ages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">execBatch</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="number">0</span>, QObject::<span class="built_in">tr</span>(<span class="string">&quot;Database Error&quot;</span>), query.<span class="built_in">lastError</span>().<span class="built_in">text</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;SELECT name, age FROM student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QString name = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="type">int</span> age = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	依旧连接到我们创建的 demo.db 数据库。我们需要插入多条数据，此时可以使用QSqlQuery::exec()函数一条一条插入数据，但是这里我们选择了另外一种方法：批量执行。首先，我们使用<strong>QSqlQuery::prepare()函数对这条 SQL 语句进行预处理，问号 ? 相当于占位符，预示着以后我们可以使用实际数据替换这些位置。</strong>简单说明一下，<strong>预处理是数据库提供的一种特性，它会将 SQL 语句进行编译，性能和安全性都要优于普通的 SQL 处理</strong>。在上面的代码中，我们使用一个字符串列表 names 替换掉第一个问号的位置，一个整型列表 ages 替换掉第二个问号的位置，利用<strong>QSqlQuery::addBindValue()我们将实际数据绑定到这个预处理的 SQL 语句上</strong>。需要注意的是，names 和 ages 这两个列表里面的数据需要一一对应。然后我们调用<strong>QSqlQuery::execBatch()批量执行 SQL，之后结束该对象。</strong>这样，插入操作便完成了。</p>
<p>​	另外说明一点，我们这里使用了 ODBC 风格的 ? 占位符，同样，我们也可以使用 Oracle 风格的占位符：</p>
<p><code>query.prepare(&quot;INSERT INTO student (name, age) VALUES (:name, :age)&quot;);</code></p>
<p>此时，我们就需要使用</p>
<p><code>query.bindValue(&quot;:name&quot;, names);</code></p>
<p><code>query.bindValue(&quot;:age&quot;, ages);</code></p>
<p>进行绑定。Oracle 风格的绑定最大的好处是，绑定的名字和值很清晰，与顺序无关。但是这里需要注意，<strong>bindValue()函数只能绑定一个位置</strong>。比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO test (name1, name2) VALUES (:name, :name)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, name);</span><br></pre></td></tr></table></figure>

<p>只能绑定第一个 :name 占位符，不能绑定到第二个。</p>
<p>​	接下来我们依旧使用同一个查询对象执行一个 SELECT 语句。如果存在查询结果，QSqlQuery::next()会返回 true，直到到达结果最末，返回 false，说明遍历结束。我们利用这一点，使用 while 循环即可遍历查询结果。使用QSqlQuery::value()函数即可按照 SELECT 语句的字段顺序获取到对应的数据库存储的数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">query.exec(“<span class="keyword">select</span> name, age <span class="keyword">from</span> student”);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>（query.next()）</span><br><span class="line">&#123;</span><br><span class="line">    QString name = query.<span class="keyword">value</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    QString age = query.<span class="keyword">value</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	对于<strong>数据库事务</strong>的操作，我们可以使用 QSqlDatabase::transaction() 开启事务，QSqlDatabase::commit() 或者QSqlDatabase::rollback() 结束事务。使用QSqlDatabase::database()函数则可以根据名字获取所需要的数据库连接。</p>
<h2 id="10-2-使用模型操作数据库"><a href="#10-2-使用模型操作数据库" class="headerlink" title="10.2 使用模型操作数据库"></a>10.2 使用模型操作数据库</h2><p>​	上一节我们使用 SQL 语句完成了对数据库的常规操作，包括简单的 CREATE、SELECT 等语句的使用。我们也提到过，Qt 不仅提供了这种使用 SQL 语句的方式，还提供了一种基于模型的更高级的处理方式。这种<strong>基于QSqlTableModel 的模型处理更为高级，如果对 SQL 语句不熟悉，并且不需要很多复杂的查询，这种QSqlTableModel模型基本可以满足一般的需求。</strong>本节我们将介绍QSqlTableModel的一般使用，对比 SQL 语句完成对数据库的增删改查等的操作。值得注意的是，QSqlTableModel并不一定非得结合 QListView或QTableView使用，我们完全可以用其作一般性处理。</p>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>首先我们来看看如何使用QSqlTableModel 进行 SELECT 操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(<span class="string">&quot;demo.db&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    QSqlTableModel model;</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">setTable</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">    model.<span class="built_in">setFilter</span>(<span class="string">&quot;age &gt; 20 and age &lt; 25&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model.<span class="built_in">select</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.<span class="built_in">rowCount</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            QSqlRecord record = model.<span class="built_in">record</span>(i);</span><br><span class="line">            QString name = record.<span class="built_in">value</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> age = record.<span class="built_in">value</span>(<span class="string">&quot;age&quot;</span>).<span class="built_in">toInt</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们依旧使用了上一节的connect()函数。接下来我们创建了QSqlTableModel实例，</p>
<ul>
<li>setTable()函数设置所需要操作的表格；</li>
<li>setFilter()函数则是添加过滤器，也就是 WHERE 语句所需要的部分。</li>
</ul>
<p>例如上面代码中的操作实际相当于 SQL 语句</p>
<p><code>SELECT * FROM student WHERE age &gt; 20 and age &lt; 25</code></p>
<p>使用QSqlTableModel::select()函数进行操作，也就是执行了查询操作。如果查询成功，函数返回 true，由此判断是否发生了错误。如果没有错误，我们<strong>使用record()函数取出一行记录，该记录是以QSqlRecord的形式给出的，而QSqlRecord::value()则取出一个列的实际数据值。注意，由于QSqlTableModel没有提供const_iterator遍历器，因此不能使用foreach宏进行遍历。</strong></p>
<p>​	另外需要注意，由于QSqlTableModel只是一种高级操作，肯定没有实际 SQL 语句方便。具体来说，<strong>我们使用QSqlTableModel只能进行 SELECT * 的查询，不能只查询其中某些列的数据。</strong></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>下面一段代码则显示了如何使用QSqlTableModel进行插入操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlTableModel model;</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setTable</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">model.<span class="built_in">insertRows</span>(row, <span class="number">1</span>);</span><br><span class="line">model.<span class="built_in">setData</span>(model.<span class="built_in">index</span>(row, <span class="number">1</span>), <span class="string">&quot;Cheng&quot;</span>);</span><br><span class="line">model.<span class="built_in">setData</span>(model.<span class="built_in">index</span>(row, <span class="number">2</span>), <span class="number">24</span>);</span><br><span class="line">model.<span class="built_in">submitAll</span>();</span><br></pre></td></tr></table></figure>

<p>​	插入也很简单：model.insertRows(row, 1);说明我们想在索引 0 的位置插入 1 行新的数据。使用<strong>setData()函数则开始准备实际需要插入的数据</strong>。注意这里我们向 row 的第一个位置写入 Cheng（通过model.index(row, 1)，回忆一下，我们把 model 当作一个二维表，这个坐标相当于第 row 行第 1 列），其余以此类推。最后，调用<strong>submitAll()函数提交所有修改</strong>。这里执行的操作可以用如下 SQL 表示：</p>
<p><code>INSERT INTO student (name, age) VALUES (&#39;Cheng&#39;, 24)</code></p>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>当我们取出了已经存在的数据后，对其进行修改，然后重新写入数据库，即完成了一次更新操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlTableModel model;</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setTable</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">model.<span class="built_in">setFilter</span>(<span class="string">&quot;age = 25&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (model.<span class="built_in">select</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (model.<span class="built_in">rowCount</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        QSqlRecord record = model.<span class="built_in">record</span>(<span class="number">0</span>);</span><br><span class="line">        record.<span class="built_in">setValue</span>(<span class="string">&quot;age&quot;</span>, <span class="number">26</span>);</span><br><span class="line">        model.<span class="built_in">setRecord</span>(<span class="number">0</span>, record);</span><br><span class="line">        model.<span class="built_in">submitAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，我们首先找到 age &#x3D; 25 的记录，然后将 age 重新设置为 26，存入相同的位置（在这里都是索引 0 的位置），提交之后完成一次更新。当然，我们也可以类似其它模型一样的设置方式：setData()函数。具体代码片段如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (model.<span class="built_in">select</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (model.<span class="built_in">rowCount</span>() == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        model.<span class="built_in">setData</span>(model.<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="number">26</span>);</span><br><span class="line">        model.<span class="built_in">submitAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意我们的 age 列是第 3 列，索引值为 2，因为前面还有 id 和 name 两列。这里的更新操作则可以用如下 SQL 表示：</p>
<p><code>UPDATE student SET age = 26 WHERE age = 25</code></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作同更新类似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlTableModel model;</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">setTable</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">model.<span class="built_in">setFilter</span>(<span class="string">&quot;age = 25&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (model.<span class="built_in">select</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (model.<span class="built_in">rowCount</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        model.<span class="built_in">removeRows</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        model.<span class="built_in">submitAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 SQL 则是：</p>
<p><code>DELETE FROM student WHERE age = 25</code></p>
<p>当我们看到removeRows()函数就应该想到：我们可以一次删除多行。事实也正是如此，这里不再赘述。</p>
<h2 id="10-3-可视化显示数据库数据"><a href="#10-3-可视化显示数据库数据" class="headerlink" title="10.3 可视化显示数据库数据"></a>10.3 可视化显示数据库数据</h2><p>​	前面我们用了两个章节介绍了 Qt 提供的两种操作数据库的方法。显然，使用QSqlQuery的方式更灵活，功能更强大，而使用QSqlTableModel则更简单，更方便与 model&#x2F;view 结合使用（数据库应用很大一部分就是以表格形式显示出来，这正是 model&#x2F;view 的强项）。本章我们简单介绍使用<strong>QSqlTableModel显示数据</strong>的方法。当然，我们也可以选择使用QSqlQuery获取数据，然后交给 view 显示，而这需要自己给 model 提供数据。</p>
<p>我们还是使用前面一直在用的 student 表，直接来看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(<span class="string">&quot;demo.db&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        QSqlTableModel *model = <span class="keyword">new</span> QSqlTableModel;</span><br><span class="line"></span><br><span class="line">        model-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        model-&gt;<span class="built_in">setSort</span>(<span class="number">1</span>, Qt::AscendingOrder);</span><br><span class="line">        model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">        model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">2</span>, Qt::Horizontal, <span class="string">&quot;Age&quot;</span>);</span><br><span class="line">        model-&gt;<span class="built_in">select</span>();</span><br><span class="line"></span><br><span class="line">        QTableView *view = <span class="keyword">new</span> QTableView;</span><br><span class="line">        view-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">        view-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line">        view-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      view-&gt;setColumnHidden(0, true);</span></span><br><span class="line">        view-&gt;<span class="built_in">resizeColumnsToContents</span>();</span><br><span class="line">        view-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line"></span><br><span class="line">        QHeaderView *header = view-&gt;<span class="built_in">horizontalHeader</span>();</span><br><span class="line">        header-&gt;<span class="built_in">setStretchLastSection</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        view-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里的connect()函数还是我们前面使用过的（11.1），我们在main()函数中创建了QSqlTableModel对象，使用 student 表。student 表有三列：id，name 和 age，我们选择按照 name 排序，使用<strong>setSort()函数</strong>达到这一目的。然后我们设置每一列的列头。这里我们只使用了后两列，第一列没有设置，所以依旧显示为列名 id。</p>
<p>​	在设置好 model 之后，我们又创建了QTableView对象作为视图。注意这里的设置：单行选择，按行选择。resizeColumnsToContents()说明每列宽度适配其内容；setEditTriggers()则禁用编辑功能。最后，我们设置最后一列要充满整个窗口。我们的代码中有一行注释，设置第一列不显示。</p>
<h1 id="11-Qt程序打包"><a href="#11-Qt程序打包" class="headerlink" title="11 Qt程序打包"></a>11 Qt程序打包</h1><p>​	Qt的应用程序编译出来之后,将单独的exe程序拿到其他PC上运行是运行不起来的,会提示缺少对应的动态链接库。我们需要去Qt的安装目录下找到所有的Qt程序运行时所依赖的，将他们和exe程序放到同一目录下，程序才可以执行。</p>
<p>根据上边的描述我们可以想象的到，如果手动去寻找应用程序依赖的动态库，这是一件非常麻烦的事情。其实我们完全没有必要这么辛苦，Qt给我们提供了一个寻找依赖项的工具windeployqt</p>
<p>Windeployqt的使用方法：</p>
<p>如果我们一件配置好了环境变量，在dos下输入windeployqt会有相应的信息输出,否则需要指定该工具的完全路径才能够正常使用,例如:</p>
<p> C:\Qt\Qt5.5.0\5.5\mingw492_32\bin\windeployqt</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image062.jpg" alt="img"></p>
<ul>
<li><p>把新生成的exe文件放到指定的目录下:</p>
<p>例如: C:\Users\Kevin\Desktop\qt_test</p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image064.jpg" alt="img"></p>
<p>l  在控制台窗口中通命令进入到上述目录中</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image066.jpg" alt="img"></p>
<ul>
<li>执行命令windeployqt 应用程序名(qttext.exe)</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image068.jpg" alt="img"></p>
<p>应用程序所需的附加依赖项就会全部拷贝到我们指定的目录中</p>
<br />



<p>Reference：</p>
<blockquote>
<p>传智播客 – C++学院</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>编程</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>5G NR Synchronization Signal/PBCH block (SSB)</title>
    <url>/posts/18457.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718163554.jpg"></p>
<p>　　本文主要对 5G NR 中的同步信号块 SSB 的结构以及时频位置进行了描述。</p>
<span id="more"></span>





<p>　　小区搜索是 UE 获取小区的时间和频率同步以及检测小区的物理层小区 ID (PCI)的过程。</p>
<p>　　系统消息设计是无线通信系统中重要概念之一，小区级系统消息主要为了配置小区驻留、提供用户接入、互操作等一系列重要参数配置。5G NR对于系统消息进行了一定程度的简化，相比4G不仅在同步信号以及系统消息设计方面都进行了完全不同的设计。</p>
<p>　　有别于4G将小区下行同步信号以及物理广播信道分离设计，5G中将小区主辅同步信号（SS，Synchronization Signal）与物理广播信道（PBCH，Physical Broadcast Channel）进行了某种程度上的耦合，以SS&#x2F;PBCH资源块的形式出现，简称为SSB。</p>
<div class="note info"><p>注：本文描述中 SSB&#x3D;SS&#x2F;PBCH&#x3D;Synchronization Signal&#x2F;PBCH block</p>
</div>

<p>　　在NR 定义了两类同步信号：<em>Primary Synchronization Signal 主同步信号</em> (PSS) 以及 Secondary <em>Synchronization Signal  辅同步信号</em>  (SSS). Synchronization Signal&#x2F;PBCH block (SSB) 由PSS、SSS和 PBCH组成。即：$SSB&#x3D;PSS+SSS+PBCH$ 。其中 PBCH 中又存放着 DMRS 。</p>
<p>　　下图显示了 PSS，SSS，PBCH 和 PBCH DMR 在 SSB 区块的位置</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718094757.png" alt="图片来源：concepts-of-5g"></p>
<h2 id="SSB时频结构"><a href="#SSB时频结构" class="headerlink" title="SSB时频结构"></a>SSB时频结构</h2><p>　　SSB的时频结构如下图所示</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718095429.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718104159.png"></p>
<ul>
<li><p>PSS、SSS 和 PBCH 始终以连续的 OFDM 符号组合在一起。</p>
</li>
<li><p>每个 SSB 在时域中占据 4 个 OFDM 符号，并分布在频域中的 240 个子载波 （20 RB）。</p>
</li>
<li><p>PSS 占据第一个 OFDM 符号，跨越 127 个子载波。</p>
</li>
<li><p>SSS 位于第三个 OFDM 符号中，跨越 127 个子载波。SSS 下方有 8 个未使用的子载波，SSS 上方有 9 个未使用的子载波。</p>
</li>
<li><p>PBCH 占据两个完整 OFDM 符号（第二和第四个），跨越 240 个子载波。在第三个 OFDM 符号中，占据SSS上方和下方的 48 个子载波。这导致 PBCH 在三个 OFDM 符号（$240+48+48+240 &#x3D; 576 $） 中占用 576 个子载波。</p>
</li>
<li><p>PBCH DM-RS占用144 个 RE，占总RE的四分之一，剩余用于PBCH有效载荷(576-144&#x3D;432 RE)。</p>
</li>
<li><p>SS&#x2F;PBCH 子载波间隔配置支持 $μ∈｛0,1,3,4｝$ 即 15 KHz 、30 KHz 、120 KHz 、240 KHz 。</p>
<br/></li>
</ul>
<p>补充</p>
<blockquote>
<p>注意：5G的一个资源块（RB）包含频域上的12个子载波。注意这一点和4G不同，4G的RB是由频域上12个子载波和时域上的0.5毫秒（7个OFDM符号）组成的二维结构，而5G的RB只有频域这一个维度。</p>
<p>5G的最小资源单位：资源单元（RE）由频域的一个子载波和时域的一个OFDM符号组成，是无线资源的最小单位（如上图中的小方格所示）。这一点是和4G一样的。</p>
</blockquote>
<blockquote>
<p><strong>主同步信号</strong>的全称为：Primary Synchroniztion Singnal，简称PSS。PSS在SSB的第一个OFDM符号上发送，频域占用了127个子载波，其余子载波为空。</p>
<p><strong>辅同步信号</strong>的全称为：Secondary Synchroniztion Singnal，简称SSS。SSS在SSB的第三个OFDM符号上发送，频域占用了127个子载波，其余子载波用于PBCH及隔离带。</p>
<p>PSS携带了3个小区号，SSS携带了336个小区组号，这两者共同决定了5G系统中的1008个物理小区号（Physical Cell Identity，简称PCI）。一旦手机成功搜索到了PSS和SSS，也就知道了这个5G载波的物理小区号。</p>
<p><strong>物理广播信道</strong>的全称为：Physical Broadcast Channel，简称PBCH。PBCH在第二个和第四个OFDM符号上在SSB内全带宽发送，另外也使用SSS两端的48个子载波来发送。</p>
</blockquote>
<br/>

<h2 id="SSB频域位置概述"><a href="#SSB频域位置概述" class="headerlink" title="SSB频域位置概述"></a>SSB频域位置概述</h2><p>　　在频域中，一个 SS&#x2F;PBCH 块由240个相邻的子载波组成，子载波在 SS&#x2F;PBCH 块中按从0到239的顺序排列。下表给出了 PBCH 的 PSS、 SSS、 PBCH 和 DMRS 的位置。PBCH、 PBCH DMRS、 PSS 和 SSS 的位置参见38.211的表7.4.3.1-1 。下表中表示为“ Set to 0”的资源元素对应的复值符号被设置为零。 从下表中可以看到，PBCH DM-RS 的位置取决于PCI ($v &#x3D; N_{ID}^{cell } mod 4$) （小区ID PCI 由 UE 使用 PSS&#x2F;SSS 确定）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200722094041.png"></p>
  <br/>

  <br/>

<h2 id="SSB时域位置概述"><a href="#SSB时域位置概述" class="headerlink" title="SSB时域位置概述"></a>SSB时域位置概述</h2><ul>
<li>每个 SSB 跨越时域中的 4 个 OFDM 符号。</li>
<li>SSB 的周期性定期传输为 5ms、10ms、20ms、40ms、80ms 或 160ms。</li>
<li>虽然较长的 SSB 周期可提高网络性能，但较短的周期有助于更快进行小区搜索。</li>
<li>在初始小区搜索或空闲模式移动期间，UE 可以假定默认周期为<em>20ms。</em></li>
</ul>
<p>　　SSB是周期性发送的，其周期可以从5毫秒到160毫秒之间变化。手机在进行小区搜索时，不能在某一个频点上等待过长时间，因此默认按照20毫秒来进行。</p>
<p>　　如果手机在某个频点上等待了20毫秒的时间，一直未发现SSB，则认为这个频点上不存在5G载波，然后转到同步栅格里面的下一个频点再次尝试。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718114146.jpg"></p>
<blockquote>
<p><strong>同步栅格</strong></p>
<p>由于5G的系统带宽动辄100MHz，高频甚至能达到400MHz，远大于4G的系统带宽（最大20MHz），如果像4G一样把同步信号放在载波中心，手机按照100KHz的粒度来搜索的话，所需要的时间非常长，而且非常耗电，完全让人无法接受。</p>
<p>因此，5G不再把SSB放在载波中心，而是放在每个频段内一组有限的可能位置，称作“<strong>同步栅格</strong>（Synchronization Raster）”。手机只需在这些稀疏的同步栅格上搜索SSB即可，速度更快。</p>
</blockquote>
<h3 id="SS-Burst-Set"><a href="#SS-Burst-Set" class="headerlink" title="SS Burst Set"></a>SS Burst Set</h3><p>　　为了使PSS &#x2F; SSS和PBCH能够进行波束扫描，定义了同步广播块集合(SS Burst Set)。 SS Burst Set由一个或多个SSB组成，每个SSB可能在不同的波束上传输。</p>
<div class="note info"><p>　　一个波束扫描内所有SSB成的set被称作SS burst set</p>
<p>SS Burst Set 有翻译为同步信号集、 同步广播块集合 也有翻译为 同步信号突发集</p>
<p>本文翻译 为同步广播块集合 来自书籍 <a href="https://book.douban.com/subject/30476355/">5G无线系统设计与国际标准</a></p>
</div>

<ul>
<li><p>同步广播块集合由一个或多个SSB组成。</p>
</li>
<li><p>同步广播块集合中的SSB以时分复用的方式传输。</p>
</li>
<li><p>同步广播块集合始终限制在5ms窗口内，位于10ms无线帧的前半部分或后半部分。</p>
</li>
<li><p>网络通过RRC参数ssb-PeriodicityServingCell设置SSB周期性，其取值范围为{5ms，10ms，20ms，40ms，80ms，160ms}。</p>
</li>
<li><p>同步广播块集合内的候选SSB的最大数量（Lmax）取决于载波频率&#x2F;频段，如下表所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Carrier Frequency</strong></th>
<th><strong>Max. No. of Candidate SSBs</strong> **within SS Burst Set ($L_{max}$)</th>
</tr>
</thead>
<tbody><tr>
<td>fc ≤ 3 GHz*</td>
<td>4</td>
</tr>
<tr>
<td>3 GHz* &lt; fc ≤ 6 GHz</td>
<td>8</td>
</tr>
<tr>
<td>fc &gt; 6 GHz</td>
<td>64</td>
</tr>
</tbody></table>
<blockquote>
<p>注: SCS &#x3D; 30 kHz情况：对于成对频谱，为3 GHz，对于非成对频谱，为2.4 GHz</p>
</blockquote>
<p>　　在<em>5ms</em>半帧内，SS Burst Set 设置的候选 SSB 的起始 OFDM 符号索引取决于子载波间距 （SCS） 和载波频率&#x2F;频段（下表中汇总）。大括号内的条目表示候选 SSB 的 OFDM 起始符号。🌟有关详细信息，请参阅 38.213 的第 4.1 节。 </p>
<table>
<thead>
<tr>
<th>SCS</th>
<th>OFDM starting symbols of the candidate SSBs</th>
<th>fc ≤ 3 GHz  Lmax &#x3D; 4</th>
<th>3 GHz&lt; fc≤ 6 GHz  Lmax &#x3D; 8</th>
<th>fc &gt; 6 GHz   Lmax &#x3D; 4</th>
</tr>
</thead>
<tbody><tr>
<td>CaseA: 15 kHz</td>
<td>{2,8} + 14n</td>
<td>n &#x3D; 0,1  {2,8,16,22}</td>
<td>n &#x3D; 0, 1, 2, 3  {2,8,16,22,30,36,44,50}</td>
<td>NA</td>
</tr>
<tr>
<td>CaseB: 30 kHz</td>
<td>{4,8,16,20} + 28n</td>
<td>n &#x3D; 0   {4,8,16,20}</td>
<td>n &#x3D; 0, 1  {4,8,16,20,32,36,44,48}</td>
<td>NA</td>
</tr>
<tr>
<td>CaseC: 30 kHz</td>
<td>{2,8} + 14n</td>
<td>n &#x3D; 0, 1   {2,8,16,22}</td>
<td>n &#x3D; 0, 1, 2, 3  {2,8,16,22,30,36,44,50}</td>
<td>NA</td>
</tr>
<tr>
<td>CaseD:  120 kHz</td>
<td>{4,8,16,20} + 28n</td>
<td>NA</td>
<td>NA</td>
<td>n&#x3D;0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18{4,8,16,20 … 508,512,520,524}</td>
</tr>
<tr>
<td>CaseE:  240 kHz</td>
<td>{8,12,16,20,32,36,40,44} + 56n</td>
<td>NA</td>
<td>NA</td>
<td>n&#x3D;0,1,2,3,5,6,7,8{8,12,16,20 … 480,484,488,492}</td>
</tr>
</tbody></table>
<blockquote>
<p>* SCS &#x3D; 30 kHz情况：对于成对频谱，为3 GHz，对于非成对频谱，为2.4 GHz</p>
</blockquote>
<p>注意，当网络不使用波束成形时，它可能只发送一个SSB，因此只能有一个SSB起始位置。</p>
  <br/>

<p>　　针对不同子载波间隔，每传输半帧SSB的候选位置如下定义：</p>
<blockquote>
<p>A：子载波间隔15kHz，针对FR1频带内不大于3GHz的NR载波频率，SSB的候选传输时刻可配置在0，1时隙的{2， 8}OFDM位置，这样共4个候选时刻；而FR1 频带内大于3 GHz的NR载波频率，SSB的候选传输时刻配置在0，1，2，3时隙的{2，8}OFDM位置，共8个候选时刻；</p>
<p>B：子载波间隔30kHz，针对FR1频带内不大于3GHz的NR载波频率，SSB的候选传输时刻可配置在以0时隙起始计算的{4，8，16，20}OFDM位置，这样共4个候选时刻；而FR1 频带内大于3GHz的NR载波频率，SSB的候选传输时刻配置在0，2时隙分别为起始计算的{4，8，16，20}OFDM位置，共8个候选时刻；</p>
<p>C：子载波间隔30kHz，5G FDD频谱模式下，针对FR1频带内不大于3GHz的NR载波频率，SSB的候选传输时刻可配置在0，1时隙的{2，8}OFDM位置，这样共4个候选时刻；而FR1频带内大于3GHz的NR载波频率，SSB的候选传输时刻配置在0，1，2，3时隙内的{2，8}OFDM位置，共8个候选时刻；5GTDD频谱模式下，针对FR1频带内不大于2.4GHz的NR载波频率，SSB的候选传输时刻可配置在0，1时隙的{2，8}OFDM位置，这样共4个候选时刻；而FR1频带内大于2.4GHz的NR载波频率，SSB的候选传输时刻刻配置在0，1，2，3时隙内的{2，8}OFDM位置，共8个候选时刻；</p>
<p>D：子载波间隔120kHz，对于FR2频带内NR载波频率，SSB的候选传输时刻配置在0，2，4，6，10，12，14，16，20，22，24，26，30，32，35，36时隙分别为起始计算的{4，8，16，20}OFDM位置，共64个候选时刻。</p>
<p>E：子载波间隔240kHz，对于FR频带内NR载波频率，SSB的候选传输时刻配置在0，4，8，12，20，24，28，32时隙分别为起始计算的{8，12，16，20，32，36，40，44}OFDM位置，共64个候选时刻。</p>
</blockquote>
  <br/>

<p> 　　5G NR在系统架构中遵循一个重要设计理念就是系统参数设置相当灵活，在SSB中体现在子载波间隔（SCS，subcarrier spacing）可以与其他物理传输信道独立设置，但是否需要不同配置有待于实际组网环境下进一步验证。终端在开机搜网同步时，根据NR的工作频段可以确定SSB的子载波间隔以及SSB候选传输位置式样(A&#x2F;B&#x2F;C&#x2F;D&#x2F;E)，如果异频载波SSB的子载波间隔通过高层信令进行传递明确为30kHz时，SSB候选传输位置式样B可扩展适用于SCS定义为仅15kHz的FR1中NR工作频带。另外，当终端被配置为FR2频带内的载波聚合或者FR1频带内连续频率的载波聚合机制时，如果网络侧提供了载波聚合任何一个小区的SSB的子载波间隔信息，终端认为这一系列载波聚合小区的SSB子载波间隔一致。</p>
<p>　　针对在半帧内传输的SSB候选位置式样ABCDE，终端可以通过解码PBCH载荷比特来确定当前传输SSB的具体索引位置，对于半帧包含4个SSB候选传输位置，通过2个低比特位（LSB）确定索引，而半帧包含8个SSB候选传输位置，则通过3个低比特位（LSB）确定索引，这两种情况下PBCH索引恰恰与SSB中DMRS的高德伪随机序列初始序列索引呈一一对应的关系，终端在确定2个低比特位或者3个低比特位时并不是直接通过解码PBCH传输比特获知，而是间接通过解码DMRS进行逻辑映射。半帧包含64个SSB候选传输位置，传输SSB中DMRS的索引按照3个低比特位循环映射（8个SSB循环），终端结合3个低比特位（LSB）与PBCH载荷的3个额外高比特位（MSB）共同确定SSB的传输索引。PBCH有效载荷共32比特，包含承载RRC内容23比特，这23比特中有6比特作为计算无线帧的高位6比特，除了这23比特之外，物理层额外与传输时刻相关4比特作为计算无线帧的的地位4比特， 1比特作为无线帧中的半帧标识，3比特作为确定SSB索引的高位3比特，剩余1比特协议没做规定，MAC层实体为了与传输字节对齐进行填补。</p>
<p>　　作为示例，在SCS&#x3D;15 kHz且载波频率在3 GHz和6 GHz之间的情况下，SS突发集合内的候选SSB的时序在下图中示出。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718103811.png"></p>
<br/>

  <br/>

<h2 id="LTE同步信号和5G同步信号之间的区别："><a href="#LTE同步信号和5G同步信号之间的区别：" class="headerlink" title="LTE同步信号和5G同步信号之间的区别："></a>LTE同步信号和5G同步信号之间的区别：</h2><h3 id="生成方法不同："><a href="#生成方法不同：" class="headerlink" title="生成方法不同："></a>生成方法不同：</h3><p>　　LTE中的PSS是长度为62的 Zadoff-Chu 序列，NR中的PSS是长度为127的m序列。LTE中的SSS是长度为62的m序列，而NR中的SSS是长度为127的GOLD序列。</p>
<h3 id="PCI的数量不同："><a href="#PCI的数量不同：" class="headerlink" title="PCI的数量不同："></a>PCI的数量不同：</h3><p>　　LTE中定义了504 PCI，分为168组，对应168个SSS；每组包含3个小区，对应3个PSS。NR定义1008个PCI，分为336组，对应336个SSS；每组包含3个小区，对应3个PSS。</p>
<h3 id="同步信号的时域和频域位置不同："><a href="#同步信号的时域和频域位置不同：" class="headerlink" title="同步信号的时域和频域位置不同："></a>同步信号的时域和频域位置不同：</h3><p>　　LTE PSS、SSS和PBCH的频域和时域位置在系统中是固定的，总是占据系统带宽的中心频率部分。PSS与SSS和PBCH没有严格的结合关系。然而，在5G中，PSS、SSS和PBCH绑定在一起，称为SSB。不同LTE子载波间隔固定为15k，而NR中的PBCH子载波间隔根据频带而变化。</p>
<h3 id="同步过程不同"><a href="#同步过程不同" class="headerlink" title="同步过程不同 :"></a>同步过程不同 :</h3><p>  　　正是由于NR和LTE的同步信号不同，其同步过程也不同于LTE。在NR中通常使用波束成形，并且同步信号SSB在不同的波束上传输。因此，同步过程的一个目标是找到最佳波束。此过程通过确定 SSB 的索引 ( the SSB’s index)来完成。在5ms周期内，SSB的索引与波束一一对应。通过确定最佳SSB的索引，可以找到最佳的波束方向。</p>
<p>　　通过确定SSB的频域位置，它可以基于其他参数（$k_{ssb}$，$N_{CRB} ^ {SSB}$等）。 获取 pointA 的位置，实现对BWP的管理。</p>
<br/>

<h2 id="SSB-波束赋形"><a href="#SSB-波束赋形" class="headerlink" title="SSB 波束赋形"></a>SSB 波束赋形</h2><p>　　5G相对于4G最大的优势在于引入了波束赋形。实际使用中，可以把一个周期内的不同SSB分配到不同的波束上发送，每个SSB的发送时间不同，大家轮流依次发送，因此这种方式叫做SSB波束扫描，这些参与波束扫描的SSB集合就叫做同步广播块集合（SS Burst Set）。由于每个波束的能量更为集中，这样就有效增强了5G的覆盖。</p>
<p>　　由于每周期不同频段所支持的SSB发送次数不同，它们的波束赋形能力也各不相同。总体上来说，频段越高，波束赋形能力越强。</p>
<p>　　由于同步信号SSB是在不同的beam上发送的。因此，同步过程的一个目的就是要找到最优的beam。这个过程是通过确定SSB的index来完成的。<br>5ms周期中SSB的index与波束是一一对应的关系，通过确定最优SSB的index就可以找到最优的波束方向。</p>
<blockquote>
<p>对于3GHz以下的频段，一个SS突发集里最多包含4个SSB，因此最多可扫描4个波束；</p>
<p>对于3GHz~6GHz的频段，一个SS突发集里最多包含8个SSB，因此最多可扫描8个波束；</p>
<p>对于高于6GHz的毫米波mmWave频段，一个SS突发集里最多包含64个SSB，因此最多可扫描64个波束。</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718114523.png"></p>
  <br/>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　当UE开机后想要接入小区时，会进行小区搜索的操作。在NR中，小区搜索主要基于对下行同步信道及信号的检测来完成。终端通过小区搜索过程获得小区ID、频率同步（载波频率）、下行时间同步（包括无线帧定时、半帧定时，时隙定时及符号定时）。具体来看，整个小区搜索过程又包括主同步信号搜索、 辅同步信号检测及物理广播信道检测三部分。本文主要对同步信号块 SSB 的结构以及时频位置进行了描述。</p>
  <br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>封面图：<a href="https://www.zcool.com.cn/u/14696761">壹零腾_-<em>原创作品</em>-<em>站酷</em>(ZCOOL)</a></p>
<p><a href="https://www.sharetechnote.com/html/5G/5G_SS_Block.html">5 g&#x2F;nr-SS Block</a></p>
<p>Lin X, Li J, Baldemair R, et al. 5G new radio: Unveiling the essentials of the next generation wireless access technology[J]. IEEE Communications Standards Magazine, 2019, 3(3): 30-37.</p>
<p>Omri A, Shaqfeh M, Ali A, et al. Synchronization procedure in 5G NR systems[J]. IEEE Access, 2019, 7: 41286-41295.</p>
<p><a href="https://www.blacktechnoguys.com/2019/12/synchronization-signal-block.html">Synchronization Signal Block</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_927cff0101019un0.html">LTE：小区搜索过程（cell search procedure）</a></p>
<p><a href="http://www.techplayon.com/5g-nr-cell-search-and-synchronization-acquiring-system-information/">5G NR Cell Search and Synchronization</a></p>
<p><a href="http://howltestuffworks.blogspot.com/2019/10/5g-nr-synchronization-signalpbch-block.html">5G NR: Synchronization Signal&#x2F;PBCH block (SSB)</a></p>
<p><a href="https://medium.com/@mishra.eric/understanding-nr5g-synchronisation-signal-block-ssb-7a8d56a48e16">Understanding NR5G Synchronisation Signal Block (SSB)</a></p>
<ol>
<li><p>3GPP TS 38.211</p>
</li>
<li><p>3GPP TS 38.212</p>
</li>
<li><p>3GPP TS 38.213</p>
</li>
<li><p>3GPP TS 38.331, 38.300</p>
</li>
</ol>
</blockquote>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>溪云初起日沉阁，山雨欲来风满楼。</p>
<p>– 志南 《绝句·古木阴中系短篷》</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>5G NR</tag>
      </tags>
  </entry>
  <entry>
    <title>创世纪图书馆 Library Genesis 图书下载指南</title>
    <url>/posts/1788.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718211615.jpg"></p>
<p>　　创世纪图书馆 Library  Genesis 是一个超棒的电子书下载网站，它让我们可以免费下载数百万本电子书，尤其是英文电子书。</p>
<span id="more"></span>

<p>Download English eBooks in Library Genesis</p>
<p>　　Library  Genesis是一个很棒的图书下载网站，它让我们可以免费访问数百万本电子书。包括不限于小说、科幻、教科书、学术作品、漫画等。其中的电子书多为 epub、pdf、mobi。 非常适合在PC、Kindle、iPad、Android等电子阅读器设备上阅读。</p>
<div class="note info"><p>Library  Genesis 英文书较多，建议搜索英文。当然中文书也有的只不过少一点。</p>
</div>



<h2 id="第1步-打开创世纪图书馆Library-Genesis"><a href="#第1步-打开创世纪图书馆Library-Genesis" class="headerlink" title="第1步 打开创世纪图书馆Library  Genesis"></a>第1步 打开创世纪图书馆Library  Genesis</h2><p>创世纪图书馆的主要地址是：</p>
<p><strong><a href="http://gen.lib.rus.ec/">gen.lib.rus.ec</a></strong></p>
<p><strong><a href="https://libgen.is/">https://libgen.is</a></strong></p>
<p><strong><a href="http://93.174.95.27/">http://93.174.95.27</a> （2020年3月新增）</strong></p>
<p><a href="http://libgen.li/"><strong>http://libgen.li</strong></a> <strong>（2020年4月新增）</strong></p>
<p><a href="https://libgen.lc/"><strong>https://libgen.lc</strong></a> <strong>（2020年5月新增）</strong></p>
<p><strong><a href="http://185.39.10.101/">http://185.39.10.101</a></strong> <strong>（2020年5月新增）</strong></p>
<p><a href="http://genesis.lib/"><strong>http://genesis.lib</strong></a> <strong>（2020年5月新增）</strong></p>
<p>这些通常可以正常工作，但是如果您需要替代方法，请尝试搜索</p>
<p>“**<a href="https://www.google.com/search?q=library+genesis+proxy&pws=0&gl=us&gws_rd=cr">library genesis proxy</a>**”</p>
<p>要么</p>
<p><strong><a href="https://www.google.com/search?q=library+genesis+mirror&pws=0&gl=us&gws_rd=cr">“library genesis mirror”</a></strong></p>
<p>打开后进行下一步操作</p>
<br/>

<h2 id="第2步-搜索图书"><a href="#第2步-搜索图书" class="headerlink" title="第2步-搜索图书"></a>第2步-搜索图书</h2><p>所以，你现在应该在这样一个页面上</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718181833.png"></p>
<p>只需在搜索框中输入您的搜索词-没有必要改变任何设置。你可以输入作者、书名或主题</p>
<p>例如，我们将搜索 Lewis Carroll 的经典作品《爱丽丝梦游仙境》，输入爱丽丝梦游仙境并按下搜索键。发现似乎没找到中文的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718182249.png"></p>
<p>可以尝试搜索英文名字 《Alice’s Adventures in Wonderland》，然后搜到很多了，棒棒的。 📚</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718182625.png"></p>
<br/>

<h2 id="第3步-找到你需要下载的书"><a href="#第3步-找到你需要下载的书" class="headerlink" title="第3步 找到你需要下载的书"></a>第3步 找到你需要下载的书</h2><p>在搜索结果中寻找你想要期望下载的那一本书。主要需要确认作者、书名以及格式。（因为有时候既能搜到 PDF 也能搜到 Epub ）。</p>
<p>比如我想下载下面这本电子书，因为它是 Epub 格式的，读起来更方便。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718183100.png"></p>
<br/>

<h2 id="第4步-点击下载链接"><a href="#第4步-点击下载链接" class="headerlink" title="第4步 点击下载链接"></a>第4步 点击下载链接</h2><p>点击需要下载的那本书，然后跳转到另一个页面中。📄</p>
<p>在屏幕下面的“ mirrors”中将看到很多个下载镜像链接，点击其中一个（你可能需要右键点击“打开新标签”），去下载。若不行的话，可以重新打开一个镜像进行下载。一般而言，基本上都是能下载的，只不过可能某些网站需要<code>科学上网</code>，因为都是国外 的网站。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718183546.png"></p>
<p>我就选择第一个下载镜像好啦，一般最右边那几个下载链接多为磁力链接，从镜像的名字你应该就能有所察觉。</p>
<br/>

<h2 id="第5步-从镜像下载"><a href="#第5步-从镜像下载" class="headerlink" title="第5步 从镜像下载"></a>第5步 从镜像下载</h2><p>点击第一个镜像下载链接，来到了一个新的页面。点击其中的 <code>GET</code> 然后即可下载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718193319.png"></p>
<p>下载好后就可以享受阅读啦😋</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200718193458561.png"></p>
<blockquote>
<p>提示:</p>
<p>若你点的是第三个下载链接 Z-Library 。需要点击书的链接，然后进入另一个页面才能点击下载。</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718193933.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718194101.png"></p>
<p>点的是第五个 BookFI.net的话 ，记得点击书名下面那个 Download ，然后直接下载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718194223.png"></p>
<p>后面那几个磁力下载的话可以使用 Xdown 或迅雷等软件下载。其它那些下载页面都大同小异，注意找准 Download 哦。 </p>
<br/>

<h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>筛选可以更精准的搜到某类型的书籍，如下图所示，可以按你搜索书籍的类别进行选择，也可以按作者搜索。一般对于我而言没必要勾选那些，因为一般我都会确定要搜索书籍的名称。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718194832.png"></p>
<br/>

<h2 id="展示书籍有多丰富"><a href="#展示书籍有多丰富" class="headerlink" title="展示书籍有多丰富"></a>展示书籍有多丰富</h2><p>搜 5G</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200718195125128.png"></p>
<p>按年份排一下，就是如此多，更新也很快。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200718195314.png"></p>
<br />

<div class="note info"><p>学海无涯 😉</p>
</div>

<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>生活</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>电子书</tag>
        <tag>网站分享</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 调用 OpenCV 打开摄像头</title>
    <url>/posts/56322.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721225351.jpg"></p>
<p>　　测试使用 MinGW-64 编译的OpenCV 是否正常，用 Qt 打开视频显示在 <code>label</code>。</p>
<span id="more"></span>



<p><a href="https://www.lifeee.top/posts/50934.html">当参见上文完成编译与安装后</a>，你可以在  <code>build/bin</code> 下面看到各种动态库 ，本文的目的就是使用 Qt 来测试一下啊 OpenCV。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721172331.png"></p>
<br/>

<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>打开Qt，新建一个Qt Widgets Application项目，添加1个label控件和2个pushButton按钮，修改pushButton按钮的名字为“开始”和“停止”，控件对象名改为 <code>label_Video</code>  、<code>pushButton_Open</code>  、 <code>pushButton_Close</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721173631890.png" alt="image-20200721173631890"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721173739290.png" alt="image-20200721173739290"></p>
<p>其它默认，勾选上 MinGW 64</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721173821531.png" alt="image-20200721173821531"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721174446565.png" alt="image-20200721174446565"></p>
<p>接下来要添加“<strong>信号槽</strong>”，分别选中两个push button，右键选择**转到槽…**，然后选择clicked()，会自动创建信号与槽及其连接。当然也可以选择手动添加槽函数，并用 <code>connect</code> 连接。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721192645948.png" alt="image-20200721192645948"></p>
<br/>



<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>为 <code>E:\20200325\DevelopmentEnvironment\opencv3411\build\install\x64\mingw\bin</code> 配置环境变量，记得重启一下。（ 我记得我以前配其它的不重启也行啊 ，但这个我的不重启不生效）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721212901172.png"></p>
<p>只要打开系统属性窗口并在“PATH”中添加一个新的对象元素就可以了。它们通常是用“;”隔开的，因此请在“;”后添加一个新项。注意，这个路径只与Windows操作系统相关，并且可以在这里找到OpenCV的DLL文件，以便使构建过程更加容易。Linux和macOS用户不需要对此做任何事情。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721213323.png"></p>
<br/>

<h2 id="代码书写"><a href="#代码书写" class="headerlink" title="代码书写"></a>代码书写</h2><p>参考 <a href="https://blog.csdn.net/mars_xiaolei/article/details/83317032">Qt5：opencv摄像头播放视频</a>  或者 OpenCV 自带的<a href="https://docs.opencv.org/3.4/examples.html">例子</a>。</p>
<p>其中 OpenCV 下的 例子的代码如下，是在 C++ MSVC 下的代码。参考其处理流程即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/videoio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span>  <span class="comment">// cv::Canny()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::cerr; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat frame;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Opening camera...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// open the first camera</span></span><br><span class="line">    <span class="keyword">if</span> (!capture.<span class="built_in">isOpened</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;ERROR: Can&#x27;t initialize camera capture&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Frame width: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;     height: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Capturing FPS: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FPS) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Press &#x27;ESC&#x27; to quit, &#x27;space&#x27; to toggle frame processing&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Start grabbing...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> nFrames = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> enableProcessing = <span class="literal">false</span>;</span><br><span class="line">    int64 t0 = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">    int64 processingTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        capture &gt;&gt; frame; <span class="comment">// read the next frame from camera</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;ERROR: Can&#x27;t grab camera frame.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nFrames++;</span><br><span class="line">        <span class="keyword">if</span> (nFrames % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">            int64 t1 = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Frames captured: &quot;</span> &lt;&lt; cv::format(<span class="string">&quot;%5lld&quot;</span>, (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)nFrames)</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;    Average FPS: &quot;</span> &lt;&lt; cv::format(<span class="string">&quot;%9.1f&quot;</span>, (<span class="type">double</span>)<span class="built_in">getTickFrequency</span>() * N / (t1 - t0))</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;    Average time per frame: &quot;</span> &lt;&lt; cv::format(<span class="string">&quot;%9.2f ms&quot;</span>, (<span class="type">double</span>)(t1 - t0) * <span class="number">1000.0f</span> / (N * <span class="built_in">getTickFrequency</span>()))</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;    Average processing time: &quot;</span> &lt;&lt; cv::format(<span class="string">&quot;%9.2f ms&quot;</span>, (<span class="type">double</span>)(processingTime) * <span class="number">1000.0f</span> / (N * <span class="built_in">getTickFrequency</span>()))</span><br><span class="line">                 &lt;&lt; std::endl;</span><br><span class="line">            t0 = t1;</span><br><span class="line">            processingTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!enableProcessing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;Frame&quot;</span>, frame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            int64 tp0 = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">            Mat processed;</span><br><span class="line">            cv::<span class="built_in">Canny</span>(frame, processed, <span class="number">400</span>, <span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line">            processingTime += cv::<span class="built_in">getTickCount</span>() - tp0;</span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;Frame&quot;</span>, processed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">27</span><span class="comment">/*ESC*/</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">32</span><span class="comment">/*SPACE*/</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enableProcessing = !enableProcessing;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enable frame processing (&#x27;space&#x27; key): &quot;</span> &lt;&lt; enableProcessing &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of captured frames: &quot;</span> &lt;&lt; nFrames &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> nFrames &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br/>

<p>我的 Qt 项目中完整的代码为：</p>
<p>QtOpenCVTest.pro</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"></span><br><span class="line">CONFIG += c++<span class="number">11</span></span><br><span class="line"></span><br><span class="line"># The following define makes your compiler emit warnings <span class="keyword">if</span> you use</span><br><span class="line"><span class="meta"># any Qt feature that has been marked deprecated (the exact warnings</span></span><br><span class="line"><span class="meta"># depend on your compiler). Please consult the documentation of the</span></span><br><span class="line"><span class="meta"># deprecated API in order to know how to port your code away from it.</span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"># You can also make your code fail to compile <span class="keyword">if</span> it uses deprecated APIs.</span><br><span class="line"># In order to <span class="keyword">do</span> so, uncomment the following line.</span><br><span class="line"># You can also select to disable deprecated APIs only up to a certain version of Qt.</span><br><span class="line">#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=<span class="number">0x060000</span>    <span class="meta"># disables all the APIs deprecated before Qt 6.0.0</span></span><br><span class="line"></span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mainwindow.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += \</span><br><span class="line">    mainwindow.h</span><br><span class="line"></span><br><span class="line">FORMS += \</span><br><span class="line">    mainwindow.ui</span><br><span class="line"></span><br><span class="line"># Default rules <span class="keyword">for</span> deployment.</span><br><span class="line">qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin</span><br><span class="line"><span class="keyword">else</span>: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin</span><br><span class="line">!<span class="built_in">isEmpty</span>(target.path): INSTALLS += target</span><br><span class="line"></span><br><span class="line">INCLUDEPATH += E:\<span class="number">20200325</span>\DevelopmentEnvironment\opencv3411\build\install\include</span><br><span class="line"></span><br><span class="line">LIBS += E:\<span class="number">20200325</span>\DevelopmentEnvironment\opencv3411\build\install\x64\mingw\bin\libopencv_*.dll</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在上面的代码中，需要替换自己的路径。</p>
</blockquote>
<p>mainwindow.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QTimer&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QImage&quot;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_Open_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_Close_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadCarmeraFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    </span><br><span class="line">    cv::VideoCapture capture;</span><br><span class="line">    QTimer *timer;</span><br><span class="line">    Mat frame;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>mainwindow.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;QDebug&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot; 测试 OpenCV 打开 摄像头&quot;</span>);</span><br><span class="line">    timer=<span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp; MainWindow::ReadCarmeraFrame);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton_Open, &amp;QPushButton::clicked , <span class="keyword">this</span>, &amp;MainWindow::on_pushButton_Open_clicked  );<span class="comment">//打开摄像头</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton_Close, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::on_pushButton_Close_clicked);<span class="comment">// 关闭摄像头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::ReadCarmeraFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取图像帧</span></span><br><span class="line">    capture&gt;&gt;frame;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将视频显示到label上</span></span><br><span class="line">    QImage image = <span class="built_in">QImage</span>((<span class="type">const</span> uchar*)frame.data,frame.cols,frame.rows,QImage::Format_RGB888).<span class="built_in">rgbSwapped</span>();</span><br><span class="line">    ui-&gt;label_Video-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开摄像头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_Open_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    capture.<span class="built_in">open</span>(<span class="number">0</span>);<span class="comment">//打开摄像头</span></span><br><span class="line">    <span class="keyword">if</span> (!capture.<span class="built_in">isOpened</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ERROR: Can&#x27;t initialize camera capture&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Frame width: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;     height: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Capturing FPS: &quot;</span> &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_FPS) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">25</span>);<span class="comment">//开启定时器，一次25ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭摄像头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_Close_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();    <span class="comment">//关闭定时器</span></span><br><span class="line">    capture.<span class="built_in">release</span>();<span class="comment">//释放图像</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>mainwindow.ui 的 xml 为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMainWindow&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MainWindow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>995<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>709<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sizePolicy&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sizepolicy</span> <span class="attr">hsizetype</span>=<span class="string">&quot;Expanding&quot;</span> <span class="attr">vsizetype</span>=<span class="string">&quot;Expanding&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">horstretch</span>&gt;</span>0<span class="tag">&lt;/<span class="name">horstretch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">verstretch</span>&gt;</span>0<span class="tag">&lt;/<span class="name">verstretch</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">sizepolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minimumSize&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>550<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;centralwidget&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;QGridLayout&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gridLayout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">row</span>=<span class="string">&quot;0&quot;</span> <span class="attr">column</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;QVBoxLayout&quot;</span> <span class="attr">name</span>=<span class="string">&quot;verticalLayout&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QLabel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;label_Video&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sizePolicy&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">sizepolicy</span> <span class="attr">hsizetype</span>=<span class="string">&quot;Expanding&quot;</span> <span class="attr">vsizetype</span>=<span class="string">&quot;Expanding&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horstretch</span>&gt;</span>0<span class="tag">&lt;/<span class="name">horstretch</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">verstretch</span>&gt;</span>0<span class="tag">&lt;/<span class="name">verstretch</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">sizepolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">string</span>&gt;</span>TextLabel<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;QHBoxLayout&quot;</span> <span class="attr">name</span>=<span class="string">&quot;horizontalLayout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pushButton_Open&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">string</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pushButton_Close&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">string</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMenuBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;menubar&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>995<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>26<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QStatusBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;statusbar&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br/>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721213453.png"></p>
<br/>

<h2 id="crashed-问题解决"><a href="#crashed-问题解决" class="headerlink" title="crashed 问题解决"></a>crashed 问题解决</h2><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200721_194414_1365_332_qtcreator.png" alt="ShareX_20200721_194414_1365_332_qtcreator"></p>
<blockquote>
<p>问题：用qt creator写程序，运行发生crashed，一般是在程序中使用了第三方库，运行时找不到dll，在qt creator中运行会直接crashed，不提示原因。</p>
<p>解决办法：直接运行生成的exe文件，会提示缺少xxxdll，此时，直接将缺少的dll放到exe所在文件夹中，再次运行，成功。也可以将dll添加到系统路径中。总之，让程序找到调用的第三方库，就不会creashed了。<br>————————————————<br>版权声明：本文为CSDN博主「LoveCherish1993」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Joker_mw/article/details/79351076">https://blog.csdn.net/Joker_mw/article/details/79351076</a></p>
</blockquote>
<p>解决方法有两个：</p>
<ul>
<li><p>第一种方法 需要将</p>
</li>
<li><p><code>E:\20200325\DevelopmentEnvironment\opencv3411\build\install\x64\mingw\bin</code></p>
</li>
</ul>
<p>  的动态库 dll 文件拷贝到运行的 exe 目录中</p>
<ul>
<li><p>第二种就是为</p>
<p> <code>E:\20200325\DevelopmentEnvironment\opencv3411\build\install\x64\mingw\bin</code> </p>
<p>配置环境变量，记得重启一下。（ 我记得我以前配其它的不重启也行啊 ，但这个我的不重启不生效）。</p>
</li>
</ul>
<br />



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/mars_xiaolei/article/details/83317032">Qt5：opencv摄像头播放视频</a></p>
<p><a href="https://docs.opencv.org/3.4/d8/dfe/classcv_1_1VideoCapture.html">cv::VideoCapture Class Reference</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake和minGW-64 编译安装 OpenCV3.4.11以供 Qt 使用</title>
    <url>/posts/50934.html</url>
    <content><![CDATA[<p>​                           </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721214708.jpg"></p>
<p>　　minGW 64 bit 编译 OpenCV 3.4.11 ，记录了详细的下载、编译、安装以及问题解决的步骤与思路。</p>
<span id="more"></span>



<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境:"></a>编译环境:</h2><p><font  color=green size=7>首</font>先说明我的操作系统版本与本文中编译的OpenCV版本等：</p>
<p>Windows10 64bit</p>
<p>OpenCV 3.4.11</p>
<p>OpenCV Contrib 3.4.11 （可选，用到FREAK、Surf和Sift算法需要编译）</p>
<p>QT5.14.0  with MinGW5.14.1 64bit<br>CMake 3.17.0</p>
<br/>

<h2 id="编译前的准备–下载"><a href="#编译前的准备–下载" class="headerlink" title="编译前的准备–下载"></a>编译前的准备–下载</h2><h3 id="下载OpenCV"><a href="#下载OpenCV" class="headerlink" title="下载OpenCV"></a>下载OpenCV</h3><p>　　在 Github 中下载 <a href="https://github.com/opencv/opencv/releases">OpenCV</a> ，选择 3.4.11版本。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720204354.png"></p>
<p>　　若使用 MSVC 版的，可直接下载 上图那个 vc14_vc15 .exe 那个，安装好后为openCV配置环境变量直接就能用了。而 OpenCV 没有编译好的 MinGW 版， 所以需要下载源码进行编译。</p>
<blockquote>
<ul>
<li>MSVC，需要使用Visual C++（微软的VC编译器）作为编译器</li>
<li>MinGW是指Minimalist GNU For  Windows，是将GNU开发工具移植到Win32平台下的产物，是一套Windows上的GNU开发工具移植到Win32平台下的产物，是一套Windows上的GNU工具集，用其开发的程序不需要额外的第三方DLL支持就可以在Windows下运行。</li>
</ul>
<p><strong>OpenCV官网&#x2F;GitHub下载的一般是支持的vc，所以对于MinGW版本的Qt需要自己下载源码重新编译</strong></p>
</blockquote>
<br/>

<h3 id="下载-OpenCV-Contrib"><a href="#下载-OpenCV-Contrib" class="headerlink" title="下载 OpenCV Contrib"></a>下载 OpenCV Contrib</h3><p>　　在 Github 中下载 <a href="https://github.com/opencv/opencv_contrib/releases">OpenCV Contrib 3.4.11</a> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720205416.png"></p>
<br/>

<h3 id="下载-CMake"><a href="#下载-CMake" class="headerlink" title="下载 CMake"></a>下载 CMake</h3><p>　　下载  <a href="https://cmake.org/download/">CMake</a> 用于编译源码。</p>
<blockquote>
<p>　　互联网上大多数开源框架和库，或者至少是那些想要保持IDE中性的开源框架和库（这意味着，使用任意一个集成开发环境配置并建立不依赖特定的集成开发环境就能够工作的一个项目），都使用CMake或类似的make系统。我猜想这也回答了某些问题，例如，我为什么需要CMake？为什么不能只给出库以及用它来做什么呢？或者其他类似的问题。这里，我们需要CMake以便能够使用源代码来配置和构建OpenCV。CMake是一个开源并跨平台的应用程序，可用于配置和构建开源项目（或者应用程序、库等等）。</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720204053.png"></p>
<br/>

<p>　　下载后好记得安装，安装CMake时除了应该确保安装GUI版本之外,还可以选择添加到环境变量里。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720212343.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720212434.png"></p>
<br/>

<h3 id="安装-Qt"><a href="#安装-Qt" class="headerlink" title="安装 Qt"></a>安装 <a href="https://www.lifeee.top/posts/20536.html">Qt</a></h3><p>　　安装好 Qt ,关于 Qt 的下载 以及 详细的安装步骤 可以看我的这篇博文 <a href="https://www.lifeee.top/posts/20536.html">Visual Studio 2019配置qt开发环境</a> 。选择编译组件的时候选择了 mingw_32 、mingw_64 以及 msvc2017_64  ，你也可以按需选择，本文只需用到 mingw 64 。</p>
<p>​      <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720205135.png"></p>
<p>　　 <a href="https://sourceforge.net/projects/mingw/">MinGW</a>  就不需要单独下载了，安装 Qt 的时候勾选上就好了。要手动下载的话可以在 <a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/</a> 下载最新版。</p>
<br/>

<br/>

<h2 id="编译前的准备–解压"><a href="#编译前的准备–解压" class="headerlink" title="编译前的准备–解压"></a>编译前的准备–解压</h2><p>　　将下载好的 OpenCV 3.4.11 解压，解压到英文、无中文、无特殊字符、无空格的路径下，避免不必要的麻烦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720205902.png"></p>
<p>　　<strong>opencv_contrib-3.4.11 是可选的</strong>。</p>
<p>　　在学习图像识别中的特征点检测和匹配时，需要用到一些常用的算法如FREAK、Surf和Sift算法等，但从OpenCV3以后，这些常用的算法OpenCV的Release版本中并不存在，因为他们是存放在opencv_contrib目录下面的未稳定功能模块，所以如果我们想要使用这些功能，需要自己下载代码并且自行编译。</p>
<p>　　解压 opencv_contrib-3.4.11 ，我的如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720211945.png"></p>
<p>　　为 MinGW-w64 配置环境变量，在 Qt 的安装目录下找到 MinGW-w64 的路径。我的路径为 <code>D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_64\bin</code> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720210535.png"></p>
<blockquote>
<p>　　打开“环境变量”设置界面方法一，在“我的电脑”上右击鼠标，在弹出菜单中选择“属性”。</p>
<p>在“系统”界面选择“高级系统设置”，接着点击环境变量。</p>
<p>子系统变量 Path 中增加一个条目即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720210920.png"></p>
<p>然后记得点三次确认。</p>
</blockquote>
<br/>

<br/>

<h2 id="CMake-构建"><a href="#CMake-构建" class="headerlink" title="CMake 构建"></a>CMake 构建</h2><blockquote>
<p> 　　CMake 是一个跨平台的自动化建构系统,它使用一个名为 CMakeLists.txt 的文件来描述构建过程,可以产生标准的构建文件,如 Unix                的 Makefile 或Windows Visual C++ 的 projects&#x2F;workspaces 。文件 CMakeLists.txt  需要手工编写,也可以通过编写脚本进行半自动的生成。CMake 提供了比 autoconfig 更简洁的语法。</p>
</blockquote>
<p>　　打开 CMake ，设置源代码路径 “Where is the source code folder”，编译目标文件的路径 “Where to build the binaries folder” 。在下图 ① 中选择源码路径，在 ② 中选择 编译结果路径，推荐在源码路径后加<code>/build</code> ,到时候会自动生成该目录。接着点击 ③ 左下角的【Configure】。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720215345439.png" alt="image-20200720215345439"></p>
<p>　　单击“Configure”按钮将启动配置过程。如果文件夹还不存在的话，可能会要求创建构建文件夹，需要通过单击“Yes”按钮来完成文件夹的创建。选择 YES  🏃🏻‍♂️</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720215647092.png" alt="image-20200720215647092"></p>
<p>　　按下图所示选择编译器。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720215757204.png" alt="image-20200720215757204"></p>
<p>　　配置C和C++编译器路径，具体路径请根据自己电脑中QT的安装目录而定。注意选择 64 位的哦，我的目录下文件名为 mingw730_64 的为64位。</p>
<p>　　我的 gcc 的路径在</p>
<p> <code>D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_64\bin\gcc.exe</code>  </p>
<p>　　 g++ 路径在</p>
<p> <code>D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_64\bin\c++.exe</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720220102.png" alt="20200720220102"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720220251581.png" alt="image-20200720220251581"></p>
<p>　　点击 Finish ，等待一会。红红的报错是常有的事，记得善用搜索引擎查找解决方案。</p>
<p>勾选上 <code>Grouped</code> 会分组显示配置信息。接着打开 OPENCV 组。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720220945.png" alt="20200720220945"></p>
<p>　　找到 <code>OPENCV_EXTRA_MODULES_PATH</code> 项，填入<code>opencv_contrib</code>目录下的<code>modules</code> 文件夹路径，我的为: <code>E:/20200325/DevelopmentEnvironment/opencv_contrib-3.4.11/modules</code>，如下图所示。<strong>记得使用 <code>/</code> 而不是 <code>\</code> 不然报错</strong>，见后文常见错误。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720230336.png"></p>
<p>　　展开 WITH 组。</p>
<p>　　勾选中“WITH_OPENGL”、“<strong>WITH_QT</strong>”，将“WITH_IPP”取消。并勾选 <code>ENABLE_CXX11</code></p>
<p>然后再次点【Configure】</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720221357979.png" alt="image-20200720221357979"></p>
<p>　　然后点击 左下角的【Configure】</p>
<p>　　然后继续修改Qt路径，要是你的没有安装过 Annoconda 一般不用改，我的安装过。</p>
<br/>

<div class="note info"><p>下面这里一定看清楚，红色部分的value值和你的安装位置对不对应。我笔记本里面有 Annoconda  里面也有cmake，所以我的默认是Annoconda  的位置，要手动改到 Qt 所在的位置。</p>
</div>

<br/>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721145912.png" alt="错误示例 更改前"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721150147.png" alt="应该是这下面的路径才对"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721150434.png" alt="正确示例 更改后"></p>
<p>　　然后点击 左下角的【Configure】，记得保持网络畅通。若还有红色，再一次configure，直到没有红色。</p>
<p>　　【Configure】一切顺利之后，执行 【Generate】。</p>
<p>很大可能性你会遇到编译错误，可参见后文的常见错误，若无法找到请 Google 错误日志，一般能找到解决方法。</p>
<p>在这个过程中，如果网络环境不好，很可能卡在<code>opencv_ffmpeg.dll</code>和<code>opencv_ffmpeg_64.dll</code>的下载中，建议更换好一点的网络环境，或者多等一会。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720233839776.png"></p>
<p>　　生成成功后需要去终端用命令行进行编译。</p>
<br/>

<br/>



<h2 id="编译-OpenCV"><a href="#编译-OpenCV" class="headerlink" title="编译 OpenCV"></a>编译 OpenCV</h2><p>　　打开终端，并且路径切换到上一步生成的路径，我的是： </p>
<p><code>E:\20200325\DevelopmentEnvironment\opencv3411\build</code></p>
<p>　　这里推荐的终端是 <a href="https://cmder.net/">cmder</a> ，很强大也很好用。当然也可以使用 <code>cmd</code> 或者 <code>Powershell</code>等。下面的命令行中先切换到路径下，然后使用 <code>mingw32-make -j 8</code> 进行编译 ，其中 <code>-j  8</code> 表示8个多线程，以加速编译，可根据硬件条件适当增减。当然可以使用默认的 <code>mingw32-make </code> 进行编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:</span><br><span class="line">cd E:\20200325\DevelopmentEnvironment\opencv3411\build</span><br><span class="line">mingw32-make -j 8</span><br><span class="line">mingw32-make install</span><br></pre></td></tr></table></figure>

<p>　　如果 <code>mingw32-make -j 8</code> 遇到错误，请看下文的  <strong>编译 OpenCV 常见错误</strong>，否则执行 <code>mingw32-make install</code>，完成安装。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721084902.png" alt="执行 mingw32-make -j 16"></p>
<p>　　遇到更多的错误不要慌张，见本文的后半部分看看有没有相似的错误或日志。假若你没有遇到 5个 以上的错误，那么我觉得你肯定是一个很幸运的人 🍦</p>
<br/>

<p>　　我所有的配置，贴出来：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721170744.png"></p>
<p>　　 mingw32-make 成功的界面 。 干杯 🍻</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721170724.png" alt="🍉"></p>
<p>　　mingw32-make install 成功的界面 🍰</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721171330498.png" alt="🍶"></p>
<p>　　生成成功后看一下 <code>build/bin</code> 下面的动态库 ，熟悉的味道，各种 OpenCV 的动态库。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721172331.png"></p>
<p>　　看一下 <code>build/lib</code> 目录</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721172746.png"></p>
<blockquote>
<p>dll.a 其实是MinGW下的DLL文件的imp-lib (Import Library)。</p>
<p>.dll.a文件的最初用意其实是MinGW下的DLL文件的imp-lib (Import Library)，即与VC下DLL文件附带了一个引入库.lib类似。在VC下编程，当要使用DLL文件时，在开发时必须要有.lib文件才能链接通过。.dll.a文件就是这样的作用。</p>
<p>但是，MinGW&#x2F;Cygwin确提供了直接与.dll文件链接的作用，就是可以不需要imp-lib库文件，只要DLL文件存在，也可以链接成功。这样就导致.dll.a文件似乎不是那么有用了。在很多场合下，可以不需要.dll.a文件了。但是有几个例外情况，来自于RedHat的官方描述。（<a href="http://www.inonit.com/cygwin/jni/invocationApi/archive.html">Reference</a>）</p>
<p>原文链接：<a href="https://blog.csdn.net/tangketan/article/details/6997699">https://blog.csdn.net/tangketan/article/details/6997699</a></p>
</blockquote>
<br/>

<br/>

<h2 id="编译-OpenCV-常见错误"><a href="#编译-OpenCV-常见错误" class="headerlink" title="编译 OpenCV 常见错误"></a>编译 OpenCV 常见错误</h2><h3 id="不明确的多线程错误"><a href="#不明确的多线程错误" class="headerlink" title="不明确的多线程错误"></a>不明确的多线程错误</h3><p>　　如果使用了多线程编译，导致错误，但是错误信息不明确，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  [ 82%] Built target opencv_ximgproc</span><br><span class="line">mingw32-make: *** [Makefile:181: all] Error 2</span><br></pre></td></tr></table></figure>

<p>　　解决方法是使用单线程编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<p>　　以查看详细的错误提示，再根据具体情况解决。</p>
<br/>

<h3 id="vs-version-rc-obj-处错误-gcc-error-long-No-such-file-or-directory"><a href="#vs-version-rc-obj-处错误-gcc-error-long-No-such-file-or-directory" class="headerlink" title="vs_version.rc.obj 处错误  gcc: error: long: No such file or directory"></a>vs_version.rc.obj 处错误  gcc: error: long: No such file or directory</h3><p>错误日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 29%] Building CXX object modules/core/CMakeFiles/opencv_core.dir/merge.avx2.cpp.obj</span><br><span class="line">[ 29%] Building CXX object modules/core/CMakeFiles/opencv_core.dir/split.avx2.cpp.obj</span><br><span class="line">[ 29%] Building CXX object modules/core/CMakeFiles/opencv_core.dir/sum.avx2.cpp.obj</span><br><span class="line">[ 29%] Building RC object modules/core/CMakeFiles/opencv_core.dir/vs_version.rc.obj</span><br><span class="line">gcc: error: long: No such file or directory</span><br><span class="line">D:\C++\Qt\Tools\mingw730_64\bin\windres.exe: preprocessing failed.</span><br><span class="line">mingw32-make[2]: *** [modules\core\CMakeFiles\opencv_core.dir\build.make:1508: modules/core/CMakeFiles/opencv_core.dir/vs_version.rc.obj] Error 1</span><br><span class="line">mingw32-make[2]: *** Waiting for unfinished jobs....</span><br><span class="line">mingw32-make[1]: *** [CMakeFiles\Makefile2:3687: modules/core/CMakeFiles/opencv_core.dir/all] Error 2</span><br><span class="line">mingw32-make: *** [Makefile:181: all] Error 2</span><br><span class="line"></span><br><span class="line">D:\Dev\OpenCV3411\opencv\sources\build&gt;D:\C++\Qt\Tools\mingw730_64\bin\windres.exe -O coff D:\Dev\OpenCV3411\opencv\sources\build\modules\core\vs_version.rc CMakeFiles\opencv_core.dir\vs_version.rc.obj</span><br><span class="line">D:\C++\Qt\Tools\mingw730_64\bin\windres.exe: CMakeFiles\opencv_core.dir\vs_version.rc.obj: No such file or directory</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721085554357.png" alt="image-20200721085554357"></p>
<p>　　根据错误日志，可发现在 <code>[modules\core\CMakeFiles\opencv_core.dir\build.make:1508: </code> 处出现错误。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721085950683.png" alt="image-20200721085950683"></p>
<p>打开</p>
<p><code>E:\20200325\DevelopmentEnvironment\opencv3411\build\modules\core\CMakeFiles\opencv_core.dir\build.make</code></p>
<p>的第1508行发现一个很长的命令行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /E E:\20200325\DevelopmentEnvironment\opencv3411\build\modules\core &amp;&amp; D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_32\bin\windres.exe -O coff $(RC_DEFINES) $(RC_INCLUDES) $(RC_FLAGS) E:\20200325\DevelopmentEnvironment\opencv3411\build\modules\core\vs_version.rc CMakeFiles\opencv_core.dir\vs_version.rc.obj</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可猜测错误原因是未成功生成vs_version.rc.obj。</p>
<p>　　根据<strong>build.make</strong>中的错误行，需要修改编译命令，手动生成vs_version.rc.obj，并重新mingw32-make，解决方法是手动生成一下。</p>
<p>进入到 <code>D:\Dev\OpenCV3411\opencv\sources\build\modules\core</code>  路径下，然后在终端运行下面的<strong>一句</strong>命令行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_32\bin\windres.exe -O coff  E:\20200325\DevelopmentEnvironment\opencv3411\build\modules\core\vs_version.rc CMakeFiles\opencv_core.dir\vs_version.rc.obj</span><br></pre></td></tr></table></figure>

<p>　　注意上面那句命令行省略了中间的<code>$(RC_DEFINES) $(RC_INCLUDES) $(RC_FLAGS)</code> 。要是没省略是执行不了的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721094418287.png" alt="输入命令行"></p>
<p>　　然后重新点击【Configure】和 【Generate】。</p>
<p>重新输入 <code>mingw32-make</code> 去编译，编译通过后 <code>mingw32-make install</code> 安装。</p>
<div class="note info"><p>提示：一定要查看自己的 build.make </p>
<p>每个人的路径都是不一样的</p>
</div>



<p><strong>出现上面这个原因还有可能是 windres.exe 的位数不同，看这个</strong> 👇🏻</p>
<h3 id="mingw730-32-bin-windres-exe-preprocessing-failed"><a href="#mingw730-32-bin-windres-exe-preprocessing-failed" class="headerlink" title="mingw730_32\bin\windres.exe: preprocessing failed."></a>mingw730_32\bin\windres.exe: preprocessing failed.</h3><p>日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 34%] Building RC object modules/core/CMakeFiles/opencv_core.dir/vs_version.rc.obj</span><br><span class="line">gcc: error: long: No such file or directory</span><br><span class="line">D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_32\bin\windres.exe: preprocessing failed.</span><br><span class="line">mingw32-make[2]: *** [modules\core\CMakeFiles\opencv_core.dir\build.make:1508: modules/core/CMakeFiles/opencv_core.dir/vs_version.rc.obj] Error 1</span><br><span class="line">mingw32-make[1]: *** [CMakeFiles\Makefile2:2239: modules/core/CMakeFiles/opencv_core.dir/all] Error 2</span><br><span class="line">mingw32-make: *** [Makefile:181: all] Error 2</span><br></pre></td></tr></table></figure>



<p>　　报错中怎么会是 mingw730_32&#x2F;bin&#x2F;windres.exe 呢？ 应该是64位的啊 ，因为我要编译64位的，那么就更改一下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721164200072.png" alt="更改前"></p>
<p>　　更改为 64 位的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:/20200213/ForDevelopment/Qt/Qt5.14.1/Tools/mingw730_64/bin/windres.exe</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721164757.png" alt="更改后"></p>
<p><code>mingw32-make.exe</code> 的路径也是32位，同样更改为64位。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721163719900.png" alt="更改前"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721165031061.png" alt="更改后"></p>
<p>　　重新【Configure】和 【Generate】。</p>
<p>　　重新输入 <code>mingw32-make</code> 去编译，编译通过后 <code>mingw32-make install</code> 安装。</p>
<br/>

<h3 id="Invalid-escape-sequence-2"><a href="#Invalid-escape-sequence-2" class="headerlink" title="Invalid escape sequence \2"></a>Invalid escape sequence \2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at cmake/OpenCVModule.cmake:369 (_glob_locations):</span><br><span class="line">  Syntax error in cmake code at</span><br><span class="line"></span><br><span class="line">    E:/20200325/DevelopmentEnvironment/opencv3411/cmake/OpenCVModule.cmake:369</span><br><span class="line"></span><br><span class="line">  when parsing string</span><br><span class="line"></span><br><span class="line">    E:\20200325\DevelopmentEnvironment\opencv_contrib-3.4.11\modules</span><br><span class="line"></span><br><span class="line">  Invalid escape sequence \2</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  modules/CMakeLists.txt:7 (ocv_glob_modules)</span><br></pre></td></tr></table></figure>



<p>　　该错误的原因是使用的路径有有 <code>\</code> ,解决方法是使用<code>/</code> 或者<code>\\</code>。请参见 <a href="https://stackoverflow.com/questions/13737370/cmake-error-invalid-escape-sequence-u">stackoverflow</a> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720225946.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200720230128.png"></p>
<p>　　然后重新点击【Configure】。</p>
<br/>

<h3 id="fatal-error-boostdesc-bgm-i-No-such-file-or-directory-include-“boostdesc-bgm-i”"><a href="#fatal-error-boostdesc-bgm-i-No-such-file-or-directory-include-“boostdesc-bgm-i”" class="headerlink" title="fatal error: boostdesc_bgm.i: No such file or directory #include “boostdesc_bgm.i”"></a>fatal error: boostdesc_bgm.i: No such file or directory #include “boostdesc_bgm.i”</h3><p>报错日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 85%] Building CXX object modules/videostab/CMakeFiles/opencv_test_videostab.dir/test/test_main.cpp.obj</span><br><span class="line">[ 85%] Building CXX object modules/videostab/CMakeFiles/opencv_test_videostab.dir/test/test_motion_estimation.cpp.obj</span><br><span class="line">[ 85%] Linking CXX executable ..\..\bin\opencv_test_videostab.exe</span><br><span class="line">[ 85%] Built target opencv_test_videostab</span><br><span class="line">[ 85%] Building CXX object modules/xfeatures2d/CMakeFiles/opencv_xfeatures2d.dir/src/boostdesc.cpp.obj</span><br><span class="line">D:\Dev\OpenCV3411\opencv_contrib-3.4.11\modules\xfeatures2d\src\boostdesc.cpp:654:20: fatal error: boostdesc_bgm.i: No such file or directory</span><br><span class="line">           #include &quot;boostdesc_bgm.i&quot;</span><br><span class="line">                    ^~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">mingw32-make[2]: *** [modules\xfeatures2d\CMakeFiles\opencv_xfeatures2d.dir\build.make:101: modules/xfeatures2d/CMakeFiles/opencv_xfeatures2d.dir/src/boostdesc.cpp.obj] Error 1</span><br><span class="line">mingw32-make[1]: *** [CMakeFiles\Makefile2:6302: modules/xfeatures2d/CMakeFiles/opencv_xfeatures2d.dir/all] Error 2</span><br><span class="line">mingw32-make: *** [Makefile:181: all] Error 2</span><br></pre></td></tr></table></figure>

<p>　　原因是某些文件没有从github下载下来，解决方法就是手动下载放到对应的路径中。可以查看 <strong>build</strong> 文件夹下的日志文件 <strong>CMakeDownloadLog.txt</strong>，在<strong>日志文件CMakeDownloadLog.txt</strong>中搜索 <strong>boostdesc_bgm.i</strong> 关键词 ，可以发现错误的原因是<br> 发现文件下载失败了。</p>
<p>　　解决方法可以 在 github issue 中看到 <a href="https://github.com/opencv/opencv_contrib/issues/1301">fatal error: boostdesc_bgm.i: No such file or directory  #1301</a></p>
<p>下载缺失的文件  放在  <strong>opencv_contrib&#x2F;modules&#x2F;xfeatures2d&#x2F;src&#x2F;</strong> 路径下即可。</p>
<p>总共缺了以下几个文件，都需要拷贝：</p>
<pre><code>boostdesc_bgm.i
boostdesc_bgm_bi.i
boostdesc_bgm_hd.i
boostdesc_lbgm.i
boostdesc_binboost_064.i
boostdesc_binboost_128.i
boostdesc_binboost_256.i
vgg_generated_120.i
vgg_generated_64.i
vgg_generated_80.i
vgg_generated_48.i
</code></pre>
<p>　　各个文件的下载路径为：</p>
<p> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_lbgm.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_lbgm.i (raw)</a><br> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_binboost_256.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_binboost_256.i (raw)</a><br>  <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_binboost_128.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_binboost_128.i (raw)</a><br> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_binboost_064.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_binboost_064.i (raw)</a><br> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_bgm_hd.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_bgm_hd.i (raw)</a>  <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_bgm_bi.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_bgm_bi.i (raw)</a>  <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/34e4206aef44d50e6bbcd0ab06354b52e7466d26/boostdesc_bgm.i">opencv&#x2F;opencv_3rdparty@<code>34e4206</code>&#x2F;boostdesc_bgm.i (raw)</a> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/fccf7cd6a4b12079f73bbfb21745f9babcd4eb1d/vgg_generated_120.i">opencv&#x2F;opencv_3rdparty@<code>fccf7cd</code>&#x2F;vgg_generated_120.i (raw)</a><br> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/fccf7cd6a4b12079f73bbfb21745f9babcd4eb1d/vgg_generated_64.i">opencv&#x2F;opencv_3rdparty@<code>fccf7cd</code>&#x2F;vgg_generated_64.i (raw)</a>  <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/fccf7cd6a4b12079f73bbfb21745f9babcd4eb1d/vgg_generated_48.i">opencv&#x2F;opencv_3rdparty@<code>fccf7cd</code>&#x2F;vgg_generated_48.i (raw)</a><br> <a href="https://raw.githubusercontent.com/opencv/opencv_3rdparty/fccf7cd6a4b12079f73bbfb21745f9babcd4eb1d/vgg_generated_80.i">opencv&#x2F;opencv_3rdparty@<code>fccf7cd</code>&#x2F;vgg_generated_80.i (raw)</a> </p>
<p>　　也可以在终端中一键下载 ,记得先进入对应的路径，然后输入 curl 后面那些命令行。😁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd E:/20200325/DevelopmentEnvironment/opencv3411/.cache/xfeatures2d</span><br><span class="line">cd boostdesc</span><br><span class="line"></span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_lbgm.i (raw) &gt; 0ae0675534aa318d9668f2a179c2a052-boostdesc_lbgm.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_binboost_256.i (raw) &gt; e6dcfa9f647779eb1ce446a8d759b6ea-boostdesc_binboost_256.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_binboost_128.i (raw) &gt; 98ea99d399965c03d555cef3ea502a0b-boostdesc_binboost_128.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_binboost_064.i (raw) &gt; 202e1b3e9fec871b04da31f7f016679f-boostdesc_binboost_064.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_bgm_hd.i (raw) &gt; 324426a24fa56ad9c5b8e3e0b3e5303e-boostdesc_bgm_hd.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_bgm_bi.i (raw) &gt; 232c966b13651bd0e46a1497b0852191-boostdesc_bgm_bi.i</span><br><span class="line">curl opencv/opencv_3rdparty@34e4206/boostdesc_bgm.i (raw) &gt; 0ea90e7a8f3f7876d450e4149c97c74f-boostdesc_bgm.i</span><br><span class="line">cd ../vgg</span><br><span class="line">curl opencv/opencv_3rdparty@fccf7cd/vgg_generated_120.i (raw) &gt; 151805e03568c9f490a5e3a872777b75-vgg_generated_120.i</span><br><span class="line">curl opencv/opencv_3rdparty@fccf7cd/vgg_generated_64.i (raw) &gt; 7126a5d9a8884ebca5aea5d63d677225-vgg_generated_64.i</span><br><span class="line">curl opencv/opencv_3rdparty@fccf7cd/vgg_generated_48.i (raw) &gt; e8d0dcd54d1bcfdc29203d011a797179-vgg_generated_48.i</span><br><span class="line">curl opencv/opencv_3rdparty@fccf7cd/vgg_generated_80.i (raw) &gt; 7cd47228edec52b6d82f46511af325c5-vgg_generated_80.i</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>　　下载好后在 CMake 中<strong>重新生成</strong>，然后继续编译。记得重新生成。</p>
<blockquote>
<p>in the end, your opencv&#x2F;.cache should look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.cache</span><br><span class="line">│</span><br><span class="line">└───xfeatures2d</span><br><span class="line"> ├───boostdesc</span><br><span class="line"> │       0ae0675534aa318d9668f2a179c2a052-boostdesc_lbgm.i</span><br><span class="line"> │       0ea90e7a8f3f7876d450e4149c97c74f-boostdesc_bgm.i</span><br><span class="line"> │       202e1b3e9fec871b04da31f7f016679f-boostdesc_binboost_064.i</span><br><span class="line"> │       232c966b13651bd0e46a1497b0852191-boostdesc_bgm_bi.i</span><br><span class="line"> │       324426a24fa56ad9c5b8e3e0b3e5303e-boostdesc_bgm_hd.i</span><br><span class="line"> │       98ea99d399965c03d555cef3ea502a0b-boostdesc_binboost_128.i</span><br><span class="line"> │       e6dcfa9f647779eb1ce446a8d759b6ea-boostdesc_binboost_256.i</span><br><span class="line"> │</span><br><span class="line"> └───vgg</span><br><span class="line">         151805e03568c9f490a5e3a872777b75-vgg_generated_120.i</span><br><span class="line">         7126a5d9a8884ebca5aea5d63d677225-vgg_generated_64.i</span><br><span class="line">         7cd47228edec52b6d82f46511af325c5-vgg_generated_80.i</span><br><span class="line">         e8d0dcd54d1bcfdc29203d011a797179-vgg_generated_48.i</span><br><span class="line">         </span><br><span class="line">https://github.com/opencv/opencv_contrib/issues/1301</span><br></pre></td></tr></table></figure>
</blockquote>
<p>　　其实下载失败一般是你的网络原因或者 hosts 的原因 ，我的就很正常，哈哈。自动下载。可以 <a href="https://www.lifeee.top/posts/32023.html">更改hosts加速访问Github</a>  试试看，不然可能很多 github release 的文件你应该也下载不了。      </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200720232843831.png"></p>
<br/>

<h3 id="CMake-Warning-at-cmake-OpenCVDownload-cmake-202-message-FFMPEG-Download-failed-28-”Timeout-was-reached”"><a href="#CMake-Warning-at-cmake-OpenCVDownload-cmake-202-message-FFMPEG-Download-failed-28-”Timeout-was-reached”" class="headerlink" title="CMake Warning at cmake&#x2F;OpenCVDownload.cmake:202 (message): FFMPEG: Download failed: 28;”Timeout was reached”"></a>CMake Warning at cmake&#x2F;OpenCVDownload.cmake:202 (message): FFMPEG: Download failed: 28;”Timeout was reached”</h3><p>错误日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Warning at cmake/OpenCVDownload.cmake:202 (message):</span><br><span class="line">  FFMPEG: Download failed: 28;&quot;Timeout was reached&quot;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFMPEG: Download: opencv_videoio_ffmpeg_64.dll Try 1 failed CMake</span><br><span class="line">Warning at cmake/OpenCVDownload.cmake:202 (message): FFMPEG:</span><br><span class="line">Download failed: 35;“SSL connect error”</span><br></pre></td></tr></table></figure>

<p>　　以上错误 的原因均是 <code>opencv_videoio_ffmpeg.dll</code> 和 <code>opencv_videoio_ffmpeg_64.dll</code>下载失败导致。</p>
<p>查看 <code>E:\20200325\DevelopmentEnvironment\opencv3411\.cache\ffmpeg</code> 路径下的缓存，文件并未下载完成</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721100208850.png"></p>
<p>　　建议换个网络环境（比如 科学上网），重新生成一下看看能不能下载成功。若还是不能的话只能手动下载了。</p>
<p>只需要下载对应的对应的 opencv_ffmpeg.dll 和 opencv_ffmpeg_64.dll即可，文件名前面的16进制前缀，为对应文件的md5值。</p>
<p>手动下载的方法 请看这几个链接：</p>
<p><a href="https://github.com/opencv/opencv/issues/5546">https://github.com/opencv/opencv/issues/5546</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721101640012.png"></p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/32932915/opencv-3-0-0-configure-fails-ffmpeg-not-downloaded">https://stackoverflow.com/questions/32932915/opencv-3-0-0-configure-fails-ffmpeg-not-downloaded</a></p>
<p><a href="https://github.com/opencv/opencv_3rdparty/tree/ffmpeg/master_20150703/ffmpeg">https://github.com/opencv/opencv_3rdparty&#x2F;tree&#x2F;ffmpeg&#x2F;master_20150703&#x2F;ffmpeg</a></p>
</blockquote>
<p>在 <a href="https://stackoverflow.com/questions/32932915/opencv-3-0-0-configure-fails-ffmpeg-not-downloaded">https://stackoverflow.com/questions/32932915/opencv-3-0-0-configure-fails-ffmpeg-not-downloaded</a> 下载下图 中的两个文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721102242557.png"></p>
<p>　　下载对应的 opencv_ffmpeg.dll 和 opencv_ffmpeg_64.dll即可，然后需要查看为对应文件的md5值。</p>
<blockquote>
<p><strong>windows下查看文件md5</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 文件路径 MD5</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721102828601.png"></p>
<p>我的 opencv_ffmpeg.dll 是 <code>f081abd9d6ca7e425d340ce586f9c090</code></p>
<p> opencv_ffmpeg_64.dll 是 <code>35fe6ccdda6d7a04e9056b0d73b98e76</code></p>
<p>拷贝下载好的文件放到</p>
<p> <code>E:\20200325\DevelopmentEnvironment\opencv3411\.cache\ffmpeg</code> </p>
<p>然后重命名为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f081abd9d6ca7e425d340ce586f9c090-opencv_ffmpeg.dll</span><br><span class="line">35fe6ccdda6d7a04e9056b0d73b98e76-opencv_ffmpeg_64.dll</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721103805182.png"></p>
<p>　　不然编译的时候不一致又会重新下载了。</p>
<p>　　仅仅把下载的文件放在缓冲区中是不够的，因为自己下载的MD5有可能和源码中指定的MD5不一致，从而导致编译后，依旧无法下载指定是的文件，同样无法编译！所以修改源码中指定的MD5。<br>打开文件 <code>opencv\sources\3rdparty\ffmpeg\ffmpeg.cmake</code><br>把如下两项对应的值，修改成以上文件的MD5，分别对应32位和64位的dll</p>
<table>
<thead>
<tr>
<th></th>
<th>ocv_update(FFMPEG_FILE_HASH_BIN32 “f081abd9d6ca7e425d340ce586f9c090”)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ocv_update(FFMPEG_FILE_HASH_BIN64 “35fe6ccdda6d7a04e9056b0d73b98e76”)</td>
</tr>
</tbody></table>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721103853226.png"></p>
<p>然后重新编译。</p>
<br/>

<h3 id="data-Download-face-landmark-model-dat"><a href="#data-Download-face-landmark-model-dat" class="headerlink" title="data: Download: face_landmark_model.dat"></a>data: Download: face_landmark_model.dat</h3><p>　　要是在生成中停留在下面这个界面比较久，是因为国内下载慢的原因。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200721121509265.png"></p>
<p>　　所以可手动下载好，然后放到指定目录下。首先这个文件下载地址为 <a href="https://github.com/opencv/opencv_3rdparty/blob/contrib_face_alignment_20170818/face_landmark_model.dat">https://github.com/opencv/opencv_3rdparty&#x2F;blob&#x2F;contrib_face_alignment_20170818&#x2F;face_landmark_model.dat</a>，</p>
<p>　　手动下载好之后，找到</p>
<p><code>E:\20200325\DevelopmentEnvironment\opencv_contrib-3.4.11\modules\face\CMakeLists.txt</code></p>
<p>打开。 找到其中以<code>https://raw”</code>开头的一串网址，如下图所示：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721143013.png"></p>
<p>　　将其替换成本地文件路径，如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721143108.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200721143233.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://wiki.qt.io/How_to_setup_Qt_and_openCV_on_Windows">How to setup Qt and openCV on Windows</a></p>
<p><a href="https://www.lifeee.top/posts/20536.html">Visual Studio 2019配置qt开发环境</a></p>
<p><a href="https://www.lifeee.top/posts/32023.html">更改hosts加速访问Github</a></p>
<p><a href="https://blog.huihut.com/2018/07/31/CompiledOpenCVWithMinGW64/">OpenCV使用CMake和MinGW-w64的编译安装</a></p>
<p><a href="https://www.cnblogs.com/ezrealiu/p/install-opencv-4-on-your-raspberry-pi-4.html">Install OpenCV 4 on your Raspberry Pi4</a></p>
<p><a href="https://sunjiadai.xyz/blog/2019/02/16/OpenCV-QT%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">OpenCV-QT项目开发记录</a></p>
<p><a href="https://github.com/opencv/opencv_contrib/issues/1301">fatal error: boostdesc_bgm.i: No such file or directory  #1301</a></p>
<p><a href="https://github.com/opencv/opencv/issues/11655">Windows 10 CMake | OPENCV_EXTRA_MODULES_PATH | Bug #11655</a></p>
<p><a href="https://github.com/opencv/opencv/issues/5546">OpenCV 3.0.0 “configure” fails - ffmpeg download error   #5546</a></p>
<p><a href="https://stackoverflow.com/questions/32932915/opencv-3-0-0-configure-fails-ffmpeg-not-downloaded">OpenCV 3.0.0 “configure” fails, ffmpeg not downloaded</a></p>
<p><a href="https://github.com/opencv/opencv_3rdparty/tree/ffmpeg/master_20150703/ffmpeg">https://github.com/opencv/opencv_3rdparty&#x2F;tree&#x2F;ffmpeg&#x2F;master_20150703&#x2F;ffmpeg</a></p>
<p><a href="https://github.com/opencv/opencv_3rdparty/tree/contrib_face_alignment_20170818">https://github.com/opencv/opencv_3rdparty&#x2F;tree&#x2F;contrib_face_alignment_20170818</a></p>
<p><a href="https://blog.csdn.net/weixin_44381193/article/details/106103417">Windows 10使用Qt配置OpenCV时出现的一些编译错误小记</a></p>
<p><a href="https://www.codenong.com/js3c4b1af3837f/">学习OpenCV3：MinGW编译OpenCV到vs_version.rc.obj处出错</a></p>
<p><a href="http://zhaoxuhui.top/blog/2019/06/04/OpenCVContribEnvCPP.html">再谈OpenCV Contrib编译与安装</a></p>
<p><a href="https://stackoverflow.com/questions/13737370/cmake-error-invalid-escape-sequence-u">Cmake error: Invalid escape sequence \U</a></p>
<p><a href="https://answers.opencv.org/question/168538/building-opencv-with-mingw-gcc-710-and-cmake-390-windresexe-unknown-option-w/">Building OpenCV with MinGW (gcc 7.1.0 and cmake 3.9.0)-&gt; windres.exe:  unknown option – W</a></p>
</blockquote>
<br/>



 

<br />



 
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>教程</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>数字笔记之OneNote</title>
    <url>/posts/63757.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/2-1___OneNote_Alternative.png"></p>
<p>　　近些年来 数字化生活方式 已经出现在我们生活中的方方面面，笔记同样如此。曾经我们都习惯于纸质笔记，无论是日记亦或是上课的笔记都会选择记录在纸质的笔记本里。随着时间的推移，可能字迹褪去了原本的颜色，甚至根本不知道丢哪里去了，珍贵的笔记丢失总是像流逝的时光一般让人忧郁惆怅。一种解决方式是使用扫描软件扫描我们的纸质笔记本进行存储。而另一种思路是 我们为什么不直接使用数字笔记呢 ？ 因此，近些年来数字笔记兴起了。OneNote、Evernote、有道云笔记、Notion 等等笔记进入了我们的生活。今天介绍的是微软出品的 OneNote ，它熟悉的界面和高度的Microsoft  Office 集成可能会让你信服。</p>
<span id="more"></span>



<br/>

<h2 id="什么是-OneNote？"><a href="#什么是-OneNote？" class="headerlink" title="什么是 OneNote？"></a>什么是 OneNote？</h2><p>　　OneNote 是一款由微软开发的数字笔记本。OneNote是全平台覆盖的，包括 Windows PC，Mac，iPhone，Android。OneNote 笔记本可以与同事共享，以进行实时协作。</p>
<br/>

<h2 id="下载-OneNote"><a href="#下载-OneNote" class="headerlink" title="下载 OneNote"></a>下载 OneNote</h2><p><a href="https://www.onenote.com/download?omkt=zh-CN">https://www.onenote.com/download?omkt=zh-CN</a></p>
<p>根据自己的操作系统平台选择。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghst41m2uyj21ba0ogwj2.jpg" alt="image"></p>
<p>　　另外简单说一下 UWP版本与 OneNote2016 版本的区别。</p>
<p>UWP版本功能较少一些，启动也会快一些。支持安装的插件少。不过在上面用数位板做笔记体验还是可以的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghst7c52wfj21i00uowjn.jpg" alt="image"></p>
<p>　　OneNote2016 则功能丰富，支持安装插件来增强一些功能。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghswwjzfptj214906bdh2.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghswx6u25oj214906b3zz.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghswxvo0j0j21490tmqaw.jpg"></p>
<br/>

<h2 id="创建笔记本"><a href="#创建笔记本" class="headerlink" title="创建笔记本"></a>创建笔记本</h2><p>　　组织内容的主要方式是通过笔记本。我们可以拥有任意多的笔记本。可以像对待传统的纸质笔记本一样对待它们。你可能会有一个专门用来处理家务事，一个用来记录你的工作，一个用来保存你的旅行计划和其他重要文件，等等。 要创建一个新的笔记本，点击文件 &gt; 新建。您可以选择在哪里创建它——是在本地计算机上还是在 OneDrive 上。这一点很重要: 如果你选择在本地电脑上制作笔记本，你将无法从其他设备访问它。使用 OneDrive 是更好的选择。给这个笔记本起个名字，然后点击 Create。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200808231100359.png" alt="image-20200808231100359"></p>
<p>　　新的笔记本会显示在屏幕左边的栏目中。</p>
<p><strong>分区组与分区</strong></p>
<p>　　当您首次创建一个新笔记本时，OneNote 会创建一个名为“ New Section 1”的默认节。通过双击它，重命名为你想要的名字。</p>
<p>　　分区组与分区同样是可以在笔记本中创建很多个的。右击就可以创建，可以多个层次嵌套。也可以拖拽来移动某个分区组或者分区。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200808232551560.png"></p>
<p><strong>页</strong></p>
<p>　　页可以理解为纸质笔记本的页，添加方法是单击现有部分右侧的 + 图标。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200808233223711.png"></p>
<p>　　要缩进页的话，可以右击想要缩进的页，点击 降级子页即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200808233323233.png"></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="OneNote-Web-Clipper"><a href="#OneNote-Web-Clipper" class="headerlink" title="OneNote Web Clipper"></a>OneNote Web Clipper</h3><p>　　在浏览器的拓展中心即可搜索到该拓展。</p>
<p>　　快速将任何网页捕获到OneNote，在这里你可以轻松编辑网页、添加注释或共享网页。剪辑完整的页面，或仅剪辑你真正需要的文章、食谱或产品信息。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsxe4vhv9j21g10phk7r.jpg"></p>
<h3 id="OneCalendar"><a href="#OneCalendar" class="headerlink" title="OneCalendar"></a>OneCalendar</h3><p>下载：<a href="https://getonetastic.com/download">https://getonetastic.com/download</a></p>
<p>　　OneCalendar是一款日历视图插件，你可以以日历的方式去查询之前所做的笔记，看上去是不是和我们的日历待办事项非常的像啊，而且还可以通过点击标题进行快速查询和编辑相应的笔记。如果我们的笔记较多，我们还可以通过按“星期” “日期” 来查询。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200816203427573.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsxj0h05wj21480lgjty.jpg"></p>
<h3 id="Onetastic"><a href="#Onetastic" class="headerlink" title="Onetastic"></a>Onetastic</h3><p>下载地址： <a href="https://getonetastic.com/">https://getonetastic.com/</a></p>
<p>Onestastic是为微软Onenote所打造的多功能加载项。</p>
<ul>
<li><p>他在Macroland提供数百个可用的宏（Macro）；</p>
</li>
<li><p>OneCalender为用户提供Onenote编辑日历（或者说日志），方便你回溯每一天你都在做些什么；</p>
</li>
<li><p>图像裁剪&#x2F;旋转，这些在传统office应用（说的就是word&#x2F;PPT）中自带的基本功能，而在Onenote中却不包含，问题不大，Onestastic可以解决；</p>
</li>
<li><p>收藏夹功能、笔记本&#x2F;分区&#x2F;页面，这些shortcut功能以快捷方式的形式提供给你最便捷的到达现有任务的通道</p>
</li>
<li><p>自定义的文本样式，类似于word中的一级二级标题，让常用的格式使用更简单</p>
</li>
</ul>
<p>　　宏可用于执行简单的重复任务。其思想类似于其他 Office 应用程序中的宏。</p>
<p>　　Macroland是下载宏的地方。点击这里开始下载宏。使用宏编辑器，您可以检查这些宏，使用它们并修改它们，然后开始构建自己的宏。还可以轻松地与其他用户共享您构建的宏。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsxq6batfj20lv05gq39.jpg"></p>
<p>　　我安装的宏有这么多，见下图。对宏中的一些内容我们也可以自己修改。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsxw3lhxrj21ci0q9q6e.jpg"></p>
<h3 id="NoteHighlight"><a href="#NoteHighlight" class="headerlink" title="NoteHighlight"></a>NoteHighlight</h3><p>　　对于 Office 64位使用 NoteHighlight2016.msi，对于 office32位使用 NoteHighlight2016x86.msi。下载地址为：</p>
<p><a href="https://github.com/elvirbrk/NoteHighlight2016/releases">https://github.com/elvirbrk/NoteHighlight2016/releases</a></p>
<p>　　其用法很简单，可以参见 项目在 github 中的<a href="https://github.com/elvirbrk/NoteHighlight2016#usage">说明</a>。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsy2f2qojj21490unq7z.jpg"></p>
<h3 id="数字笔记珍宝插件-OneNoteGem"><a href="#数字笔记珍宝插件-OneNoteGem" class="headerlink" title="数字笔记珍宝插件 OneNoteGem"></a>数字笔记珍宝插件 OneNoteGem</h3><p>　　数字笔记珍宝插件的功能丰富十分丰富，不过很多功能需要付费，我已经卸载了，其下载地址为 <a href="http://cn.onenotegem.com/">http://cn.onenotegem.com/</a> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20200816202435524.png"></p>
<p>　　插件的价格如下，个人觉得价格偏高。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1ghsxb9khh3j20ox1muae7.jpg" style="zoom:67%;" />





<h3 id="故障现象：插件不出现"><a href="#故障现象：插件不出现" class="headerlink" title="故障现象：插件不出现"></a>故障现象：插件不出现</h3><blockquote>
<p>当你安装完插件后，发现OneNote界面还和原来一样，没有插件出现，重启软件后也一样；点击文件-选项-加载项，发现刚安装的插件在“非活动应用程序加载项”。</p>
<p>点击文件-选项-加载项–转到…勾选插件-确定，重启软件。</p>
<p><a href="https://www.office26.com/onenote/onenote-add-in.html">https://www.office26.com/onenote/onenote-add-in.html</a></p>
</blockquote>
<br/>

<h2 id="OneNote-UWP-靓丽女声"><a href="#OneNote-UWP-靓丽女声" class="headerlink" title="OneNote UWP 靓丽女声"></a>OneNote UWP 靓丽女声</h2><p>　　进入沉浸式阅读模式，朗读的声音和 Microsoft Edge 上的 xiaoxiao 一样，宛若真人朗读。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916142143508.png" alt="image-20200916142143508"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916142100904.png" alt="image-20200916142100904"></p>
<h2 id="OneNote的默认字体"><a href="#OneNote的默认字体" class="headerlink" title="OneNote的默认字体"></a>OneNote的默认字体</h2><p>　　默认的11真的有时候太小了，更改方法为 文件-&gt; 选项-&gt; 字体&#x2F;字号 。我更改的为16号方正萤雪简体，看起来比较舒适。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916143407554.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916143718222.png"></p>
<br/>



<h2 id="OneNote-数位板"><a href="#OneNote-数位板" class="headerlink" title="OneNote + 数位板"></a>OneNote + 数位板</h2><p>　　OneNote 对数位板兼容的很好，目前很多其它电子笔记似乎对数位板要么不支持，要么不友好。OneNote + 数位板的话可以涂涂画画，阅读文献或者手写笔记都是不错的选择呢，推荐购买制霸全球的 wacom 数位板。</p>
<blockquote>
<p>数位板必须要贴膜吗</p>
<p>贴膜就是图个安心，其实板子没有那么脆弱啦，倒是贴上了以后，膜很容易被画出印子你还得换没完没了地换膜，比如 wacom  制霸全球的本领就是无人可及的电磁感压技术，还是不要贴膜了吧。这岂不是相当于给自己整了一个体验打折扣的商品。打仗哪有不伤人的，同理这东西是生产工具，刮花就刮花，不让它全力发挥的干活对它来讲才是白在世上走一回。</p>
<p><a href="https://zhidao.baidu.com/question/648260775815706445.html">百度知道</a></p>
</blockquote>
<br/>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>​	<strong>数字笔记锚 Anchor to OneNote</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/anchor-to-onenote/2019/1112/39.html">在 OneNote 中创建 PDF 文件锚，并导出锚的缩略图</a></li>
</ul>
<p><strong>笔记自动完成工具 Auto OneNote</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/46.html">自动设置 OneNote 页面的中西，中英文为不同的字体</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/45.html">自动修改 OneNote 页面里英文 Calibri      字体为默认中文字体问题</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/44.html">创建 OneNote 标记摘要页, 同时自动刷新标记摘要</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/43.html">监视一个 Windows      文件夹，自动保存并刷新文件列表到一个 OneNote 页面里</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/42.html">创建 OneNote      两个页面，分别自动实时列表未完成的和已完成的待办事项</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/41.html">自动同步刷新外部的 Excel (.xlsx) 文件内容到      OneNote 表格里</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/auto-onenote/2019/1112/40.html">自动持续同步一个文本文件 .txt 的内容到 OneNote</a></li>
</ul>
<p><strong>添加到数字笔记 Bring to OneNote</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/bring-to-onenote/2020/0105/726.html">如何在 Chrome 开发者模式下，安装 Bring to      OneNote for Chrome 插件？</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/bring-to-onenote/2019/1214/714.html">安装多个版本的 OneNote 时,如何设置默认的      OneNote 程序</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/bring-to-onenote/2019/1112/49.html">发送至 ( Send to ) OneNote 修复工具</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/bring-to-onenote/2019/1112/48.html">转换 PDF 为图片并保存到 OneNote 中</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/bring-to-onenote/2019/1112/47.html">修改设置 OneNote 屏幕截图快捷键工具</a></li>
</ul>
<p><strong>精摘板 CiteBoard for OneNote</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/citeboard/2019/1112/50.html">转换剪贴板里 HTML 链接为纯文本链接</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/clip-to-onenote/2020/clip-to-onenote-for-mac-safari.html">Mac Safari 浏览器的 OneNote 网页裁剪插件      – 剪辑到数字笔记</a></li>
</ul>
<p><strong>收藏到数字笔记 Favorite to OneNote</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/favorite-to-onenote/2019/1112/52.html">如何保存网页到 OneNote，使其保持排版不混乱</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/favorite-to-onenote/2019/1112/51.html">如何在 OneNote 中保存并查看动态 GIF 图片</a></li>
</ul>
<p><strong>Fix One</strong></p>
<ul>
<li><a href="http://cn.onenotegem.com/a/documents/fix-one/2019/1115/704.html">EXE: 如何检查 OneNote.exe 是哪一个版本？</a></li>
<li><a href="http://cn.onenotegem.com/a/documents/fix-one/2019/1115/703.html">如何修复“OneNote 正在清理上次打开之后的内容”？</a></li>
</ul>
<br/>

<h2 id="值得一看的文章"><a href="#值得一看的文章" class="headerlink" title="值得一看的文章"></a>值得一看的文章</h2><p><a href="https://www.office26.com/onenote/">https://www.office26.com/onenote/</a></p>
<p>里面有很多小技巧</p>
<p><a href="https://mp.weixin.qq.com/s/DowcyNtuyME-JC24i_6eSA">【干货】用OneNote数字化家居管理，有效收纳</a></p>
<p><a href="https://mp.weixin.qq.com/s/0jVQOaGvn0iBxOQJpaWrsQ">【模板】用OneNote管理密码&#x2F;密码管理模板</a></p>
<p><a href="https://mp.weixin.qq.com/s/u0tSJdNz3Tjc4-OxijAETg">【资讯】近期安卓版OneNote的4项大更新</a></p>
<p><a href="https://mp.weixin.qq.com/s/rwjhIqqxrVVm-wYK21zbbQ">【干货】快速输入项目符号与数字编号</a></p>
<p><a href="https://mp.weixin.qq.com/s/vrF_GwD--wwwhpFi0IGs9Q">【教程】彩色笔记：分区颜色的正确使用方式</a></p>
<p><a href="https://mp.weixin.qq.com/s/Ii0966l3Tj9BTvyZ3AouJA">【FAQ】找回丢失的笔记</a></p>
<p><a href="https://mp.weixin.qq.com/s/_kCNPxioNLhnbE-NTkPbtA">用OneNote管理纸质文档</a></p>
<p><a href="https://mp.weixin.qq.com/s/cG6nltmp7MqIoya-fb5-EQ">【教程】OneNote模板使用基础</a></p>
<p><a href="https://mp.weixin.qq.com/s/bDWBs_Yg12CiTCVhxrfrOQ">【模板】OneNote时间管理四象限法模板</a></p>
<p><a href="https://mp.weixin.qq.com/s/2kTsqAcA_KJ-cvent2AAug">【教程】渐变色清单&#x2F;待办事项</a></p>
<p><a href="https://mp.weixin.qq.com/s/9gLoenUMA2YOLmnTLotthg">【资源】Win10微软表情大全字符版非图片</a></p>
<p><a href="https://mp.weixin.qq.com/s/3W3Gwh_QP_YZNs03jn3snQ">【模板】OneNote身体健康系列模板分享</a></p>
<p><a href="https://mp.weixin.qq.com/s/EfwbGgrQPI12prVSbdbFSA">【插件】给OneNote添加替换功能</a></p>
<p><a href="https://mp.weixin.qq.com/s/3WA9m8oBkt_vjK8jLy_ROQ">【插件】OneNote神器插件-Onetastic</a></p>
<p><a href="https://mp.weixin.qq.com/s/aaW38mYDqGn4c4hPsrSdMw">打造属于自己的OneNote选项卡提高效率</a></p>
<p><a href="https://mp.weixin.qq.com/s/TVWQ0VDHSPlNoANpQgG_gg">【干货】OneNote容器的妙用</a></p>
<p><a href="https://mp.weixin.qq.com/s/aS2V4-9bA55HAVtrDn7vzw">【资讯】OneNote2016推送新图标</a></p>
<p><a href="https://mp.weixin.qq.com/s/gliRxAUCtXjAG1o8lsHlWw">【折腾】在手机上使用OneNote平板模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/g3RjGgGhbsZap7XWpHNtzg">【折腾】OneNote的折叠展开按钮（非普通手柄图标）</a></p>
<p><a href="https://mp.weixin.qq.com/s/0N5grgiLDak65mFdN0s4ag">【好软分享】免费开源满足所有截图需求</a></p>
<p><a href="https://mp.weixin.qq.com/s/zmPSRSVl9nMkPJLIKU463Q">OneNote官方网页剪辑工具</a></p>
<p><a href="https://mp.weixin.qq.com/s/wQhM6XD1sRngFbwgFq6M4Q">【干货】自定义OneNote标签实现快速检索</a></p>
<p><a href="https://mp.weixin.qq.com/s/QQKUnjzJie2IZvR5Ihd-LQ">【资讯】OneNote安卓新增深色模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/8oTSDrd-_6rJeY2EUU-ZQw">【折腾】OneNote 21天可视化打卡模板</a></p>
<p><a href="https://mp.weixin.qq.com/s/wp66Dq0ooo4Z_gbF1Cst0Q">【干货】OneNote备份&#x2F;还原&#x2F;迁移</a></p>
<p><a href="https://mp.weixin.qq.com/s/odawDW-1-RtDoajnACvX0A">【OneNote模板分享】习惯养成行动模板</a></p>
<p><a href="https://mp.weixin.qq.com/s/ZWT36Al8KrvPlwGG_r7DLg">【折腾】OneNote合并单元格的研究</a></p>
<p><a href="https://mp.weixin.qq.com/s/lxhXgwL3MEMaooyiORwJQw">【好软分享】 给OneNote配个扫描仪</a></p>
<p><a href="https://mp.weixin.qq.com/s/yZ3ZI6IE7sr8GYM73K3aew">【干货】在OneNote中创建完美的大括号</a></p>
<p><a href="https://mp.weixin.qq.com/s/AcztYhBVnJtlqyWWlwWSGw">转换网页webp图片格式以用于Onenote&#x2F;印象笔记的剪藏</a></p>
<p><a href="https://mp.weixin.qq.com/s/EuZFCj2dkZWg9DeRu4lZZg">【动态壁纸软件分享】壁纸跟随时间动态变化</a></p>
<p><a href="https://mp.weixin.qq.com/s/3OLX3BNhJsEE1SeRCRoBhg">如何导出OneNote中一个页面的所有图片文件</a></p>
<p><a href="https://mp.weixin.qq.com/s/C_--MuOAjobh3rNokdkkNg">OneNote的存储空间到底多大？如何给OneNote免费扩容？</a></p>
<p><a href="https://mp.weixin.qq.com/s/3lTXz3GKMtu2m7OJ4deNrQ">通过电子邮件保存资料至OneNote</a></p>
<p><a href="https://mp.weixin.qq.com/s/xggw3MhL1a9S-2cwFXpRnQ">一张图入门时间管理流程GTD</a></p>
<p><a href="https://mp.weixin.qq.com/s/S9qkkKsHYGL-_i6B0kKvgg">一张图快速入门OneNote软件操作</a></p>
<p><a href="https://mp.weixin.qq.com/s/jl1VHSbqXfeNZV3hXJl5FQ">来自微软官方的OneNote快捷键大全</a></p>
<p><a href="https://mp.weixin.qq.com/s/AAI9l1Gx2iSildGnH2GVWQ">【新年快乐】【OneNote模板分享】晨间日记</a></p>
<p> <a href="https://mp.weixin.qq.com/s/RUxHPqVf0FBDAoxb3p93cQ">【OneNote模板分享】错题本模板</a></p>
<p><a href="https://mp.weixin.qq.com/s/uxQ4dbtbWuTWgXxZoHeP0A">微软对OneNote一年的发展规划</a></p>
<p><a href="https://mp.weixin.qq.com/s/kJzbn72thmqGGn30hOEzJw">微软：在 OneNote 中同步笔记的最佳做法</a></p>
<p><a href="https://mp.weixin.qq.com/s/8t6T-qgZLntTja8BtsllHA">【News】微软恢复对OneNote2016的主流支持</a></p>
<p><a href="https://mp.weixin.qq.com/s/wyGtrd7HSUY8LZq6RiGa2g">你们都用错了思维导图</a></p>
<p><a href="https://mp.weixin.qq.com/s/9cjBmoQKeG0oN_FYjhHXtA">把OneNote UWP设为开机启动</a></p>
<p><a href="https://mp.weixin.qq.com/s/KMfqvPjXv01R3Y2yj2N56A">解析重命名OneNote笔记本的几种方式</a></p>
<p><a href="https://mp.weixin.qq.com/s/u6yZw3LlMIApwrMkiThzgg">深度认识OneNote笔记文件格式</a></p>
<p><a href="https://mp.weixin.qq.com/s/oJo3As9cjZTNYaDT-jk2Zw">OneNote 2016快速入门指南</a></p>
<p><a href="https://mp.weixin.qq.com/s/BbUe5NCVxZFohmL0Mmbg8A">【干货】OneNote微软云笔记操作技巧都在这里了！</a></p>
<p><a href="https://mp.weixin.qq.com/s/_6uT3McO6CnhHaWj4lr6PQ">【干货】拯救下OneNote的表格</a></p>
<p><a href="https://mp.weixin.qq.com/s/hPqCP2tpc_wiZVAaMm4j3w">【OneNote模板分享】康奈尔笔记模板A4便于打印</a></p>
<p><a href="https://mp.weixin.qq.com/s/9g7e2_IDbRi7Wd9P772-3g">一分钟OneNote笔记转思维导图</a></p>
<p><a href="https://mp.weixin.qq.com/s/mJNLrwDzcavxeMsvP3prBA">把你的笔记钉在桌面上（OneNote UWP强烈推荐）</a></p>
<p><a href="https://mp.weixin.qq.com/s/wTLHPhbS7ByQmDYRp02THQ">OneNote为你的笔记建立大纲</a></p>
<p><a href="https://mp.weixin.qq.com/s/KF4k3-LRK-yiATygw6McXg">揪出你OneNote中的臃肿笔记</a></p>
<p><a href="https://mp.weixin.qq.com/s/ALxw-Zpf8tE5-Mz50P26BQ">改善你的OneNote同步速度</a></p>
<p><a href="https://mp.weixin.qq.com/s/csbaJmcDeR-fge8eIaEIeQ">解决全局手势粘贴造成OneNote UWP 占用CTRL的问题</a></p>
<p><a href="https://mp.weixin.qq.com/s/kG8HyQPXqc7lFiAa8EpXNQ">如何选择电子笔记软件</a></p>
<p><a href="https://mp.weixin.qq.com/s/Imt7svDxg2kZvT0H__AkPw">为什么要做电子笔记</a></p>
<p><a href="https://mp.weixin.qq.com/s/bs8zBe168NlWB9-AyMU4qg">初次见面，暖场热身</a></p>
<br/>

<br/>

<br/>

<br/>

<blockquote class="blockquote-center">
<p>一声梧叶一声秋，一点芭蕉一点愁，三更归梦三更后。</p>
<p>－－徐再思《水仙子·夜雨》</p>

</blockquote>



<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion配置QT的开发环境</title>
    <url>/posts/30535.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh889n55kxj23s02iowz1.jpg"></p>
<p>　　Qt 开发时 QtCreator 是不得不接触的 IDE，提供了代码编写与可视化设计 GUI 的环境，但有时候使用却有点稍显逊色 。CLion 是 JetBrains 出品的 C++ IDE ，使用 CLion 来编写 C++ 会大大提高效率，因此 CLion 写代码，Qt Designer设计界面的方式是个不错的选择。😛</p>
<span id="more"></span>



<h2 id="我的的配置环境"><a href="#我的的配置环境" class="headerlink" title="我的的配置环境"></a>我的的配置环境</h2><blockquote>
<p>Windows 10</p>
<p>Qt 5.14..0</p>
<p>Mingw 64 bit</p>
<p>CLion 2020.1</p>
</blockquote>
<br/>

<h2 id="安装-CLion-与-Qt"><a href="#安装-CLion-与-Qt" class="headerlink" title="安装 CLion 与 Qt"></a>安装 CLion 与 Qt</h2><p> 　　首先安装好CLion ，可参考前面的这篇文章：  <a href="https://www.lifeee.top/posts/59155.html">CLion的安装、激活、汉化及编译器配置</a></p>
<p>并安装Qt ，可参见 <a href="https://www.lifeee.top/posts/20536.html">Visual Studio 2019配置qt开发环境</a> 一文中 <a href="https://www.lifeee.top/posts/20536.html#Qt%E5%AE%89%E8%A3%85">Qt安装</a> 小节 安装好 Qt 。安装时可根据自身需求选择 mingw 或者 MSVC 编译器。</p>
<blockquote>
<p>Basically, MinGW is a port of Linux (GNU, actually) tools for Windows, which happen to include a port of GCC (the actual compiler). MSVC, on the other hand, is a Windows native tool chain and runtime for building C&#x2F;C++ executables.  – <a href="https://www.quora.com/What-is-the-difference-between-MinGW-and-MSVC-compilers">Quora</a></p>
<p>MinGW 是 Minimalist GNU on Windows 的缩写。它是一个可自由使用和自由发布的 Windows 特定头文件和使用 GNU 工具集导入库的集合，允许你在 GNU&#x2F;Linux 和 Windows 平台生成本地的 Windows 程序而不需要第三方 C 运行时库。</p>
<p>msvc 版允许和微软的 Visual Studio 进行集成迅速开发复杂的企业级应用。 </p>
<p>如果考虑到扩展和跨平台，应该优先考虑 MinGW。</p>
</blockquote>
<br/>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>  右键“我的电脑”-》“高级系统设置”-》“环境变量”-》“系统变量”-》Path，添加如下四个新的系统变量：</p>
<blockquote>
<p>D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_64\bin</p>
<p>D:\20200213\ForDevelopment\Qt\Qt5.14.1\Tools\mingw730_64\lib</p>
<p>D:\20200213\ForDevelopment\Qt\Qt5.14.1\5.14.1\mingw73_64\bin</p>
<p>D:\20200213\ForDevelopment\Qt\Qt5.14.1\5.14.1\mingw73_64\lib</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh71kywfkmj20m10j4dhf.jpg"></p>
<p>根据自己的安装路径配置如上四个系统变量。</p>
<br/>

<h2 id="CLion-中的配置"><a href="#CLion-中的配置" class="headerlink" title="CLion 中的配置"></a>CLion 中的配置</h2><h3 id="CLion-中工具链配置"><a href="#CLion-中工具链配置" class="headerlink" title="CLion 中工具链配置"></a>CLion 中工具链配置</h3><p>启动Clion后，左上角是点击“File”-》“settings”-》“Build，Excution，Deployment”-》“Toolchains”,然后将Environment改为“MinGW”，然后，选择Qt安装路径下的MinGw路径。具体如下图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh71uot0gnj21370p277f.jpg"></p>
<p>若你的没有检测出，请根据上图的手动配置相应的 gcc 、g++ 等编译器的路径。注意我的是 64位 MinGW下的路径。</p>
<p>另外，若看到出现对话框中有一个黄色感叹号 ，关于 cmake 错误，请参<a href="https://zhuanlan.zhihu.com/p/43680621">https://zhuanlan.zhihu.com/p/43680621</a>。</p>
<br/>

<h3 id="CLion中CMake设置"><a href="#CLion中CMake设置" class="headerlink" title="CLion中CMake设置"></a>CLion中CMake设置</h3><p>注意：工具链要选择上一步中配置好的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh71whdmtgj21370p2diq.jpg"></p>
<p>CMake Options 是用来指定Qt的安装位置，默认会检测到，若没有的话需要手动设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMake Options：</span><br><span class="line">-DCMAKE_PREFIX_PATH=D:/20200213/ForDevelopment/Qt/Qt5.14.1/5.14.1/mingw73_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br/>



<h3 id="配置Qt-Designer和UIC-用于打开-Qt-设计师"><a href="#配置Qt-Designer和UIC-用于打开-Qt-设计师" class="headerlink" title="配置Qt Designer和UIC 用于打开 Qt 设计师"></a>配置Qt Designer和UIC 用于打开 Qt 设计师</h3><p><strong>Qt Designer 配置</strong></p>
<p>　　在CLion中，进入菜单File-&gt;Settings-&gt;Tools-&gt;External Tools，点击 + 新建工具。</p>
<p>名称写为 Qt Designer ，描述随便写，desginer.exe 的路径根据自己的安装情况更改。在参数与工作目录中分别写入$FileName$ 和 $FileDir$，见下图配置。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh72293qlwj21370p2tc2.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name: Qt Designer</span><br><span class="line">Program: D:\20200213\ForDevelopment\Qt\Qt5.14.1\5.14.1\mingw73_64\bin\designer.exe   (改为自己Qt Designer的路径)</span><br><span class="line">Arguments: $FileName$</span><br><span class="line">Working directory: $FileDir$</span><br></pre></td></tr></table></figure>

<br/>

<p><strong>UIC配置</strong></p>
<p>　　与 Qt Designer  配置相似 ，名称、描述、程序路径、参数与工作目录。其中参数与工作目录分别写入  $FileName$ -o ui_$FileNameWithoutExtension$.h 和 $FileDir$ 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh726cjkonj21370p2whs.jpg" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name: UIC</span><br><span class="line">Program: D:\20200213\ForDevelopment\Qt\Qt5.14.1\5.14.1\mingw73_64\bin\uic.exe   (改为自己uic的路径)</span><br><span class="line">Arguments: $FileName$ -o ui_$FileNameWithoutExtension$.h</span><br><span class="line">Working directory: $FileDir$</span><br></pre></td></tr></table></figure>



<p>　　这样以后就可以打开外部的 Qt 设计师编辑我们软件的界面啦。</p>
<p>具体打开方式为： 右键点击ui文件或者qrc文件，然后点击External Tools -&gt; QtDesigner，如能将选中的文件通过Qt Creator打开，则为成功。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh72anaj9oj20ar0aqt9a.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh72a9cziaj213r0y144w.jpg"></p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh72b8dv27j21i00tmwjz.jpg" alt="image" style="zoom:80%;" />





<br/>



<h2 id="建立项目进行测试"><a href="#建立项目进行测试" class="headerlink" title="建立项目进行测试"></a>建立项目进行测试</h2><h3 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h3><p>配置好后我们可以打开 CLion 试试了。</p>
<p>创建一个新项目：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424231024.png"></p>
<p>然后 Run 一下 ，熟悉的 HelloWorld ，你好世界！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424231211.png"></p>
<p>说明 C++ 的是能够运行起来啦，接下来我们加入属于 Qt 的东西 。</p>
<p>在工程上右键-》“new”-》“C++ class”，新建 &#96;&#96;mainwindow.cpp&#96;，如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh72j3a0otj210g0p9jvt.jpg"></p>
<p>接着继续在工程上右键-》“new”-》“file”,新建mainwindow.ui文件</p>
<p>在 main.cpp 中写入以下内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>mainwindow.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* File Name: mainwindow.cpp</span></span><br><span class="line"><span class="comment">* Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Author: </span></span><br><span class="line"><span class="comment">* Version: v1.0</span></span><br><span class="line"><span class="comment">* Date: 2020/7/28 17:57</span></span><br><span class="line"><span class="comment">* LastEditTime: 2020/7/28 17:57</span></span><br><span class="line"><span class="comment">* Copyright: </span></span><br><span class="line"><span class="comment">* Project Name: CLionQtTest</span></span><br><span class="line"><span class="comment">* IDE: CLion</span></span><br><span class="line"><span class="comment">* Reference:</span></span><br><span class="line"><span class="comment">* History: 修改历史记录列表， 每条修改记录应包括修改日期、修改者及修改内容简述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mainwindow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">        <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">        <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>mainwindow.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainWindow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>



<p>mainwindow.ui 可以右键-外部工具-选择UI designer 打开 ，随便加点控件</p>
<p>具体打开方式为： 右键点击ui文件或者qrc文件，然后点击External Tools -&gt; QtDesigner，如能将选中的文件通过Qt Creator打开，则为成功。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202203291046823.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202203291046401.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202203291045869.jpeg"></p>
<p>mainwindow.ui 中的内容为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMainWindow&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MainWindow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>600<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;centralwidget&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QLabel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">x</span>&gt;</span>230<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">y</span>&gt;</span>100<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">width</span>&gt;</span>351<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">height</span>&gt;</span>171<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>方正宋刻本秀楷简体<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pointsize</span>&gt;</span>16<span class="tag">&lt;/<span class="name">pointsize</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">string</span>&gt;</span>你好世界，Qt + CLion <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QPushButton&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pushButton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">x</span>&gt;</span>200<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">y</span>&gt;</span>360<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">width</span>&gt;</span>281<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">height</span>&gt;</span>101<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>思源黑体 CN Light<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pointsize</span>&gt;</span>12<span class="tag">&lt;/<span class="name">pointsize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">weight</span>&gt;</span>50<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bold</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bold</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">string</span>&gt;</span>热夏的博客</span><br><span class="line">www.lifeee.top<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMenuBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;menubar&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>26<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QStatusBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;statusbar&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br/>

<h3 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h3><p>　　CLion是根据CMakeLists.txt文件来组织和设置项目的，所以如果我们需要添加诸如Qt这样的第三方库或是改变编译行为，都只要修改CMakeLists.txt即可。</p>
<p>　　在完成上面的工作后，我们需要编写 CMakeLists.txt ，注意将 CLionQtTest 改成自己的项目名称。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line">project(CLionQtTest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTOMOC ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTOUIC ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_AUTORCC ON)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_package(Qt5Widgets)</span><br><span class="line">find_package( Qt5Core)</span><br><span class="line">find_package( Qt5Gui)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(UI_FILES)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(RC_FILES)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(QRC_FILES)</span><br><span class="line"></span><br><span class="line">add_executable(CLionQtTest</span><br><span class="line">        main.cpp</span><br><span class="line">        mainwindow.cpp</span><br><span class="line">        mainwindow.h</span><br><span class="line">        mainwindow.ui</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">target_link_libraries(CLionQtTest Qt5::Widgets)</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意将 CLionQtTest 改成自己的项目名称。</p>
<blockquote>
<p> #表示该项目至少要求cmake的版本为3.16</p>
<p>cmake_minimum_required(VERSION 3.16)</p>
<p>#指定c++标准的版本</p>
<p>set(CMAKE_CXX_STANDARD 11)  </p>
<p>#自动调用moc，uic，rcc处理qt的扩展部分</p>
<p>set(CMAKE_AUTOMOC ON)<br>set(CMAKE_AUTOUIC ON)<br>set(CMAKE_AUTORCC ON)</p>
<p>#项目名称</p>
<p>project(CLionQtTest)</p>
<p>#找到对应的qt模块，名字为qmake中QT +&#x3D; <name>中的name首字母大写后加上Qt5前缀</p>
<p>例如core为QtCore，也可以去${CMAKE_PREFIX_PATH}的目录中找到正确的模块名</p>
<p>find_package(Qt5Widgets)<br>find_package( Qt5Core)<br>find_package( Qt5Gui)</p>
<p>#向项目中添加需要的文件，当然你也可以对ui文件、cpp文件、h文件、qrc文件单独使用SET指令管理，然后添加到add_executable指令中</p>
<p>add_executable(CLionQtTest<br>  main.cpp<br>  mainwindow.cpp<br>  mainwindow.h<br>  mainwindow.ui</p>
<p>)</p>
<p># 或者 将当前目录的所有源文件添加进变量<br>aux_source_directory(. DIRS_SRCS)</p>
<p>#将项目中需要添加的Qt Modules中的库文件与项目进行链接（添加的模块即Qt”*.pro”文件中的Qt+&#x3D;Module）</p>
<p>target_link_libraries(CLionQtTest Qt5::Widgets)</p>
</blockquote>
<br/>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>然后运行即可，报错的话可以看下面的一些常见错误。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh6xxze79mj213r0ptgoz.jpg" alt="正常运行"></p>
<br/>



<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>Process finished with exit code -1073741511 (0xC0000139)</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh6xrgwxqlj213r0y1aek.jpg"></p>
<blockquote>
<p>方案一：</p>
<p>在Clion中，进入菜单-&gt;Run-&gt;Edit Configurations，选择自己的Application，填写Working directory为Qt的bin目录，如我的安装目录是：D:\Qt\Qt5.10.0\5.10.0\mingw53_32\bin</p>
<p>然后保存退出即可。</p>
<p>方案二：把Dll拷贝到exe目录</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh6xtbpmicj21270r8ju9.jpg" alt="方案一"></p>
<p>然后重新运行就正常啦</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202203291044896.png" alt="正常运行"></p>
<p>配置工具链 MinGW 路径时报错：</p>
<p>For MinGW make to work correctly sh.exe must NOT be in your path.</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh6soqz39hj21hm0oztby.jpg"></p>
<p>解决方法：cmake设置参数 -DCMAKE_SH&#x3D;”CMAKE_SH-NOTFOUND”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh6sretl4gj21hm0oz77b.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-DCMAKE_SH=&quot;CMAKE_SH-NOTFOUND&quot;</span><br></pre></td></tr></table></figure>



<br/>

<h2 id="Clion-如何切换Debug与Release版本"><a href="#Clion-如何切换Debug与Release版本" class="headerlink" title="Clion-如何切换Debug与Release版本"></a>Clion-如何切换Debug与Release版本</h2><p>　　在设置中找到 Build，Execution，Deployment 中的 CMake 。点击左侧的框，“+”，添加新的模式，系统一般会自动给你产生release版本。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh70bh50g0j21370p2mzt.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh70bvcmkij21370p2419.jpg"></p>
<p>然后进行切换，运行即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh70eix1pfj213r0nsq6f.jpg" alt="image"></p>
<br/>

<br/>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://doc.qt.io/qt-5/cmake-manual.html">CMake manuel in Qt’s documentation.</a></p>
<p><a href="https://www.cnblogs.com/apocelipes/p/10353698.html">配置CLion作为Qt5开发环境</a></p>
<p><a href="https://www.jianshu.com/p/3bfcb78af171">Clion 搭建C++环境常见问题</a></p>
<p><a href="https://my.oschina.net/StupidZhe/blog/3079593/print">Clion + CMake快速配置Qt开发环境终极版</a></p>
<p><a href="https://blog.csdn.net/iamjingong/article/details/80876040">Win10+Clion+QT5详细配置教程，实测有效！</a></p>
<p><a href="https://www.quora.com/What-is-the-difference-between-MinGW-and-MSVC-compilers">What is the difference between MinGW and MSVC compilers?</a> </p>
<p><a href="https://www.cnblogs.com/linuxAndMcu/p/12052238.html">MinGW 与 MSVC 编译的区别</a></p>
<br />

<br />

<br />

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote class="blockquote-center">
<p>要把所有的夜归还给星河，把所有的春光归还给疏疏篱落，把所有的慵慵沉迷与不前，归还给过去的我。明日之我，胸中有丘壑，立马振山河。</p>
<p>——《德卡先生的信箱》</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>编程</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>善用佳软</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>OneNote快捷键</title>
    <url>/posts/34731.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/green-leafed-plant-1698560s.jpg"></p>
<p>　　<code>Microsoft OneNote </code>是一套用于自由形式的信息获取以及多用户协作工具。OneNote 是跨平台的，但并可使用触笔、声音或视频创建笔记，比单纯使用键盘更方便。 本文摘录了一些 OneNote 的快捷键 ，善于使用快捷键能够更加轻松的编辑笔记的格式。</p>
<span id="more"></span>



<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　OneNote软件的界面是带有标签的三环活页夹的电子版本，可用于直接记录笔记，但也可用于收集打印的“页面”，或由其他应用程序发送过来的页面。页面可以在活页夹内部移动，同时可通过电子墨水技术添加注释，处理文字，或绘图，并且其中还可内嵌多媒体影音或Web链接。作为容器以及收集自不同来源的信息仓库，OneNote笔记本非常适合用于整理来自某个课程或研究项目的大量信息。</p>
<p>　　OneNote的重要创新之一是内建的搜索功能，以及可索引的图形和音频仓库。图像文件（例如屏幕截图、扫描的嵌入式文档，或照片）中可以搜索内嵌的文本内容，电子墨水注释也可作为文字进行搜索。音频内容也可以通过关键字进行语义搜索，同时还可以在录制的同时播放笔记中记录的内容。</p>
<p>　　该软件的多用户功能可实现脱机编辑和随后的同步合并，并可以段落为基础进行合并。这使得OneNote成为一个非常适合就某个项目进行协作，而且所有成员并非总是在线的情况下使用的强大工具。 </p>
<p>　　许多用户发现，将外部键盘与键盘快捷方式配合使用， OneNote 可帮助他们更高效地工作。 对行动不便或者有视力障碍的用户而言，键盘快捷方式比触摸屏更方便，是鼠标的重要替代方式。 </p>
<p>​        <strong>注意:</strong> </p>
<ul>
<li>本主题中的这些快捷方式指的是美式键盘布局。 其他键盘布局的键可能与美式键盘上的键不完全对应。</li>
<li>快捷方式中的加号（+）意味着你需要同时按多个键。</li>
<li>快捷方式中的逗号符号（，）表示需要按顺序按多个键。</li>
</ul>
<p>​    </p>
<p>本文列出了 Windows 桌面版 OneNote 的键盘快捷方式。</p>
<p>   <strong>注意:</strong> </p>
<ul>
<li><p>若要快速查找本文中的快捷方式，您可以使用 “搜索”。 按 Ctrl + F，然后键入搜索文字。</p>
 <br/></li>
</ul>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>突出显示所选文本。</td>
<td>Ctrl + Alt + H</td>
</tr>
<tr>
<td>插入超链接。</td>
<td>Ctrl+K</td>
</tr>
<tr>
<td>复制所选文字的格式（<strong>格式刷</strong>）。</td>
<td>Ctrl+Shift+C</td>
</tr>
<tr>
<td>将格式粘贴到所选文本（<strong>格式刷</strong>）。</td>
<td>Ctrl+Shift+V</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>应用或删除加粗格式。</td>
<td>Ctrl+B</td>
</tr>
<tr>
<td>应用或删除斜体格式。</td>
<td>Ctrl+I</td>
</tr>
<tr>
<td>应用或删除下划线格式。</td>
<td>Ctrl+U</td>
</tr>
<tr>
<td>应用或删除删除线格式。</td>
<td>Ctrl+连字符 (-)</td>
</tr>
<tr>
<td>应用或删除上标格式。</td>
<td>Ctrl + Shift + 等号（&#x3D;）</td>
</tr>
<tr>
<td>应用或删除下标格式。</td>
<td>Ctrl+等号 (&#x3D;)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 1</strong> “ 样式。</td>
<td>Ctrl+Alt+1</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 2</strong> “ 样式。</td>
<td>Ctrl+Alt+2</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 3</strong> “ 样式。</td>
<td>Ctrl+Alt+3</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 4</strong> “ 样式。</td>
<td>Ctrl+Alt+4</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 5</strong> “ 样式。</td>
<td>Ctrl+Alt+5</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 6</strong> “ 样式。</td>
<td>Ctrl+Alt+6</td>
</tr>
<tr>
<td>清除应用于所选文字的所有格式。 （应用 “<strong>正文</strong>“ 样式。）</td>
<td>Ctrl+Shift+N</td>
</tr>
<tr>
<td>增加段落缩进量。</td>
<td>Alt+Shift+向右键          Tab 键，位于行首</td>
</tr>
<tr>
<td>减少段落缩进量。</td>
<td>Alt+Shift+向左键                    按 Shift + Tab，在一行的开头</td>
</tr>
<tr>
<td>将段落左对齐。</td>
<td>Ctrl+L</td>
</tr>
<tr>
<td>将段落向右对齐。</td>
<td>Ctrl+R</td>
</tr>
<tr>
<td><strong>增大所选文本的字号。</strong></td>
<td><strong>Ctrl + Shift + 右尖括号（&gt;）</strong></td>
</tr>
<tr>
<td><strong>缩小所选文本的字号。</strong></td>
<td><strong>Ctrl + Shift + 左尖括号（&lt;）</strong></td>
</tr>
<tr>
<td>显示或隐藏当前页上的基准线。</td>
<td>Ctrl+Shift+R</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>插入当前日期和时间。</th>
<th>Alt+Shift+F</th>
</tr>
</thead>
<tbody><tr>
<td>开始一个数学等式或将所选文字转换为数学等式。</td>
<td>Alt + 等号（&#x3D;）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>创建表格。</th>
<th>Tab 键，键入新的文本行后</th>
</tr>
</thead>
<tbody><tr>
<td>在表中的同一单元格中创建另一个段落。</td>
<td>Alt+Enter</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>创建新单元格。</th>
<th>按 Tab 键，在表格的最后一个单元格中</th>
</tr>
</thead>
<tbody><tr>
<td>增加段落缩进量。</td>
<td>Alt+Shift+向左键</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>增加段落缩进量。</th>
<th>Alt+Shift+向左键</th>
</tr>
</thead>
<tbody><tr>
<td>减少段落缩进量。</td>
<td>Alt+Shift+向右键</td>
</tr>
</tbody></table>
   <br/>

<h2 id="标记笔记"><a href="#标记笔记" class="headerlink" title="标记笔记"></a>标记笔记</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>应用、标记或清除 “待办<strong>事项</strong>“ 标记。</td>
<td>Ctrl+1</td>
</tr>
<tr>
<td>应用或清除 “<strong>重要</strong>“ 标记。</td>
<td>Ctrl+2</td>
</tr>
<tr>
<td>应用或清除 “<strong>问题</strong>“ 标记。</td>
<td>Ctrl+3</td>
</tr>
<tr>
<td>应用或清除 “<strong>后续</strong>工作” 标记。</td>
<td>Ctrl+4</td>
</tr>
<tr>
<td>应用或清除 “<strong>定义</strong>“ 标记。</td>
<td>Ctrl+5</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁定所有受密码保护的分区。</th>
<th>Ctrl+Alt+L</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>完整快捷键前见文本后续内容</p>
   <br/>



<h2 id="设置笔记的格式"><a href="#设置笔记的格式" class="headerlink" title="设置笔记的格式"></a>设置笔记的格式</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td><strong>突出显示所选文本。</strong></td>
<td><strong>Ctrl + Alt + H</strong>     或 Ctrl + Shift +H</td>
</tr>
<tr>
<td>插入超链接。</td>
<td>Ctrl+K</td>
</tr>
<tr>
<td>复制所选文字的格式（<strong>格式刷</strong>）。</td>
<td>Ctrl+Shift+C</td>
</tr>
<tr>
<td>将格式粘贴到所选文本（<strong>格式刷</strong>）。</td>
<td>Ctrl+Shift+V</td>
</tr>
<tr>
<td>打开超链接。</td>
<td>在超链接文本上输入</td>
</tr>
<tr>
<td><strong>应用或删除加粗格式。</strong></td>
<td><strong>Ctrl+B</strong></td>
</tr>
<tr>
<td><strong>应用或删除斜体格式。</strong></td>
<td><strong>Ctrl+I</strong></td>
</tr>
<tr>
<td><strong>应用或删除下划线格式。</strong></td>
<td><strong>Ctrl+U</strong></td>
</tr>
<tr>
<td><strong>应用或删除删除线格式。</strong></td>
<td><strong>Ctrl+连字符 (-)</strong></td>
</tr>
<tr>
<td>应用或删除上标格式。</td>
<td>Ctrl + Shift + 等号（&#x3D;）</td>
</tr>
<tr>
<td>应用或删除下标格式。</td>
<td>Ctrl+等号 (&#x3D;)</td>
</tr>
<tr>
<td>应用或删除项目符号列表格式。</td>
<td>Ctrl+句点 (.)</td>
</tr>
<tr>
<td>应用或删除编号列表格式。</td>
<td>Ctrl + 斜杠（&#x2F;）</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 1</strong> “ 样式。</td>
<td>Ctrl+Alt+1</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 2</strong> “ 样式。</td>
<td>Ctrl+Alt+2</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 3</strong> “ 样式。</td>
<td>Ctrl+Alt+3</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 4</strong> “ 样式。</td>
<td>Ctrl+Alt+4</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 5</strong> “ 样式。</td>
<td>Ctrl+Alt+5</td>
</tr>
<tr>
<td>对当前笔记应用 “<strong>标题 6</strong> “ 样式。</td>
<td>Ctrl+Alt+6</td>
</tr>
<tr>
<td>清除应用于所选文字的所有格式。 （应用 “<strong>正文</strong>“ 样式。）</td>
<td>Ctrl+Shift+N</td>
</tr>
<tr>
<td>增加段落缩进量。</td>
<td>Alt+Shift+向右键                    Tab 键，位于行首</td>
</tr>
<tr>
<td>减少段落缩进量。</td>
<td>Alt+Shift+向左键                    按 Shift + Tab，在一行的开头</td>
</tr>
<tr>
<td>将段落左对齐。</td>
<td>Ctrl+L</td>
</tr>
<tr>
<td>将段落向右对齐。</td>
<td>Ctrl+R</td>
</tr>
<tr>
<td><strong>增大所选文本的字号。</strong></td>
<td><strong>Ctrl + Shift + 右尖括号（&gt;）</strong></td>
</tr>
<tr>
<td><strong>缩小所选文本的字号。</strong></td>
<td><strong>Ctrl + Shift + 左尖括号（&lt;）</strong></td>
</tr>
<tr>
<td>显示或隐藏当前页上的基准线。</td>
<td>Ctrl+Shift+R</td>
</tr>
</tbody></table>
<p>​              <br/></p>
<p>​	</p>
<h2 id="在页面上插入项目"><a href="#在页面上插入项目" class="headerlink" title="在页面上插入项目"></a>在页面上插入项目</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>在当前页上插入文档或文件。</td>
<td>Alt+N, F</td>
</tr>
<tr>
<td>在当前页上将文档或文件作为打印输出插入。</td>
<td>Alt+N, O</td>
</tr>
<tr>
<td>显示或隐藏当前页上的文档打印输出（当在高对比度模式下运行 OneNote 时）。</td>
<td>Alt+Shift+P</td>
</tr>
<tr>
<td>插入来自文件的图片。</td>
<td>Alt+N, P</td>
</tr>
<tr>
<td>插入来自扫描仪或相机的图片。</td>
<td>Alt+N, S</td>
</tr>
<tr>
<td>插入屏幕剪辑                                                                  <strong>注意:</strong> “ OneNote “ 图标必须在 Windows 任务栏通知区域中处于活动状态。</td>
<td>Windows 徽标键+Shift+S                    在 OneNote 2007 和2010中，Windows 徽标键 + S</td>
</tr>
<tr>
<td>插入当前日期。</td>
<td>Alt+Shift+D</td>
</tr>
<tr>
<td>插入当前日期和时间。</td>
<td>Alt+Shift+F</td>
</tr>
<tr>
<td>插入当前时间。</td>
<td>Alt+Shift+T</td>
</tr>
<tr>
<td>插入换行符。</td>
<td>Shift+Enter</td>
</tr>
<tr>
<td>开始一个数学等式或将所选文字转换为数学等式。</td>
<td>Alt + 等号（&#x3D;）</td>
</tr>
</tbody></table>
<p>​         <br/></p>
<p>​	</p>
<h2 id="使用表格"><a href="#使用表格" class="headerlink" title="使用表格"></a>使用表格</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>创建表格。</td>
<td>Tab 键，键入新的文本行后</td>
</tr>
<tr>
<td>在只有一行的表中创建另一个列。</td>
<td>Tab 键</td>
</tr>
<tr>
<td>当位于表的最后一个单元格中时创建另一行。</td>
<td>Enter                                                                  <strong>注意:</strong> 再次按 Enter 完成表。</td>
</tr>
<tr>
<td>在当前行下方插入一行。</td>
<td>在表格单元格中按 Ctrl + Enter</td>
</tr>
<tr>
<td>在表中的同一单元格中创建另一个段落。</td>
<td>Alt+Enter</td>
</tr>
<tr>
<td>在表中当前列的右侧创建一列。</td>
<td>Ctrl+Alt+R</td>
</tr>
<tr>
<td>在表中当前列的左侧创建一列。</td>
<td>在 OneNote 2010 中，按 Ctrl + Alt + E</td>
</tr>
<tr>
<td>在表中的当前行上方创建一个行。</td>
<td>当光标位于任意行的开头（第一行除外）时，Enter</td>
</tr>
<tr>
<td>创建新单元格。</td>
<td>按 Tab 键，在表格的最后一个单元格中</td>
</tr>
<tr>
<td>删除表中的当前空行。</td>
<td>删除，然后在光标位于行首时再次删除</td>
</tr>
</tbody></table>
   <br/>       

<p>​	</p>
<h2 id="选择文本和对象"><a href="#选择文本和对象" class="headerlink" title="选择文本和对象"></a>选择文本和对象</h2><table>
<thead>
<tr>
<th>若要</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>选择当前页上的所有项目。</td>
<td>Ctrl+A                    若要展开所选内容，请再次按 Ctrl + A。</td>
</tr>
<tr>
<td>选择到行末。</td>
<td>Shift+End</td>
</tr>
<tr>
<td>选择整行。</td>
<td>当光标位于行首时，按 Shift + 向下键</td>
</tr>
<tr>
<td>跳转到页面的标题并选择它。</td>
<td>Ctrl+Shift+T</td>
</tr>
<tr>
<td>取消选择 “分级显示” 或 “页面”。</td>
<td>Esc</td>
</tr>
<tr>
<td>向上移动所选段落。</td>
<td>Alt+Shift+向上箭头键</td>
</tr>
<tr>
<td>向下移动所选段落。</td>
<td>Alt+Shift+向下键</td>
</tr>
<tr>
<td>增加段落缩进量。</td>
<td>Alt+Shift+向左键</td>
</tr>
<tr>
<td>减少段落缩进量。</td>
<td>Alt+Shift+向右键</td>
</tr>
<tr>
<td>选择当前段落及其下属段落。</td>
<td>Ctrl+Shift+连字符 (-)</td>
</tr>
<tr>
<td>删除所选笔记或对象。</td>
<td>Delete</td>
</tr>
<tr>
<td>移至行的开始。</td>
<td>Home</td>
</tr>
<tr>
<td>移至行的末尾。</td>
<td>End</td>
</tr>
<tr>
<td>返回访问的上一页。</td>
<td>Alt+向左箭头键</td>
</tr>
<tr>
<td>向前转到访问的下一页。</td>
<td>Alt+向右箭头键</td>
</tr>
</tbody></table>
<p>​        <br/></p>
<h2 id="标记笔记-1"><a href="#标记笔记-1" class="headerlink" title="标记笔记"></a>标记笔记</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>应用、标记或清除 “待办<strong>事项</strong>“ 标记。</td>
<td>Ctrl+1</td>
</tr>
<tr>
<td>应用或清除 “<strong>重要</strong>“ 标记。</td>
<td>Ctrl+2</td>
</tr>
<tr>
<td>应用或清除 “<strong>问题</strong>“ 标记。</td>
<td>Ctrl+3</td>
</tr>
<tr>
<td>应用或清除 “<strong>后续</strong>工作” 标记。</td>
<td>Ctrl+4</td>
</tr>
<tr>
<td>应用或清除 “<strong>定义</strong>“ 标记。</td>
<td>Ctrl+5</td>
</tr>
<tr>
<td>应用或清除自定义标记。</td>
<td>Ctrl+6</td>
</tr>
<tr>
<td>应用或清除自定义标记。</td>
<td>Ctrl+7</td>
</tr>
<tr>
<td>应用或清除自定义标记。</td>
<td>Ctrl+8</td>
</tr>
<tr>
<td>应用或清除自定义标记。</td>
<td>Ctrl+9</td>
</tr>
<tr>
<td>删除所选笔记中的所有笔记标记。</td>
<td>Ctrl+0</td>
</tr>
</tbody></table>
<p>​        <br/></p>
<h2 id="使用大纲"><a href="#使用大纲" class="headerlink" title="使用大纲"></a>使用大纲</h2><table>
<thead>
<tr>
<th>若要</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>通过<strong>级别 1</strong>显示。</td>
<td>Alt+Shift+1</td>
</tr>
<tr>
<td>展开到 “<strong>级别 2</strong>“。</td>
<td>Alt+Shift+2</td>
</tr>
<tr>
<td>展开到<strong>级别 3</strong>。</td>
<td>Alt+Shift+3</td>
</tr>
<tr>
<td>展开到 “<strong>级别 4</strong>“。</td>
<td>Alt+Shift+4</td>
</tr>
<tr>
<td>展开到 “<strong>级别 5</strong>“。</td>
<td>Alt+Shift+5</td>
</tr>
<tr>
<td>展开到 “<strong>级别 6</strong>“。</td>
<td>Alt+Shift+6</td>
</tr>
<tr>
<td>展开到<strong>级别 7</strong>。</td>
<td>Alt+Shift+7</td>
</tr>
<tr>
<td>展开到 “<strong>级别 8</strong>“。</td>
<td>Alt+Shift+8</td>
</tr>
<tr>
<td>展开到 “<strong>级别 9</strong>“。</td>
<td>Alt+Shift+9</td>
</tr>
<tr>
<td>展开所有级别。</td>
<td>Alt+Shift+0</td>
</tr>
<tr>
<td>展开所选标题。</td>
<td>Alt + Shift + 等号（&#x3D;）</td>
</tr>
<tr>
<td>折叠所选标题。</td>
<td>Alt + Shift + 连字符（-）</td>
</tr>
<tr>
<td>将缩进量增加一级。</td>
<td>Tab 键</td>
</tr>
<tr>
<td>将缩进减少一级。</td>
<td>Shift+Tab</td>
</tr>
<tr>
<td>展开折叠的大纲。</td>
<td>Alt+Shift+加号 (+)</td>
</tr>
<tr>
<td>折叠展开的大纲。</td>
<td>Alt + Shift + 减号（-）</td>
</tr>
</tbody></table>
<p>​          <br/></p>
<h2 id="指定语言设置"><a href="#指定语言设置" class="headerlink" title="指定语言设置"></a>指定语言设置</h2><p>​                <strong>注意:</strong> 若要更改笔记的书写方向，必须首先在 “ <strong>Microsoft Office 语言首选项</strong>“ 工具中启用一种或多种从右向左书写的语言。</p>
<table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>设置从左向右的书写方向。</td>
<td>Ctrl + 左 shift</td>
</tr>
<tr>
<td>设置从右向左的书写方向。</td>
<td>Ctrl + 右 shift</td>
</tr>
<tr>
<td>在从右向左的文本中将缩进增加一个级别。</td>
<td>Tab 键</td>
</tr>
<tr>
<td>在从右向左的文本中将缩进减少一个级别。</td>
<td>Shift+Tab</td>
</tr>
</tbody></table>
<p>​        <br/>    </p>
<p>​	</p>
<h2 id="处理页面"><a href="#处理页面" class="headerlink" title="处理页面"></a>处理页面</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>启用或禁用整页视图。</td>
<td>F11</td>
</tr>
<tr>
<td>打开新的 OneNote 窗口。</td>
<td>Ctrl+M</td>
</tr>
<tr>
<td>创建<strong>快速笔记</strong>。</td>
<td>Ctrl+Shift+M</td>
</tr>
<tr>
<td>展开或折叠页组的选项卡。</td>
<td>Ctrl + Shift + 星号（*）</td>
</tr>
<tr>
<td>打印当前页。</td>
<td>Ctrl+P</td>
</tr>
<tr>
<td>在选定分区的末尾添加一个新页。</td>
<td>Ctrl+N</td>
</tr>
<tr>
<td>增加页选项卡栏的宽度。</td>
<td>Ctrl + Shift + 左方括号（[）</td>
</tr>
<tr>
<td>减小页选项卡栏的宽度。</td>
<td>Ctrl + Shift + 右方括号（]）</td>
</tr>
<tr>
<td>在当前页之下创建一个相同级别的新页。</td>
<td>Ctrl+Alt+N</td>
</tr>
<tr>
<td>减少当前页选项卡标签的缩进级别。</td>
<td>Ctrl + Alt + 左中括号（[）</td>
</tr>
<tr>
<td>增加当前页选项卡标签的缩进级别。</td>
<td>Ctrl + Alt + 右方括号（[）</td>
</tr>
<tr>
<td>在当前页之下创建一个新子页。</td>
<td>Ctrl+Shift+Alt+N</td>
</tr>
<tr>
<td>选择所有项。</td>
<td>Ctrl+A                    若要展开所选内容，请再次按 Ctrl + A。</td>
</tr>
<tr>
<td>选择当前页。</td>
<td>Ctrl+Shift+A                    如果所选页面是组的一部分，请按 Ctrl + A 选择组中的所有页面。</td>
</tr>
<tr>
<td>向上移动所选页选项卡。</td>
<td>Alt+Shift+向上箭头键</td>
</tr>
<tr>
<td>向下移动所选页选项卡。</td>
<td>Alt+Shift+向下键</td>
</tr>
<tr>
<td>移动到页面标题。</td>
<td>Ctrl+Shift+T</td>
</tr>
<tr>
<td>转至当前可见的一组页选项卡中的第一页。</td>
<td>Alt+Page Up</td>
</tr>
<tr>
<td>转至当前可见的一组页选项卡中的最后一页。</td>
<td>Alt+Page Down</td>
</tr>
<tr>
<td>在当前页中向上滚动。</td>
<td>Page Up</td>
</tr>
<tr>
<td>在当前页中向下滚动。</td>
<td>Page Down</td>
</tr>
<tr>
<td>滚动到当前页的顶部。</td>
<td>Ctrl+Home</td>
</tr>
<tr>
<td>滚动到当前页的底部。</td>
<td>Ctrl+End</td>
</tr>
<tr>
<td>转至下一段落。</td>
<td>Ctrl+向下键</td>
</tr>
<tr>
<td>转至上一段落。</td>
<td>Ctrl+向上键</td>
</tr>
<tr>
<td>在当前页上向上移动光标或向上展开页面。</td>
<td>Ctrl+Alt+向上箭头键</td>
</tr>
<tr>
<td>将光标向下移动到当前页，或向下展开页面。</td>
<td>Ctrl+Alt+向下箭头键</td>
</tr>
<tr>
<td>将光标停留在当前页上，或将页面向左展开。</td>
<td>Ctrl+Alt+向左箭头键</td>
</tr>
<tr>
<td>将光标向右移动到当前页，或向右展开页面。</td>
<td>Ctrl+Alt+向右箭头键</td>
</tr>
<tr>
<td>转至下一个笔记容器。</td>
<td>Alt+向下键</td>
</tr>
<tr>
<td>转至行的开头。</td>
<td>Home</td>
</tr>
<tr>
<td>转至行的结尾。</td>
<td>End</td>
</tr>
<tr>
<td>转到以前访问过的页面。</td>
<td>Alt+向左箭头键</td>
</tr>
<tr>
<td>转到访问的下一页（如有可能）。</td>
<td>Alt+向右箭头键</td>
</tr>
<tr>
<td>放大。</td>
<td>Alt + Ctrl + 加号（在数字键盘上）                    Alt + Ctrl + Shift + 加号（+）</td>
</tr>
<tr>
<td>缩小。</td>
<td>Alt + Ctrl + 减号（在数字键盘上）                    Alt + Ctrl + Shift + 连字符（-）</td>
</tr>
<tr>
<td>同步笔记本。                                                                  <strong>注意:</strong> 当 OneNote 运行时，你的笔记会在你更改时自动保存。 因此，您不必手动保存笔记。</td>
<td>Ctrl+S</td>
</tr>
</tbody></table>
<p>​       <br/>     </p>
<p>​	</p>
<h2 id="使用笔记本和分区"><a href="#使用笔记本和分区" class="headerlink" title="使用笔记本和分区"></a>使用笔记本和分区</h2><table>
<thead>
<tr>
<th>若要</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>打开 OneNote 。</td>
<td>Windows 徽标键 + Shift + N</td>
</tr>
<tr>
<td>打开一个笔记本。</td>
<td>Ctrl+O</td>
</tr>
<tr>
<td>打开分区。</td>
<td>Ctrl+Alt+Shift+O</td>
</tr>
<tr>
<td>发送到 OneNote 工具。</td>
<td>Windows 徽标键 + N</td>
</tr>
<tr>
<td>创建一个新分区。</td>
<td>Ctrl+T</td>
</tr>
<tr>
<td>转至下一分区。</td>
<td>Ctrl+Tab</td>
</tr>
<tr>
<td>转至上一分区。</td>
<td>Ctrl+Shift+Tab</td>
</tr>
<tr>
<td>转至分区中的下一页。</td>
<td>Ctrl+Page Down</td>
</tr>
<tr>
<td>转至分区中的上一页。</td>
<td>Ctrl+Page Up</td>
</tr>
<tr>
<td>转至分区中的第一页。</td>
<td>Alt+Home</td>
</tr>
<tr>
<td>转至分区中的最后一页。</td>
<td>Alt+End</td>
</tr>
<tr>
<td>转至当前可见的一组页选项卡中的第一页。</td>
<td>Alt+Page Up</td>
</tr>
<tr>
<td>转至当前可见的一组页选项卡中的最后一页。</td>
<td>Alt+Page Down</td>
</tr>
<tr>
<td>移动或复制当前页。</td>
<td>Ctrl+Alt+M</td>
</tr>
<tr>
<td>将焦点放在当前页选项卡上。</td>
<td>Ctrl+Alt+G</td>
</tr>
<tr>
<td>选择当前页选项卡。</td>
<td>Ctrl+Shift+A</td>
</tr>
<tr>
<td>将焦点放在当前分区选项卡上。</td>
<td>Ctrl+Shift+G</td>
</tr>
<tr>
<td>移动当前分区。</td>
<td>Ctrl+Shift+G，然后按 Shift+F10, M</td>
</tr>
<tr>
<td>切换到导航栏上的另一个笔记本。</td>
<td>按 Ctrl + G，使用向下键或向上键选择笔记本，然后按 Enter</td>
</tr>
</tbody></table>
<p>​        <br/>    </p>
<p>​	</p>
<h2 id="搜索笔记"><a href="#搜索笔记" class="headerlink" title="搜索笔记"></a>搜索笔记</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>移动到<strong>搜索</strong>框以搜索所有笔记本。</td>
<td>Ctrl+E</td>
</tr>
<tr>
<td>在搜索所有笔记本时，预览下一个结果。</td>
<td>向下键</td>
</tr>
<tr>
<td>搜索所有笔记本时，转到所选结果并关闭搜索。</td>
<td>Enter</td>
</tr>
<tr>
<td>更改搜索范围。</td>
<td>Ctrl + E、Tab 键、空格键</td>
</tr>
<tr>
<td>打开 “<strong>搜索结果</strong>“ 窗格。</td>
<td>在搜索之后按 Alt+O</td>
</tr>
<tr>
<td>搜索当前页。</td>
<td>Ctrl+F</td>
</tr>
<tr>
<td>在搜索当前页时，移到下一个结果。</td>
<td>Enter                    F3</td>
</tr>
<tr>
<td>在搜索当前页时，移到上一个结果。</td>
<td>Shift+F3</td>
</tr>
<tr>
<td>关闭搜索并返回到页面。</td>
<td>Esc</td>
</tr>
</tbody></table>
   <br/>    

<p>​	</p>
<h2 id="共享笔记"><a href="#共享笔记" class="headerlink" title="共享笔记"></a>共享笔记</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>使用电子邮件发送所选页。</td>
<td>Ctrl+Shift+E</td>
</tr>
<tr>
<td>从所选笔记创建<strong>今日</strong>Outlook 任务。</td>
<td>Ctrl+Shift+1</td>
</tr>
<tr>
<td>从所选笔记创建<strong>明天</strong>的Outlook 任务。</td>
<td>Ctrl+Shift+2</td>
</tr>
<tr>
<td>从所选笔记创建 “<strong>本周</strong>“Outlook 任务。</td>
<td>Ctrl+Shift+3</td>
</tr>
<tr>
<td>从所选笔记创建 “<strong>下周</strong>Outlook 任务”。</td>
<td>Ctrl+Shift+4</td>
</tr>
<tr>
<td>从所选笔记创建 “<strong>无日期</strong>“Outlook 任务。</td>
<td>Ctrl+Shift+5</td>
</tr>
<tr>
<td>打开所选的 Outlook 任务。</td>
<td>Ctrl+Shift+K</td>
</tr>
<tr>
<td>将所选 Outlook 任务标记为 “已完成”。</td>
<td>Ctrl+Shift+9</td>
</tr>
<tr>
<td>删除所选 Outlook 任务。</td>
<td>Ctrl+Shift+0</td>
</tr>
<tr>
<td>同步当前共享笔记本中的更改。</td>
<td>Shift+F9</td>
</tr>
<tr>
<td>同步所有共享笔记本中的更改。</td>
<td>F9</td>
</tr>
<tr>
<td>将当前页标记为<strong>未读</strong>。</td>
<td>Ctrl+Q</td>
</tr>
</tbody></table>
<p>   　        <br/>	</p>
<h2 id="保护笔记"><a href="#保护笔记" class="headerlink" title="保护笔记"></a>保护笔记</h2><table>
<thead>
<tr>
<th>执行的操作</th>
<th>按</th>
</tr>
</thead>
<tbody><tr>
<td>锁定所有受密码保护的分区。</td>
<td>Ctrl+Alt+L</td>
</tr>
</tbody></table>
   <br/>       

<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><p>​              <a href="https://support.microsoft.com/zh-cn/office/%E4%BD%BF%E7%94%A8%E5%B1%8F%E5%B9%95%E9%98%85%E8%AF%BB%E5%99%A8%E6%B5%8F%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA-onenote-4097a3f7-067d-4a81-a0c1-1afa4a15dffb#picktab=windows_desktop">使用屏幕阅读器浏览和导航 OneNote</a>            </p>
<p>​              <a href="https://support.microsoft.com/zh-cn/office/%E5%9C%A8-onenote-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B1%8F%E5%B9%95%E9%98%85%E8%AF%BB%E5%99%A8%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1-32cd532b-d5d4-442b-bc13-1d0ad2016377#picktab=windows_desktop">在 OneNote 中使用屏幕阅读器执行基本任务</a>            </p>
<blockquote>
<p>Referenc:  <a href="https://support.microsoft.com/zh-cn/office/onenote-%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F-44b8b3f4-c274-4bcc-a089-e80fdcc87950">OneNote 中的键盘快捷方式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>高效</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PQDT查找国外硕博学位论文</title>
    <url>/posts/11890.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E6%A3%80%E7%B4%A2%E7%A1%95%E5%8D%9A%E8%AE%BA%E6%96%871_compressed.jpg"></p>
<p>　　查找国内的硕博学位论文可以上万方、知网，那么要查找国外的呢？答案是 PQDT 。😉</p>
<span id="more"></span>



<h2 id="PQDT"><a href="#PQDT" class="headerlink" title="PQDT"></a>PQDT</h2><p>　　PQDT（ProQuest数字化博硕士论文文摘数据库）：ProQuest公司是世界上最早及最大的博硕士论文收藏和供应商，该公司的ProQuest Dissertations and  Theses（PQDT）数据库收录全球2,000余所大学文、理、工、农、医等领域的380多万篇博士、硕士论文的摘要及索引，内容覆盖理工和人文社科等广泛领域，是学术研究中十分重要的参考信息源。</p>
<p>网址：<a href="http://search.proquest.com/">http://search.proquest.com/</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200911204452.jpg"></p>
<p>　　每年约增加10万篇论文摘要。其中博士论文摘要350字左右，硕士论文摘要为150字左右，并可看到1997年以来论文的前24页。该数据库是检索世界各大学学位论文及挑选全文的首选途径。</p>
<p>　　PQDT分为A辑(人文社科专辑)和B辑(理工农医专辑)</p>
<blockquote>
<p>【数据库属性】 资源类型：学位论文<br>学科类型：综合或其它<br>开放类型：商业数据库<br>内容类型：全文<br>适用类型：科研类<br>语种类型：外文<br>购买类型：正式</p>
</blockquote>
<blockquote>
<p>ProQuest Dissertations &amp; Theses可实现:</p>
<ul>
<li><strong>研究生</strong> 通过检索数据库，已保证自己计划撰写的论文不会与已发表的论文重复</li>
<li><strong>学生、老师和其他研究人员</strong> 检索与他们学术兴趣相关的论文</li>
<li>快速获取高质量、<strong>同行评审</strong>和<strong>跨学科</strong>的研究资料</li>
<li>构建你自己的<strong>电子书</strong>馆藏 - 每一篇新出版的论文都包含了ISBN号，ProQuest是全球最大的<strong>ISBN</strong>出版商 </li>
<li><strong>跨库检索</strong> 可与ProQuest平台的期刊及其他类型数据库实现合并检索</li>
</ul>
<p>　　数据库提供书目和索引信息，收录论文最早可回溯到1861年美国的第一篇论文，以及17世纪欧洲的论文，最新收录可至上学期刚发表的论文。</p>
<p>　　<em><strong>ProQuest Dissertations &amp; Theses</strong></em> 作为美国国会图书馆的官方论文存储资料库，和加拿大国家图书馆的出版合作伙伴。</p>
<p>　　该数据库可提供200多万篇全文论文，包括印刷本、微缩、电子本（如允许订购）出版类型，国内订户是订购ProQuest Dissertations &amp; Theses A &amp; I 博硕论文文摘数据库，包含了PQDT A 人文社科专集和PQDT  B科学与工程专集，国内还组建了PQDT全文团，各参团成员通过挑选论文，然后将所选订的论文存放在国内专门的全文数据库检索平台，以实现检索与利用。</p>
<p><em><strong>PQDT</strong></em> 文摘库可提供电子版博硕论文前10%的内容预览，最多可预览前24页。</p>
<p><em><strong>PQDT</strong></em> 每周更新，提供24个标引和检索字段，可进行全文检索。</p>
</blockquote>
<p>网址：<a href="http://search.proquest.com/">http://search.proquest.com/</a></p>
<br/>



<br/>



<h2 id="PQDT新平台"><a href="#PQDT新平台" class="headerlink" title="PQDT新平台"></a>PQDT新平台</h2><p>　　PQDTCN数据库为PQDT中部分记录的全文。该库目前已收录国外博硕士学位论文逾40万篇，年增2万多篇。该库通过CALIS组织的“ProQuest学位论文全文数据库集团采购”建设而成，各馆均购买一定数量的论文，然后放在全文库中进行共享。</p>
<blockquote>
<p> 是否可以理解为<strong>PQDTCN</strong>是<strong>PQDT</strong>的国内镜像？🙄</p>
</blockquote>
<p>　　ProQuest博硕士学位论文全文数据库：该数据库是在PQDT文摘库的基础上，由ProQuest公司开发，中国集团引进的电子版论文全文服务系统，目前收录有1998年以来的授予学位的63万多篇博硕士论文全文，每年仍以1万多篇的速度增长。</p>
<p>网址：<a href="http://www.pqdtcn.com/">http://www.pqdtcn.com/</a></p>
<p><strong>全文库：</strong></p>
<p><a href="http://www.pqdtcn.com/">PQDT学位论文全文检索平台 http://www.pqdtcn.com/</a></p>
<p><strong>其他镜像站点：</strong></p>
<p><a href="http://pqdt.calis.edu.cn/">PQDT学位论文全文(CALIS站点)</a></p>
<p><a href="http://pqdt.bjzhongke.com.cn/">PQDT学位论文全文（中信所站点）</a></p>
<p><a href="http://pqdt.lib.sjtu.edu.cn/">PQDT学位论文全文（上交大站点）</a></p>
<br/>

<h2 id="PQDT新平台使用介绍"><a href="#PQDT新平台使用介绍" class="headerlink" title="PQDT新平台使用介绍"></a>PQDT新平台使用介绍</h2><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%873.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%874.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%875.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%876.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%877.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%878.PNG"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/%E5%B9%BB%E7%81%AF%E7%89%879.PNG"></p>
<br/>

<br/>





<h2 id="常用检索关键词："><a href="#常用检索关键词：" class="headerlink" title="常用检索关键词："></a>常用检索关键词：</h2><p>​    1、使用“and”或空格搜索全部关键词<br>​　　多个关键词用空格或“and”隔开，如“digital library”或“digital and library”，这两个词将同时出现在标题、正文或摘要中（两个词的出现位置不一定相邻）。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916114745954.png"></p>
<p>​    2、使用双引号搜索完整的关键词<br>　　如果输入的关键词本身包括空格并且不希望被分割，可以在关键词两边加上西文双引号，如“”digital library””。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916114829465.png"></p>
<p>​    3、使用“OR”搜索任意关键词<br>　　搜索多个关键词中的任一词，如“digital or library”，这时搜索结果将包含这两个词中的任一个或全部。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916114855114.png"></p>
<p>​    4、使用“and not”排除关键词<br>排除包含指定关键词的搜索结果，如“digital library and not study”，这时搜索结果将同时包含前两个词，但不包含“study”。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916114920134.png"></p>
<br/>

<br/>

<br/>

<br/>



<blockquote class="blockquote-center">
<p>谁念西风独自凉，萧萧黄叶闭疏窗，沉思往事立残阳。</p>
<p>— 纳兰性德《浣溪沙·谁念西风独自凉》</p>

</blockquote>



<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>网站分享</tag>
        <tag>信息检索</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于QT的学习网站</title>
    <url>/posts/10222.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/phone_bg1-b8769697a0.jpg"></p>
<p>　　</p>
<center> 一些有关 QT 的学习网站  💻 <center/>

<span id="more"></span>







<ul>
<li><a href="https://www.qt.io/">Qt 官网</a><br><a href="https://www.qt.io/">https://www.qt.io</a><br>了解Qt最新资讯开发动态的窗口。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160240200.png"></p>
<br/>

<ul>
<li><a href="http://download.qt.io/">Qt 资源下载</a><br><a href="https://download.qt.io/">http://download.qt.io</a><br>最新Qt安装程序可以在这里找到。当然也可以去一些国内的镜像中下载，比如 Tuna 。<a href="https://www.lifeee.top/posts/qt_abandon.html">安装步骤看这里</a>。😇</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160309041.png"></p>
<br/>

<ul>
<li><a href="http://planet.qt.io/">Qt 博客者聚集地</a><br><a href="http://planet.qt.io/">http://planet.qt.io</a><br>很多Qt大神都在里面。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160624453.png"></p>
<br/>

<ul>
<li><p><a href="https://wiki.qt.io/">Qt 百科</a><br><a href="https://wiki.qt.io/">https://wiki.qt.io</a><br>这里Qt社区收集了多年来关于Qt的信息。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160701075.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://doc.qt.io/">Qt 文档</a><br><a href="https://doc.qt.io/">https://doc.qt.io</a><br>在线版的帮助文档。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160727895.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://forum.qt.io/">Qt 论坛</a><br><a href="https://forum.qt.io/">https://forum.qt.io</a><br>从桌面和移动到云，游戏，工具，第三方库，兴趣小组。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160759152.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://bugreports.qt.io/">Qt 提交Bugs</a><br><a href="https://bugreports.qt.io/">https://bugreports.qt.io</a><br>提交Bug前先搜索下Bug是否已经存在。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160842640.png"></p>
</li>
</ul>
<br/>

<ul>
<li><a href="https://doc.qt.io/qt-5/qtexamples.html">Qt 官方示例</a><br><a href="https://doc.qt.io/qt-5/qtexamples.html">https://doc.qt.io/qt-5/qtexamples.html</a><br>图文并茂的官方示例。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160914591.png"></p>
<br/>

<ul>
<li><p><a href="https://inqlude.org/">Qt 第三方库聚合</a><br><a href="https://inqlude.org/">https://inqlude.org</a><br>如QCustomPlot，QJson，Log4Qt。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916160952579.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="http://www.qtcentre.org/">QtCentre</a><br><a href="http://www.qtcentre.org/">http://www.qtcentre.org</a><br>访问较慢且上面的信息很久没更新了，倒是提问题或找解决问题挺有用的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161028362.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://bbs.csdn.net/forums/Qt">CSDN Qt 论坛</a><br><a href="https://bbs.csdn.net/forums/Qt">https://bbs.csdn.net/forums/Qt</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161101377.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="http://www.qtcn.org/">QTCN网</a><br><a href="http://www.qtcn.org/">http://www.qtcn.org</a><br>上面有很多开源作品。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161132340.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="http://www.qter.org/">Qt中文开源社区</a><br><a href="http://www.qter.org/">http://www.qter.org</a><br>教程论坛文章俱全。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161156401.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://stackoverflow.com/">问答论坛stackoverflow</a><br><a href="https://stackoverflow.com/">https://stackoverflow.com</a><br>提问题(网友较热心)或找问题不限于Qt且大多都可以找到。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161358154.png"></p>
</li>
</ul>
<br/>

<ul>
<li><p><a href="https://www.bilibili.com/">B站视频教程</a><br><a href="https://www.bilibili.com/">https://www.bilibili.com</a><br>想看视频教程学习是个不错的地方。</p>
<br/>
</li>
<li><p><a href="https://www.youtube.com/">YouTube视频教程</a></p>
<p><a href="https://www.youtube.com/">https://www.youtube.com/</a></p>
<p>这里有很多国内没有的教程视频，随便一搜就有很多。</p>
</li>
</ul>
<br/>

<ul>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN">书籍教程</a><br><a href="https://github.com/justjavac/free-programming-books-zh_CN">https://github.com/justjavac/free-programming-books-zh_CN</a><br>免费的编程中文书籍索引。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916161436347.png"></p>
<br/>



<blockquote>
<p>reference：<a href="https://zhuanlan.zhihu.com/p/77638176">https://zhuanlan.zhihu.com/p/77638176</a></p>
</blockquote>
<br/>

<br/>

<br/>



<blockquote class="blockquote-center">
<p>秋风起兮白云飞，草木黄落兮雁南归。</p>
<p>— 刘彻《秋风辞》</p>

</blockquote>



<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>网站分享</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你为PDF添加书签目录</title>
    <url>/posts/47067.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/pexels-fox-212323_compressed.jpg"></p>
<p>　　无论在工作中还是学习中我们都会常常与PDF文档相伴，而有一些PDF文档却没有目录，这就很烦恼啦。所以我们需要为这些PDF添加上目录方便阅读的时候点击目录跳转。通过本文我会手把手教你为PDF文档添加目录，继续阅读下去吧。 💡</p>
<span id="more"></span>



<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>　　首先，看一下制作目录前的文件，既不是 True PDF 也没有目录 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618095826876.png"></p>
<p>　　我们需要用到<a href="https://www.cnblogs.com/stronghorse/p/4913182.html">老马的原创空间</a> 出品的一款软件— PdgCntEditor 。可以在下面两个链接中选择一个链接进行下载。</p>
<ul>
<li><p><a href="https://www.lanzous.com/ifJ8yds7ide">https://www.lanzous.com/ifJ8yds7ide</a></p>
</li>
<li><p>链接：<a href="https://pan.baidu.com/s/1BC0JTOACnfePv8LokD5GCg">https://pan.baidu.com/s/1BC0JTOACnfePv8LokD5GCg</a><br>提取码：tyor</p>
</li>
</ul>
<p>　　软件长这个样子：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200916164541225.png"></p>
<br/>

<h2 id="收集目录"><a href="#收集目录" class="headerlink" title="收集目录"></a>收集目录</h2><p>　　制作目录前需要收集目录，然后才能将目录挂到PDF上。一般可以在以下途径获取到目录：</p>
<table>
<thead>
<tr>
<th>序列</th>
<th>途径</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>书籍网上商城</td>
<td>京东，亚马逊，当当，中国图书网</td>
</tr>
<tr>
<td>b</td>
<td>pdf 上直接拷贝</td>
<td>PDF 不能是图片格式的页面（即：文字可直接拷贝）</td>
</tr>
<tr>
<td>c</td>
<td>OCR 文字识别技术</td>
<td>区域识别并保持排版格式的，笔者只用过 Adobe Acrobat</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>　　比如在京东找到了我需要的目录，将其复制粘贴到TXT中，留着后续用。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618100229305.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618100252227.png"></p>
<br/>

<h2 id="目录制作"><a href="#目录制作" class="headerlink" title="目录制作"></a>目录制作</h2><p>　　打开 PdgCntEditor ，然后打开 PDF ，将TXT中的目录复制粘贴到 PdgCntEditor 中。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618100622364.png" alt="打开PDF"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618100707174.png" alt="粘贴目录进来"></p>
<p>　　若目录中存在很多点，需要将其去除掉。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618101114971.png" alt="有很多点点"></p>
<p>　　可以在windows中的记事本替换。也可以使用 PdgCntEditor 中的替换和正则表达式替换，见下图的①和②。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618101628966.png"></p>
<p>　　如下图步骤，点击①替换，输入<code>..</code> ，然后多点几次全部替换，直到目录后绝大多数<code>.</code> 消失。为什么不替换<code>.</code> 呢 ，因为会把各个小节的点也替换了，比如 1.1.2 会变成 112 ，而替换两个点就不会了。虽然最后可能会残留一个点，但这样操作快一点。正则表达式就能够完全替换了，需要一定难度。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618103114801.png"></p>
<p>　　记事本替换如下图</p>
<p>　　按 Ctrl + H </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618103217002.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618103240534.png"></p>
<p>　　若无点，继续下面的操作</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618101324769.png" alt="去除点后的目录"></p>
<p>　　Ctrl +A 全选后，点击自动缩进① 自动生成书签树，完成层级关系的整理。</p>
<p>然后点击图示按钮</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618103451831.png"></p>
<p>　　这个时候，虽然看似每一行的末尾都制定了页码，但如果页码不是制表符分隔的情况下实际上是无效的，也就是点击了书签跳转不过去，我们继续全选这些书签数据，点击图示按钮自动切分页码。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618103639247.png"></p>
<p>　　由于点击后只是做了空白字符之间的替换操作，看不到很明显的效果。没什么变化，不必惊慌。</p>
<br/>

<h2 id="页码偏移处理"><a href="#页码偏移处理" class="headerlink" title="页码偏移处理"></a>页码偏移处理</h2><p>　　若直接保存的话，也能生出书签，但是书签可能存在偏移。目录与真实的页码对应不上。因此需要设置偏移，偏移量视你的PDF而定。比如我的是37,因为书本的第一页对应着PDF中的37页。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618104034968.png"></p>
<p>　　找到偏移量大小和，就可以设置了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618104141829.png" alt="一图胜千言"></p>
<br/>

<h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>　　偏移量设置完毕后点击保存。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618104425582.png"></p>
<p>　　然后就有目录了，点哪跳哪。要是你的偏移量有问题的话，可以多试几次，算一下偏移页面，然后重新生成。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618104722059.png"></p>
<br/>

<h2 id="添加封面"><a href="#添加封面" class="headerlink" title="添加封面"></a>添加封面</h2><p>　　若需要增加其它页面的目录，比如封面，目录。那就可以手动操作了。在书签源数据中，页码用负数表示，具体数据呢，自己向前数下页码就行。比如目录需要向前4页，那就写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录	-4</span><br></pre></td></tr></table></figure>

<br/>

<div class="note info"><p>Notice： 目录文字与页码数字之间用 <code>Tab </code> 分割，按一下即可，然后在点击一下保存。</p>
</div>

<br/>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618105551508.png" alt="添加了封面与目录页"></p>
<br/>

<h2 id="删除-提取目录"><a href="#删除-提取目录" class="headerlink" title="删除&#x2F;提取目录"></a>删除&#x2F;提取目录</h2><p>　　下载FreePic2Pdf 这个软件，下载链接为:</p>
<p><a href="https://www.lanzous.com/inV9wds8gyj">https://www.lanzous.com/inV9wds8gyj</a></p>
<p>打开 FreePic2Pdf.exe ，点击更改 PDF。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200730210441067.png"></p>
<p>　　选择从PDF中取出书签，然后打开PDF，点击开始即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618112535064.png"></p>
<p>　　这样就删除了PDF中原有的书签目录（即将目录从PDF中提取出来了），提取出的书签目录见下图。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200618112711519.png"></p>
<br/>

<br/>

<br/>

<br/>

<blockquote class="blockquote-center">
<p>满载一船秋色，平铺十里湖光。</p>
<p>— 张孝祥《西江月·阻风山峰下》</p>

</blockquote>



<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>文档/文件关键词内容搜索</title>
    <url>/posts/36171.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/pexels-cottonbro-4855385_compressed.jpg"></p>
<p>大家都知道要想快速的搜索文件可以使用 <a href="https://www.voidtools.com/zh-cn/">Everything</a> ，然而要想搜索文档文件中的内容  Everything 却做不到，那么搜索文档内容该怎么办呢？AnyTXT Searcher 和  BBdoc  是两款搜索文档内容的软件。🔍</p>
<span id="more"></span>



<br />



<h2 id="AnyTXT-Searcher"><a href="#AnyTXT-Searcher" class="headerlink" title="AnyTXT Searcher"></a>AnyTXT Searcher</h2><p>下载地址： <a href="https://anytxt.net/">https://anytxt.net/</a></p>
<p>AnyTXT Searcher　是一款带有强大全文搜索引擎的桌面搜索工具。</p>
<p>AnyTXT Searcher  有一个内置的强大的文档解析引擎，它可以在不安装任何其他软件的情况下提取常用文档的文本，并结合内置的高速索引系统来存储文本的元数据。使用  AnyTXT 搜索器，可以快速查找计算机上存在的任何文字。它在 Windows  10,8,7，Vista，XP，2008,2012,2016等操作系统上运行良好。</p>
<p>支持的格式</p>
<ul>
<li>Plain Text Format (txt, cpp, html, etc.) 纯文本格式(txt、 cpp、 html 等)</li>
<li>Microsoft Outlook (eml) Microsoftoutlook (eml)</li>
<li>Microsoft Word (doc, docx) Microsoftword (doc，docx)</li>
<li>Microsoft Excel (xls, xlsx) Microsoftexcel (xls，xlsx)</li>
<li>Microsoft PowerPoint (ppt, pptx) Microsoft PowerPoint (ppt，ppt)</li>
<li>Portable Document Format (pdf) (beta) 便携式文件格式(pdf)(beta)</li>
<li>eBook Formats(mobi, epub, etc.) 电子书格式(mobi、 epub 等)</li>
</ul>
<p><strong>也可以新增其它格式。</strong></p>
<p>首次安装后会需要一定的时间进行本地数据库的构建，过一会我们就可以进行搜索了。</p>
<p>以搜索“多载波”为例，在①中输入要搜索的关键词或者句子，在②中可以只能要搜索哪一个磁盘，在③中可以指定文件类型，然后点击④即可以开始搜索。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018192214838.png" alt="搜索示例"></p>
<p>缩小检索的磁盘为　Ｄ盘。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018192510993.png" alt="指定磁盘路径"></p>
<p>再缩小检索的文件类型为　docx 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018192631143.png" alt="指定类型"></p>
<p>若没有想要的文件类型，可以新增一个，比如 新增一个 .cpp</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018192741383.png" alt="新增"></p>
<p>选择添加文件类型。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018192845388.png" alt="文件类型"></p>
<p>然后选择一个 CPP文件，在下面的弹窗中选择 所以文件将被包含。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018193105424.png"></p>
<p>以后就可以搜索CPP文件的关键词啦。</p>
<br/>

 

<h2 id="BBdoc-文档搜索"><a href="#BBdoc-文档搜索" class="headerlink" title="BBdoc 文档搜索"></a>BBdoc 文档搜索</h2><p>下载地址： <a href="http://www.bbdoc.cn/">http://www.bbdoc.cn/</a></p>
<p>bbdoc 是一款可以搜索文档内容的小软件。</p>
<ul>
<li>支持文件名，文档内容快速搜索，</li>
<li>支持文件类型、文件修改时间筛选</li>
</ul>
<p>下载后，解压并运行 bbdoc.exe 即可使用。首次开启，bbdoc 先会花一段时间来建立索引。在搜索框中输入你想要搜的内容，然后按下回车键，所有内含相关字段的文档，都被被罗列出来。当然也可以指定搜索文档的类型，一般得办公文件的类型都支持。缺点是其<strong>不支持新增文件类型</strong>。</p>
<p>软件主要功能介绍：</p>
<p>1、支持按照文档类型搜索，目前支持word、pdf、Excel、压缩文件、csv、wps、txt等，针对图片、音视频、html等文件搜索会升级上来，更方便查询管理。</p>
<p>2、支持按照文件大小搜索，也支持按照文件大小排序。</p>
<p>3、支持按照文档修改或创建时间段查询，也支持按照日期排序。</p>
<p>4、支持按照文件名关键词搜索。</p>
<p>5、支持按照文档内容快速搜索，升级会增加2-3个关键词组合搜索。</p>
<p>6、搜索结果支持：1）直接打开文档内容 2）直接进入文档所在目录 3）支持查看文档内容搜索快照预览。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018194148992.png" alt="仅搜索文档内容"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201018194300480.png" alt="同时搜索文档名称以及文档内容"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>使用 AnyTXT Searcher 似乎搜索的内容比 BBdoc 文档搜索 更齐全一些。</li>
<li>使用 AnyTXT Searcher 可以自定义文档类型（文档后缀）。</li>
<li>BBdoc 文档搜索 UI漂亮一些。</li>
</ol>
<br/>

<br/>

<br/>

<blockquote class="blockquote-center">
<p>秋雨一何碧，山色倚晴空。</p>
<p>– 水调歌头·平山堂用东坡韵</p>

</blockquote>

<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>网页关键字自动高亮，网页高亮批注，保存网页为单文件--浏览器拓展推荐</title>
    <url>/posts/33359.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb1ucpm60j21040o2wos.jpg"></p>
<p>　　在阅读英文网页或者中文网页时，有时候因为文字排版太密集了，难以一眼找到自己需要关注的一些关键字；在 IEEE 在线阅读时，一下子找不到关注的重点；需要高亮一段文字又要怎么办；高亮了需要保存网页为一个单文件又该怎么办？其实通过下面几个浏览器拓展就可以轻松解决这些问题，感兴趣的话继续看下去吧。😛</p>
<span id="more"></span>

<h2 id="关键字自动高亮解决方案"><a href="#关键字自动高亮解决方案" class="headerlink" title="关键字自动高亮解决方案"></a>关键字自动高亮解决方案</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　关键字自动高亮指的是对于一些我们设定好的关键字能够在打开网页后就自动高亮，以不同颜色进行区分，让人一目了然，毕竟人眼对颜色是很敏感的。主要应用在科研工作者们进行文献调研时，提高阅读效率。比如下面这样🔎</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glaxpkee9zj217f0ofq8i.jpg" alt="搜索时"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glapy2earrj21bm0q3wp2.jpg" alt="阅读时"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>　　要实现上面的效果我们需要用到一款名为 Multi-highlight 的浏览器拓展，在新版的 Edge 以及 Chrome 浏览器都可使用，当然我更建议使用 Edge ，因为真的很好用。🎁</p>
<p>其下载地址为：</p>
<p>可在<a href="https://chrome.google.com/webstore/detail/multi-highlight/pfgfgjlejbbpfmcfjhdmikihihddeeji">Multi-highlight - Chrome 网上应用店 (google.com)</a> 直接安装，网络通畅的话。</p>
<p>本来是推荐在<a href="https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home?hl=zh-CN">Microsoft Edge 拓展商店</a> 下载，但是这款拓展似乎还没上架，其它拓展可以推荐在Edge拓展商店下载。</p>
<p>若网络不可达的同学也可在国内的 <a href="https://www.extfans.com/">扩展迷</a> 下载。</p>
<p>当然也可以在云盘直接下载因为我已经下载并上传好了，贴心的我😅</p>
<p>下载地址： <a href="https://yours.lanzous.com/b064k5u3e">https://yours.lanzous.com/b064k5u3e</a> 提取码：wang</p>
<p>下载好后其中后缀为<code>crx</code>的文件就是接下来需要用到的安装文件 。</p>
<p>安装方法为：</p>
<p>Edge 浏览器打开 <a href="edge://extensions/">edge:&#x2F;&#x2F;extensions&#x2F;</a></p>
<p>Chrome浏览器打开 <a href="Chrome://extensions/">Chrome:&#x2F;&#x2F;extensions&#x2F;</a></p>
<p>然后打开开发者模式</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glayhm84l0j216z0r3gqj.jpg" alt="打开开发模式"></p>
<p>将 <code>multi-highlight.crx</code> 拖拽到上面这个页面即可安装好。</p>
<br />

<h4 id="关键词设置"><a href="#关键词设置" class="headerlink" title="关键词设置"></a>关键词设置</h4><p>　　拖拽后就安装好了，右上角有一个黄色的 <strong>M</strong> 标志，这个就是 Multi-highlight 。起初安装后如下图所示，是什么关键字也没设置的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glayjk2ot7j20gp08g3ze.jpg" alt="安装后"></p>
<p>　　然后设置想要自动高亮的关键字，比如设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">估计 检测 频率偏移 定时 OFDM 信道 channel pilot 信号 signal</span><br></pre></td></tr></table></figure>

<p>　　中间用空格分开，用回车也可😍，<strong>中英文</strong>关键字都支持哦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20201203205512275.png" alt="设置关键字"></p>
<p>　　要是想暂停高亮的话，点一下开关就好了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201203153326496.png" alt="我关闭啦"></p>
<br />

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>然后就是去享受就好啦。😋😋😋</p>
<p>没有设置关键字之前是这样的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glaynzxc9xj215b0nrgqk.jpg" alt="未设置"></p>
<p>　　<br/></p>
<p>　　设置后是下面这样的。很明显能够一下子捕获自己关注的点。尤其是在阅读很长的文章的时候，能让我们顿时神清气爽，废寝忘食，一生只爱学习。🤤</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glayrkr29dj215x0o8dl6.jpg" alt="已设置关键字"></p>
<p>　　<br/></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glayy5dg7cj21f20q3tf0.jpg" alt="使用示例"></p>
<p>　　<br/></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glapaj4mppj210j0ltteh.jpg" alt="在线阅读文献时"></p>
<br />

<p>　　<br/></p>
<h2 id="高亮批注解决方案"><a href="#高亮批注解决方案" class="headerlink" title="高亮批注解决方案"></a>高亮批注解决方案</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　高亮批注指的是能够以一些高亮的颜色批注网页或者PDF。主要是对一些重要的句子进行标注，方便日后查阅能够一眼就能看到。💡</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glaze935c8j21cc0q3449.jpg" alt="示例"></p>
<p>　　<br/></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>　　要实现上面的效果我们需要用到一款名为<a href="https://chrome.google.com/webstore/detail/weava-highlighter-pdf-web/cbnaodkpfinfiipjblikofhlhlcickei">Weava Highlighter - PDF &amp; Web )</a>的浏览器拓展，在新版的Egde以及Chrome浏览器都可使用。这款拓展除了能不但能高亮句子，而且还能将高亮的句子帮你储存起来。其还能高亮PDF ，当然我很建议使用专业的PDF阅读软件进行标注。题外话PDF软件很推荐PDF-XChange Editor。</p>
<p>其官方的宣传视频可在 YOuTube上查看，地址为 <a href="https://youtu.be/K4THlgVyNJc">https://youtu.be/K4THlgVyNJc</a></p>
<iframe width="640" height="400" src="https://www.youtube.com/embed/K4THlgVyNJc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<p>官方介绍为（机翻）</p>
<blockquote>
<p>网站和PDF的最佳突出显示工具。免费易用。</p>
<p>使用Weava Online Web&amp;PDF荧光笔突出显示和组织您的研究。</p>
<p>简化您的研究过程。把重点放在生产力上。不要将时间浪费在跟踪来源、复制和粘贴或引用上。平均而言，我们的用户报告Weava帮助他们每周节省3.8小时以上。相反，你可以花很多时间在对你真正重要的事情上。</p>
<p>借助WEAVA，您可以：</p>
<p>➤使用多种颜色突出显示网站和PDF，并添加批注。只需单击一下即可重新访问它们。</p>
<p>➤将您的亮点组织到文件夹和子文件夹中。</p>
<p>➤自动为您的亮点创建引文。</p>
<p>➤随时随地访问您的亮点。您的高光和笔记将保存在云中。</p>
</blockquote>
<p>其下载地址为：</p>
<p>可在<a href="https://chrome.google.com/webstore/detail/weava-highlighter-pdf-web/cbnaodkpfinfiipjblikofhlhlcickei">Weava Highlighter - PDF &amp; Web - Chrome 网上应用店 (google.com)</a>直接安装，网络通畅的话。</p>
<p>当然也可以在云盘直接下载因为我已经下载并上传好了。</p>
<p>下载地址： <a href="https://yours.lanzous.com/b064k5u3e">https://yours.lanzous.com/b064k5u3e</a> 提取码：wang</p>
<p>安装方法如本文前半部分所述。</p>
<p>　　<br/></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装好浏览器多了这么一个图标👇</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glaznuxz4rj20il0bigmt.jpg" alt="image"></p>
<p>然后点击一下，会提示你进行登录或者注册。</p>
<p>由于我的已经登录过了，因此出现的是一些我曾经高亮过的句子。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glazs2iwqjj21h40rih72.jpg" alt="image"></p>
<p>　　使用很简单，用下面一张图就能说清楚了，选中想要高亮的句子，然后就会出现不同颜色了，选择一种即可实现高亮。若想要更改其它颜色似乎要让开会员，好吧，够用就行了，没有必要花这个钱了，除非你是重度用户。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glaqn0li53j20xp1ciaui.jpg" alt="使用示例"></p>
<p>　　　　<br/></p>
<p>　　以后只要在浏览器点  Weava Highlighter的图标就能看见近期勾画过的重点了，也可在其网站<a href="https://www.weavatools.com/app/dashboard">Weava: Organize your Research (weavatools.com)</a> 进行查看。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20201203213935855.png" alt="曾经爱过，不，曾经高亮过"></p>
<p>　　其实高亮可以配合下面一款拓展使用体验更好，下面就介绍一款我很中意的拓展，能够将网页原封不动的保存下来。</p>
<p>　　<br/></p>
<p>　　<br/></p>
<h2 id="网页另存为单文件"><a href="#网页另存为单文件" class="headerlink" title="网页另存为单文件"></a>网页另存为单文件</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　小伙伴们都知道在网页中按下 <code>Ctrl+S</code> 就能保存当前的网页了，然后其存储方式是html和资源文件分离的。存储、移动或者分享给其他人都不是很方便。网页另存为单文件是指存储为一个单文件，资源文件嵌在html当中。🌻</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb04jms99j21df0pf17f.jpg" alt="拓展主页"></p>
<p>　　<br/></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>　　要实现上面的效果我们需要用到一款名为<a href="https://microsoftedge.microsoft.com/addons/detail/singlefile/efnbkdcfmcmnhlkaijjjmhjjgladedno">SingleFile </a>的浏览器拓展，在新版的Egde、Firefox 、Chrome浏览器都可使用。这款拓展不但能将网页另存为单文件，而且还支持先批注再存储哦。</p>
<p>其下载地址为：</p>
<p>可在<a href="https://microsoftedge.microsoft.com/addons/detail/singlefile/efnbkdcfmcmnhlkaijjjmhjjgladedno">SingleFile - Microsoft Edge Addons </a> 或者 <a href="https://chrome.google.com/webstore/detail/singlefile/mpiodijhokgodhhofbcjdecpffjipkle">SingleFile - Chrome 网上应用店</a>  直接安装。建议直接在Edge安装就好啦。</p>
<p>当然也可以在云盘直接下载因为我已经下载并上传好了。</p>
<p>下载地址： <a href="https://yours.lanzous.com/b064k5u3e">https://yours.lanzous.com/b064k5u3e</a> 提取码：wang</p>
<p>安装方法如本文前半部分所述。</p>
<p>安装好后如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0brknvuj20hv0bf754.jpg" alt="安装好啦"></p>
<p>　　<br/></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>　　使用分为直接保存以及批注后保存，首先介绍直接保存。要想直接保存当前网页为单文件的话，直接点击一下  SingleFile 的图标就好啦，或者在网页中右击然后找到 SingleFile 点击使用 SingleFile 保存页面，然后会过几秒钟就下载成功了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0gjwsnhj219z0qvtmk.jpg" alt="image"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0k17h6nj20rt0db0xm.jpg" alt="保存好的网页"></p>
<p>　　默认会使用网页的标题命名，若需要自己手动命名，可在设置中打开保存前自动命名，我就不演示了。</p>
<p>演示一下先批注后保存</p>
<p><strong>右击一下</strong> SingleFile ，然后选择标注并保存该页面。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0n85q0nj21b90nrduh.jpg" alt="标注并保存该页面"></p>
<p>　　几秒钟后出现了一个新的页面，在这个页面进行一下标注然后保存即可。标注的话支持几种常见的颜色进行高亮以及便利贴进行标注，并且标注后的离线文件中同样可以看见标注的内容哦。</p>
<p>下面是一个使用示例，标注后点击下图中的①即可保存到本地。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0s6lzzrj21i00q3dm6.jpg" alt="标注后保存"></p>
<p>　　还记得本文介绍的第二个拓展 Weava Highlighter 吗？ 我们用 Weava Highlighter 高亮了一些句子后使用 SingleFile 进行保存的话，那些高亮的句子也能保存哦。举个栗子🥜</p>
<p>使用 Weava Highlighter 高亮后的网页：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0x4zgnuj21i00q3dli.jpg" alt="在线网页"></p>
<p>使用 SingleFile 保存到本地的网页：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb0yuvviaj21i00se0zv.jpg" alt="本地网页"></p>
<p>　　两个页面没差别吧，哈哈。😎</p>
<p>　　高亮后的保存的本地的网页再拖入到 Zotero 这岂不是美滋滋，这才是正确的文献管理，哈哈，以后可以很方便的关联与某篇文献相关的内容啦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1glb12i8zs6j21480p3tt6.jpg" alt="Zotero"></p>
<p>　　<br/></p>
<p>　　<br/></p>
<p>　　本文到此就结束啦，有建议或者疑问可在下方登录 Github 账号进行留言. </p>
<center><font size=4.5>😋 Peace </center>



<p>　　<br/></p>
<p>　　<br/></p>
<p>　　<br/></p>
<blockquote class="blockquote-center">
<p>晚来天欲雪，能饮一杯无？</p>
<p>– 白居易</p>

</blockquote>



<p>　　<br/>　　<br/>　　<br/></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>浏览器拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>5G高频段信道测量与建模进展</title>
    <url>/posts/25652.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210210181608.jpg"></p>
<p>高频段拥有丰富空闲频谱资源，可有效满足未来 5G 对更高容量和速率的需求，用于传输高达 10Gbps 甚至更高的用户数据速率业务。高频段同时具有较大的传播损耗、散射损耗和准光学特性。 因此，有必要对高频段信道进行建模研究及测量。本文为高频段信道的调研报告。</p>
<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>研究高频段信道传播特征，获得信道模型，分析和评估使用场景，以及选择适用频段，是当前高频段的首要工作。针对高频段的信道测量和建模工作也已展，如10~11、28、38、43~50、56~76和81<del>86 GHz等一些重点频段，路损、阴影衰落、时延扩展（Delay Spread ,DS）、角度扩展（Angular Spread，AS）及极化等信道特征，以及它们随场景和频率的变化规律等成为研究的关键内容．几个高频段信道模型陆续被发布，如IEEE 802.11ad、METIS、MIWEBA、NYU、5GCM、3GPP-HF(high-frequency,6</del>100GHz)等。</p>
<br />

<h2 id="二、５G高频段信道建模的需求与挑战"><a href="#二、５G高频段信道建模的需求与挑战" class="headerlink" title="二、５Ｇ高频段信道建模的需求与挑战"></a>二、５Ｇ高频段信道建模的需求与挑战</h2><p>高频段信道具有许多明显不同于6GHz以下蜂窝移动通信信道的特征．开发新的可工作在高频段（直到100GHz）的5G系统，需要这些频段的精确传播模型，显然现有的为6GHz以下频段开发的信道模型无法胜任．相比传统信道模型，5G高频段信道模型应支持更宽的频率范围、更大的频带宽度和更大的天线孔径，并保持在空间、时间、频率和天线四个维度的一致性，具体体现在以下几个方面:</p>
<ul>
<li><p>支持广泛的传播场景及空间一致性</p>
</li>
<li><p>支持更高的带宽和频率一致性</p>
</li>
<li><p>支持大规模天线阵列（极窄波束）及天线一致性</p>
</li>
<li><p>支持高速移动及双向移动</p>
<br /></li>
</ul>
<h2 id="三、信道建模方法"><a href="#三、信道建模方法" class="headerlink" title="三、信道建模方法"></a>三、信道建模方法</h2><p>信道模型通常将信道参数分为宏观参量（如路损和阴影衰落）和反映信道衰落特性的微观参量，如大尺度参数和小尺度参数（Small-Scale Parameters,SSPs，包括时延、功率、到达角和离开角等）。</p>
<p>3.1 路损与阴影衰落模型</p>
<p>$$<br>P L(\mathrm{~dB})&#x3D;20 \log _{10}(4 \pi f &#x2F; c)+10 n \log <em>{10}(d &#x2F; 1 m)+X</em>{\sigma} \qquad（1）<br>$$<br>Friis公式给出了自由空间中信号视距传播模型，在实际的信道环境中，通过引入随环境而改变的路损指数ｎ，构造出一个更为普遍的路损模型．对于6GHz以下频段，往往忽略频率的影响，而高频段就不能忽略了，一个常用的路损模型为：</p>
<p>$$<br>P L(\mathrm{~dB})&#x3D;20 \alpha \log _{10}(d)+\beta+10 \gamma \log <em>{10}(f)+X</em>{\sigma}\qquad（2）<br>$$</p>
<p>该式称为ABG模型（因三个系数记为Alpha-Beta-Gamma而得名），是对FI(Floating Interceoe)模型的扩展以反映频率影响．这里ｆ常以GHz计量。</p>
<br />

<p>3.2 GSCM模型结构<br>GSMＭ模型中的传播路径采用簇与射线结构表示，如图１所示．．通过几何关系，将具有不同小尺度参数的射线（平面波）叠加得到，包含链路两端（基站和终端）的天线阵列和传播路径的３D MIMO信道，其中发射单元ｓ到接收天线单元ｕ之间的子信道 可表示为：</p>
<p>$$<br>\begin{aligned}<br>&amp;\mathbf{H}<em>{u</em>{s s}}(t ; \tau)&#x3D;\<br>&amp;\sum_{n&#x3D;1}^{N} \sum_{m&#x3D;1}^{M_{n}}\left[\begin{array}{l}<br>F_{r, u, \theta}\left(\boldsymbol{\Omega}<em>{r, n, m}\right) \<br>F</em>{r, u, \varphi}\left(\boldsymbol{\Omega}<em>{r, n, m}\right)<br>\end{array}\right]^{\mathrm{T}}\left[\begin{array}{ll}<br>\alpha</em>{n, m}^{\theta \theta} &amp; \boldsymbol{\alpha}<em>{n, m}^{\theta \varphi} \<br>\alpha</em>{n, m}^{\varphi \theta} &amp; \alpha_{n, m}^{\varphi \varphi}<br>\end{array}\right]\left[\begin{array}{l}<br>F_{t, s, \theta}\left(\boldsymbol{\Omega}<em>{t, s, m}\right) \<br>F</em>{t, s, \varphi}\left(\boldsymbol{\Omega}<em>{t, n, m}\right)<br>\end{array}\right]\<br>&amp;\cdot \mathrm{e}^{\mathrm{j} 2 \pi\left(\Omega</em>{t, n} \cdot d_{s}, \omega\right) &#x2F; \lambda} \mathrm{e}^{j 2 \pi\left(\Omega_{n, n} \cdot d_{m}\right) &#x2F; \lambda} \mathrm{e}^{j 2 \pi v_{n}, t} \delta\left(\tau-\tau_{n, m}\right)<br>\end{aligned}<br>$$<br><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210210185348.png"></p>
<blockquote>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210210123525011.png" alt="图 1 GBSM信道模型中的簇与射线图"></p>
<br />

<p>通过合理的参数化，GSCM可以比较准确地、灵活地描述不同的场景和不同的天线类型．信道中的簇和射线由路损、阴影衰落和大小尺度衰落共同描述．为了更加准确反映实际情况，模型也考虑站内不同LSPs参数的相关性和不同站间同一LSPs的相关性（与站点的几何关系有关）．簇参数（数目、到达率、功率衰减指数、角度扩展）和簇内射线参数（到达率、平均到达时间、功率衰减率等）是模型的重要参数，现有的GSCM模型通常假设簇和簇内射线数目固定，簇时延间隔服从指数分布，簇功率随时延指数衰减，簇角度服从卷绕高斯或Laplacian分布，（子）簇内射线具有相同的时延、功率和不同的角度．ＳＶ模型同样采用簇和射线概念，区别是簇数及簇内射线数不固定，服从泊松分布，簇角度多采用ＲＴ方法获得；簇内射线时延间隔服从指数分布，功率随时延呈指数衰减，角度服从高斯分布。</p>
<br />

<h2 id="三、信道探测系统"><a href="#三、信道探测系统" class="headerlink" title="三、信道探测系统"></a>三、信道探测系统</h2><p>信道测量（信道探测）是以提取信道参数为主要目标的研究活动，能够为信道建模提供真实的测量数据，并作为验证模型有效性和合理性的有力工具，所有的信道模型都离不开信道测量。<br>在这些测量活动中主要使用了两类信道探测器：<br>基于矢量网络分析仪（VNA）的信道测量系统和针对特定频率所设计的宽带探测系统。前者将整个探测频段分为若干频点，在每个频点使用单频信号探测，依次扫描所有频点，其频率和带宽仅受限于VNA的能力，具有较大的灵活性，但扫频测量速度慢，且需要使用长电缆（或光缆）共享收发两端的本振来保证每个频点频率和相位的一致性，因此不适合远距离或动态场景测量．后者采用定制射频单元，频率固定，带宽为几百MHz到１GHz，常采用PN、Chirp、Zadoff-Chu或OFDM信号等宽带探测序列，收发两端通常使用GPS驯<br>服的恒温晶振或原子钟（铷钟、铯钟）来保持同步．这种方案能够提高频率维度的测量速度，但测量频宽有限．从硬件成本和校准成本考虑，除了少数的一发几收结构和多发多收结构外，多数系统都采用一个射频单元．<br>因为高频段信号有较大的传播损耗，为保证系统动态范围，探测天线主要采用：<br>（１）高增益方向天线，由于此类天线具有较窄波瓣角度，只能保证一定角度内的信号探测，需要旋转来实现全立体空间扫描，导致空间扫描周期较长，很难对时变信道进行空时联合测量；<br>（２）低增益或全向天线，通过平移构成线阵、面阵或立体阵等虚拟天线阵，由阵列处理增益来保证高信噪比，这种方式同样存在扫描周期较长的问题；</p>
<p>（３）电控毫米波天线阵列，这种模块化天线阵可以通过电子控制在空间形成不同方向的扫描波束，能够提高扫描速度，但这种方式，需测量和保存大量的天线辐射模式数据．</p>
<br />

<h2 id="四、现有的信道模型"><a href="#四、现有的信道模型" class="headerlink" title="四、现有的信道模型"></a>四、现有的信道模型</h2><p><strong>IEEE信道模型</strong><br>IEEE802.15.3ｃ是IEEE802.15（ＷＰＡＮ）工作组推出的世界上首个60GHz信道模型，它将传统的SV模型进行了扩展以支持到达方位角，是一个单端二维（２Ｄ）信道模型．它针对从起居室、办公室、图书馆、会议室、桌面到走廊６个场景的LOS和NLOS条件，建立了１０个信道模型CM1～CM10模型。</p>
<p>IEEE802.11ad信道模型是为超高数据速率60GHz WLAN系统所建议的双端３Ｄ信道模型，它基于扩展SV模型，支持三种室内环境的接入和D2D应用。</p>
<p><strong>MiWEBA信道模型</strong><br>MiWEBA是一个致力于毫米波通信推广与应用的研究项目，主要参与单位包括Fraunhofer HHI，IMC以及日本、法国的几所大学和研究所．其中第五工作组专注于传播与天线，于２０１４年６月推出第一版毫米波段信模型．该模型支持57~66ＧＨｚ频段的室内和室外三种场景，包括开阔地（校园）、城市街区和旅馆大厅，每种场景都支持三种链路类型，即接入、前传／后传和D2D．采用测量和射线追踪建模方法，信道由视距和少数几条反射路径（统称为Quasi-Deteministic,Q-DＱ射线），再加上数个随机射线簇（Ｒ射线）组成．</p>
<p><strong>METIS信道模型</strong><br>METIS项目提出了灵活可扩展的信道建模框架，以满足不同精度和计算复杂度的要求，以期胜任５Ｇ技术研发．整个信道模型包括图谱（Mapbased）信道模型、随机信道模型或者两者混合建模．图谱模型基于射线追踪，使用简化的三维几何模型来描述包含衍射、反射、漫反射、阻碍等传播机制，支持频率范围为２～100ＧＨｚ.</p>
<p><strong>NYU信道模型</strong><br>NYU的Rappaport教授团队在对多频段（28、38、60、73.5ＧＨｚ）、多场景（室内外、校园、市区）、多链路类型（回传、接入）测量分析的基础上，给出了室外二维（无俯仰角度）毫米波信道模型［３５］，该模型包括路损、时域簇和簇内射线功率和时延参数、以波瓣数和波瓣扩展表征的角度域参数等．随后该团队利用射线追踪技术，提出了GSCM框架下的三维信道模型．模型中簇和射线的功率是对数正态随机变量，并随时延指数衰减（类似于ＳＶ模型）；时域簇内射线随机指定波瓣，并生成所需角度，波瓣和射线角度均服从高斯或LAplacian分布．模型给出了定向路损、波束合并路损和全向路损三种模型。</p>
<p><strong>mmMAGIC信道模型</strong><br>mmMAGIC旨在为６～100ＧＨｚ的５Ｇ通信开发新的无线接入技术，其中第二工作组专注于信道测量和建模，以欧洲研究机构为研究主体，包括Fraunhofer HHI、Ericsson、Aalto大学等．重点关注室外的城市街区和开<br>放广场，室内的办公室、购物中心、机场值机大厅和地铁站，以及O2I和体育馆．mmMAGIC以３ＧＰＰ３Ｄ模型为基准，采用测量、ＲＴ和点云相结合的建模方法，最终使用Fraunhofer HHI开发的开源QuaDRiGa工具实现三维统计信道模型．QuaDRiGa具有支持球面波，时间演进，场景转换，可变终端速度，ＬＯＳ和ＮＬＯＳ统一建模，几何极化分量计算，更平滑的LSPs相关性等优点．在建模方法上，除了采用ＫＥＤ阻挡建模，还采用更精细的簇内射线的功率、时延和角度建模．因为项目还在进行中，当前它仅综合WINNER、３GPP 3D、METIS和５GCM的结果，给出了初始模型参数．</p>
<p><strong>３GPP高频段信道模型</strong><br>3GPP HF（６～100GHz）是第一个公开发布的５Ｇ高频段信道标准模型．除了5GCＭ典型场景外，还关注回传、Ｄ２Ｄ／Ｖ２Ｖ、体育场和体育馆．它同样基于3GPP3D模型，采用测量、ＲＴ相结合的建模方法．该模型有很多方法和参数值与５ＧＣＭ相同，但一些实现方法更具体，这包括：多频仿真时的频率相关性建模，使模型支持载波聚合仿真；更精细的射线功率、时延和角度建模，以支持大带宽；对于每一个路径，天线单元可以具有不同的时延，以支持大规模天线阵（但还不支持球面波）．借鉴５ＧＣＭ的两种空间一致性方法：给出空间一致性所需的相关距离，生成空间连续的随机变量分别应用于ＬＯＳ概率、位于室内的概率、建筑物类型及簇相关小尺度参数；基于散射体位置的信道动态演进．继承了５ＧＣＭ阻挡建模方法，对其中的极坐标表达进一步细化，将阻挡物体参数分为两个类型．此外，还提出了簇时延线（ＣＤＬ）和抽头延时线（ＴＤＬ）两个简化模型用于链路仿真，并借鉴METIS，给出了图谱混合信道模型.</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210210124428428.png" alt="图 2 现有信道模型的比较"></p>
<br />

<p>现有模型能够提供各种场景、三种连接类型（具有不同的收发天线高度）的大、小尺度双端３Ｄ参数，使得MIMO系统能够充分利用俯仰方向信息，提升系统容量．在建模方法上，除了GSCM和SV扩展模型外，RT建模方法得到了足够重视．基于RT的METIS图谱模型宣称符合所有的５Ｇ对信道模型的需求，但是它过于复杂，仍需要增加信道测量工作来验证和校正．多数模型提供全向路损模型，在建模时搜集所有方向路径功率，而高频段多采用定向天线，在NLOS条件时部分较强方向信号不会被接收，会导致按模型和天线增益计算的接收功率过大（路损指数过小），造成夸大的小区覆盖范围，从而影响基站部署．而METIS和IEEE 802.11 ad将路损隐含在小尺度参数的方式可能更为合理，阴影衰落也是如此．除了路损与频率关系明显，多频测量结果并没有反映出LSPs和SSPs的频率依赖关系，而射线追踪仿真能反映出这种关系，时延扩展和角度扩展随频率增加而减小．这可能受限于测量系统的动态范围，还需要进一步测量和分析揭示其规律5G CM和3GPP HF模型都提供了对高带宽和频率一致性的支持，声称支持极窄３Ｄ波束（１°分辨率），在建模方法上有支持球面波和天线一致性的可能：由于散射体位置确定，可以确信定这种方法支持球面波建模，如果能够在GGSCM中将天线按相干距离区域划分，那么可以针对各个天线（组）设置其簇参数，支持天线一致性．最新的模型都<br>提供了多种方法来支持空间一致性．极化支持方面，所有路径采取同一个XPR并不能真实准确刻画信道的极化特征，而RT技术能够计算每条射线的ＰＭ显然更符合实际情况．</p>
<br />





<h2 id="参考文献及进一步阅读"><a href="#参考文献及进一步阅读" class="headerlink" title="参考文献及进一步阅读"></a>参考文献及进一步阅读</h2><blockquote>
<p>[1]Qamar F, Siddiqui M H S, Dimyati K, et al. Channel characterization of 28 and 38 GHz MM-wave frequency band spectrum for the future 5G network[C]&#x2F;&#x2F;2017 IEEE 15th student conference on research and development (SCOReD). IEEE, 2017: 291–296.</p>
<p>[2]Imai T, Kitao K, Tran N, et al. Development of high frequency band over 6 GHz for 5G mobile communication systems[C]&#x2F;&#x2F;2015 9th European Conference on Antennas and Propagation (EuCAP). IEEE, 2015: 1–4.</p>
<p>[3]Elayan H, Amin O, Shubair R M, et al. Terahertz communication: The opportunities of wireless technology beyond 5G[C]&#x2F;&#x2F;2018 International Conference on Advanced Communication Technologies and Networking (CommNet). IEEE, 2018: 1–5.</p>
<p>[4]Awada A, Lobinger A, Enqvist A, et al. A simplified deterministic channel model for user mobility investigations in 5G networks[C]&#x2F;&#x2F;2017 IEEE International Conference on Communications (ICC). IEEE, 2017: 1–7.</p>
<p>[5]Wang C-X, Bian J, Sun J, et al. A survey of 5G channel measurements and models[J]. IEEE Communications Surveys &amp; Tutorials, IEEE, 2018, 20(4): 3142–3168.</p>
<p>[6]He D, Ai B, Guan K, et al. Channel measurement, simulation, and analysis for high-speed railway communications in 5G millimeter-wave band[J]. IEEE Transactions on Intelligent Transportation Systems, IEEE, 2017, 19(10): 3144–3158.</p>
<p>[7]孙健,张文胜,王承祥.5G高频段信道测量与建模进展[J].电子学报,2017,45(05):1249-1260.</p>
<p>[8]张沛泽,庞帅,周宇,孙向前,王洪博.5G高频段无线信道测量技术研究进展及发展趋势[J].移动通信,2017,41(18):67-72.</p>
<p>[9]张建华,唐盼,田磊.高频段信道建模研究现状与展望[J].电信网技术,2016(03):10-17.</p>
<p><a href="http://www.imt-2020.cn/zh/documents/download/148">IMT-2020（5G）推进组高频段专题组技术报告</a></p>
<p><a href="https://www.itu.int/en/journal/2019/001/Pages/04.aspx">Channel models for 5G and beyond</a></p>
</blockquote>
<br />

<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>爆竹声中一岁除，春风送暖入屠苏。<br>千门万户曈曈日，总把新桃换旧符。</p>
<p>–王安石</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>5G NR</tag>
        <tag>调研</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/posts/40836.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgkazuya-tachibana-arseniy-chebynkin-kitchen.jpg"></p>
<p><strong>优先队列</strong>是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务，【不是普通队列的先进先出(FIFO)】。优先队列往往用**<a href="https://www.wikiwand.com/zh-cn/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">堆</a>**来实现。🌴</p>
<span id="more"></span>



<br />



<h2 id="🍽操作"><a href="#🍽操作" class="headerlink" title="🍽操作"></a>🍽操作</h2><p>优先队列至少需要支持下述操作：</p>
<ul>
<li>插入带优先级的元素（insert_with_priority）</li>
<li>取出具有最高优先级的元素（pull_highest_priority_element）</li>
<li>查看最高优先级的元素（peek）：O(1) 时间复杂度</li>
</ul>
<p>其它可选的操作：</p>
<ul>
<li>检查优先级高的一批元素</li>
<li>清空优先队列</li>
<li>批插入一批元素</li>
<li>合并多个优先队列</li>
<li>调整一个元素的优先级</li>
<li></li>
</ul>
<h2 id="🍿实现"><a href="#🍿实现" class="headerlink" title="🍿实现"></a>🍿实现</h2><h3 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h3><p>有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为O(1)，但取出时效率为O(n)。</p>
<h3 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h3><p>出于性能考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)。</p>
<p>从计算复杂度的角度，优先级队列等价于排序算法。</p>
<p>有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为O(log n)，并可以常量时间复杂度的peek操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，[1]，但删除操作的时间复杂度为O(log n)。Brodal queue（英语：Brodal queue）具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。</p>
<p>对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。 </p>
<h3 id="库实现"><a href="#库实现" class="headerlink" title="库实现"></a>库实现</h3><p>优先队列是计算机科学中的一类”容器数据类型”。</p>
<p>标准模板库（STL）以及1998年的C++标准确定优先队列是标准模板库的容器适配器模板。其实现了一个需要三个参数的最大优先队列：比较函数（缺省情况是小于函数less<T>）、存储数据所用的容器类型（缺省情况是向量vector<T>）以及指向序列开始和结束位置的两个迭代器。和标准模板库中其他的真实容器不同，优先队列不允许使用其元素类型的迭代器，而必须使用优先队列抽象数据类型的迭代器。标准模板库还实现了支持随机访问数据容器的优先队列–二叉最大堆。<a href="https://www.wikiwand.com/zh-cn/Boost_C%2B%2B_Libraries">Boost C++库</a>也在其中实现了堆结构。</p>
<h2 id="🌸STL-priority-queue-优先级队列-用法"><a href="#🌸STL-priority-queue-优先级队列-用法" class="headerlink" title="🌸STL priority_queue 优先级队列 用法"></a>🌸STL priority_queue 优先级队列 用法</h2><p>优先级队列是一个容器适配器，它提供对最大（默认）元素的恒定时间查找，但以对数插入和提取为代价。可以提供用户提供的比较来更改顺序，例如 使用std :: greater <T>会使最小的元素显示为top（）。使用priority_queue类似于在某些随机访问容器中管理堆，其好处是不会意外使堆无效。</p>
<h2 id="🌻priority-queue-操作"><a href="#🌻priority-queue-操作" class="headerlink" title="🌻priority_queue 操作"></a>🌻priority_queue 操作</h2><p>对 priority_queue 进行操作有一些限制：</p>
<ul>
<li>push(const T&amp; obj)：将obj的副本放到容器的适当位置，这通常会包含一个排序操作。</li>
<li>push(T&amp;&amp; obj)：将obj放到容器的适当位置，这通常会包含一个排序操作。</li>
<li>emplace(T constructor a rgs…)：通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个排序操作。</li>
<li>top()：返回优先级队列中第一个元素的引用。</li>
<li>pop()：移除第一个元素。</li>
<li>size()：返回队列中元素的个数。</li>
<li>empty()：如果队列为空的话，返回true。</li>
<li>swap(priority_queue<T>&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">class</span> <span class="title class_">Container</span>= vector &lt;Type&gt;, <span class="keyword">class</span> Compare= less &lt;<span class="keyword">typename</span> Container ::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br></pre></td></tr></table></figure>



<p><em>Type</em><br> 要存储在 priority_queue 中的元素数据类型。</p>
<p>*Container <em>容器</em><br> 用来实现 priority_queue 的基础容器的类型，比如vector,deque等，默认是vector .</p>
<p><em>Functional</em><br> 一种提供函数对象的类型，该函数对象将两个元素值作为排序键进行比较，以确定其在 priority_queue 中的相对顺序。 此参数为可选自变量，默认值是二元谓词 <code>less&lt;typename Container::value_type&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>





<p><strong>基本类型优先队列的例子：</strong></p>
<p> 示例来自 <a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com) </a> ，在此表示感谢。🍻🍻</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      这里一定要有空格，不然成了右移运算符↓↓</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure>





<p><strong>用pair做优先队列元素的例子：</strong></p>
<p>规则：pair的比较，先比较第一个元素，第一个相等比较第二个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>





<p><strong>用自定义类型做优先队列元素的例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<p>示例，来自 <strong><a href="https://en.cppreference.com/w/cpp/container/priority_queue">https://en.cppreference.com/w/cpp/container/priority_queue</a></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_queue</span><span class="params">(T q)</span> </span>&#123; <span class="comment">// NB: pass by value so the print uses a copy</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认大顶堆  队头元素最大</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> data = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : data)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_queue</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先输出小的元素</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">            <span class="built_in">q2</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q22;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n:data)</span><br><span class="line">        q22.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print_queue</span>(q22);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using lambda to compare elements.</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">int</span> left, <span class="type">int</span> right) &#123; <span class="built_in">return</span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>); &#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : data)</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_queue</span>(q3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp2=[](<span class="type">int</span> left, <span class="type">int</span> right)&#123;<span class="built_in">return</span>()&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>



<p><strong>补充</strong></p>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode） (leetcode-cn.com)</a> 这一题可使用优先队列的大顶推</p>
<h2 id="🍉应用"><a href="#🍉应用" class="headerlink" title="🍉应用"></a>🍉应用</h2><p>优先队列常用于操作系统的<a href="https://www.wikiwand.com/zh-cn/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">任务调度</a>，也是<a href="https://www.wikiwand.com/zh-cn/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a>的重要组成部分。</p>
<h2 id="🌳参考文献"><a href="#🌳参考文献" class="headerlink" title="🌳参考文献"></a>🌳参考文献</h2><p><a href="https://www.wikiwand.com/zh-cn/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97">优先队列 - Wikiwand</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/priority_queue">std::priority_queue - cppreference.com</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/priority-queue-class?view=msvc-160">priority_queue 类 | Microsoft Docs</a></p>
<p><a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com)</a></p>
<br />

<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore / Git 忽略文件无效解决方案</title>
    <url>/posts/6977.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210413220456534.png"></p>
<center> <font size=4.9> 忽略 Git 仓库中的一些文件或文件夹.  </center>

<span id="more"></span>

<br />

<h2 id="Git-忽略文件-文件夹"><a href="#Git-忽略文件-文件夹" class="headerlink" title="Git 忽略文件&#x2F;文件夹"></a>Git 忽略文件&#x2F;文件夹</h2><p>要想忽略掉 Git  仓库中的一些文件或文件夹可以在仓库的根目录中创建 <em>.gitignore</em> 文件，指示 Git 在您进行提交时要忽略哪些文件和目录。 要与克隆仓库的其他用户共享忽略规则，请提交 <em>.gitignore</em> 文件到您的仓库。【针对没有提交过的】</p>
<ol>
<li><p>打开 Git Bash。</p>
</li>
<li><p>导航到 Git 仓库的位置。</p>
</li>
<li><p>为仓库创建 .gitignore 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> .gitignore</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>也可以不使用命令行，手动创建一个 <code>.gitignore</code> ，然后在里面输入想要忽略的文件或文件夹即可，比如我的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*.iq</span><br><span class="line">*.mat</span><br><span class="line">*.jpg</span><br><span class="line">*.zip</span><br><span class="line">*.rar</span><br><span class="line">*<span class="number">.7</span>z</span><br><span class="line">cmake-build-debug<span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<p>具体忽略的一些模板可以在这个仓库查看 👉<a href="https://github.com/github/gitignore">github&#x2F;gitignore: A collection of useful .gitignore templates</a></p>
<p>比如 <code>cpp</code> 的项目可以这样忽略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Prerequisites</span><br><span class="line">*.d</span><br><span class="line"></span><br><span class="line"># Compiled Object files</span><br><span class="line">*.slo</span><br><span class="line">*.lo</span><br><span class="line">*.o</span><br><span class="line">*.obj</span><br><span class="line"></span><br><span class="line"># Precompiled Headers</span><br><span class="line">*.gch</span><br><span class="line">*.pch</span><br><span class="line"></span><br><span class="line"># Compiled Dynamic libraries</span><br><span class="line">*.so</span><br><span class="line">*.dylib</span><br><span class="line">*.dll</span><br><span class="line"></span><br><span class="line"># Fortran <span class="keyword">module</span> files</span><br><span class="line">*.mod</span><br><span class="line">*.smod</span><br><span class="line"></span><br><span class="line"># Compiled Static libraries</span><br><span class="line">*.lai</span><br><span class="line">*.la</span><br><span class="line">*.a</span><br><span class="line">*.lib</span><br><span class="line"></span><br><span class="line"># Executables</span><br><span class="line">*.exe</span><br><span class="line">*.out</span><br><span class="line">*.app</span><br></pre></td></tr></table></figure>

<br />

<br />

<h2 id="gitignore-git-忽略文件无效解决方案"><a href="#gitignore-git-忽略文件无效解决方案" class="headerlink" title=".gitignore &#x2F; git 忽略文件无效解决方案"></a>.gitignore &#x2F; git 忽略文件无效解决方案</h2><p>如果想要忽略已提交的文件，则必须在添加忽略该文件的规则之前取消跟踪它，即先删除本地缓存，然后重新提交。 从终端取消执行以下操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;update .gitignore&quot;</span></span><br><span class="line">git push -u origin master </span><br></pre></td></tr></table></figure>

<br />

<br />

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://stackoverflow.com/questions/4308610/how-to-ignore-certain-files-in-git">gitignore - How to ignore certain files in Git - Stack Overflow</a></p>
<p><a href="https://docs.github.com/cn/github/getting-started-with-github/ignoring-files">忽略文件 - GitHub Docs</a></p>
<p><a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation (git-scm.com)</a></p>
<p><a href="https://www.atlassian.com/git/tutorials/saving-changes/gitignore">.gitignore file - ignoring files in Git | Atlassian Git Tutorial</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208">忽略特殊文件 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<br />

<br />

<br />

 <br />
]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下安装中文版 man 手册 以及 C++ 帮助手册</title>
    <url>/posts/58853.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grdb8wqvaaj21s80to13l.jpg"></p>
<p>man 手册页是在Unix或类Unix操作系统中常用的一种花在线软件文档形式，内容包括计算机程序（包括库和系统调用），正式的标准和惯例，甚至是抽象的概念。我们都可以通过执行man命令调用手册页。本文主要内容为：为 Linux 下的 man 手册安装中文版并设置别名 cman ， 方便中英阅读对照；同时安装 Ｃ++ 的 man 手册文档，方便查阅库函数的使用细节。</p>
<span id="more"></span>





<h2 id="安装-中文-man-手册"><a href="#安装-中文-man-手册" class="headerlink" title="安装 中文 man 手册"></a>安装 中文 man 手册</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install manpages-zh</span><br></pre></td></tr></table></figure>



<h2 id="查看man-手册安装到哪里"><a href="#查看man-手册安装到哪里" class="headerlink" title="查看man 手册安装到哪里"></a>查看man 手册安装到哪里</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -L manpages-zh | less</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grd734x529j20xz0jsacb.jpg"></p>
<p>由上图可见，安装位置为 <code>/usr/share/man/zh_CN</code></p>
<blockquote>
<p>注： 从dpkg命令下退出请按 键盘的  <kbd>Q</kbd></p>
</blockquote>
<br />

<br />

<h2 id="为-bash-设置一个中文man的别名"><a href="#为-bash-设置一个中文man的别名" class="headerlink" title="为 bash 设置一个中文man的别名"></a>为 bash 设置一个中文man的别名</h2><p>为了不干扰原来 <code>man</code> 命令的使用，可以设置一个别名，比如 <code>cman</code></p>
<p>​     修改 ~&#x2F;.bashrc 添加一个alias :</p>
<p>修改方法1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="built_in">alias</span> cman=<span class="string">&#x27;man -M /usr/share/man/zh_CN&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使别名生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改方法2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias cman=&#x27;man -M /usr/share/man/zh_CN&#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使别名生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grd77lqdrdj20xz0jsng7.jpg"></p>
<p>这样以后查看 英文 继续使用 man 就行，查看中文版 使用 cman 命令就行，当然开两个终端中英对照更加有助于英语水平的提高 . 😀</p>
<br />

<br />

<h2 id="为-zsh-配置别名"><a href="#为-zsh-配置别名" class="headerlink" title="为 zsh 配置别名"></a>为 zsh 配置别名</h2><p>若没有使用 zsh 可忽略这一步 ， 有的话执行下面的命令，因为 zsh 读取的配置文件和 bash 的不一样.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias cman=&#x27;man -M /usr/share/man/zh_CN&#x27;&quot;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使别名生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grd876w823j20xz0jsas7.jpg"></p>
<br />

<br />



<h2 id="安装C-帮助手册"><a href="#安装C-帮助手册" class="headerlink" title="安装C++帮助手册"></a>安装C++帮助手册</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libstdc++-10-doc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就能查看一些 C++ 的东西了  ，比如 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man std::map</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++ 的好多好像没中文的，只能 man 了 ，不能 cman</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grd8smjhbzj20xz0jsqm5.jpg"></p>
<br />

<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p><strong>手册内容</strong></p>
<p>多数手册包含以下几部分内容：</p>
<ul>
<li>NAME 功能的简单描述</li>
<li>SYNOPSIS 语法格式</li>
<li>DESCRIPTION 描述</li>
<li>OPTIONS 选项</li>
<li>ERRORS 描述出错场景，<strong>这在排查错误时很有帮助</strong></li>
<li>NOTES 注意事项</li>
<li>FILES 相关文件，例如对于man命令的FILES部分内容显示了它的配置文件位置等信息</li>
<li>EXAMPLES 使用示例，会提供一些简单的示例</li>
<li>BUGS 存在的bug，<strong>当遇到奇怪的问题时，不妨看看当前命令是否有已知的bug</strong></li>
</ul>
<p><strong>基本查看</strong></p>
<p>手册的查看和less查看文本类似，可以参考《文本查看篇》或查看less命令的使用，这里介绍基本操作：</p>
<ul>
<li>空格 向下翻页</li>
<li>Home 回到第一页</li>
<li>End 跳到最后一页</li>
<li>&#x2F;string 向前搜索string字符串</li>
<li>?string 向后搜索string字符串</li>
<li>n 下一个匹配字符</li>
<li>N 上一个匹配字符</li>
<li>q 退出</li>
</ul>
</blockquote>
<br />

<h2 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h2><blockquote>
<p>对于 .bash_profile 和 .bashrc 区别 ：</p>
<p>如果你想对bash的功能进行设置或者是定义一些别名，推荐你修改&#x2F;.bashrc文件，这样无论你以何种方式打开shell，你的配置都会生效。</p>
<p>而如果你要更改一些环境变量，推荐你修改 ~&#x2F;.bash_profile文件，因为考虑到shell的继承特性，这些更改确实只应该被执行一次（而不是多次）。针对所有用户进行全局设置，推荐你在&#x2F;etc&#x2F;profile.d目录下添加以.sh结尾的文件，而不是去修改全局startup文件。</p>
<p>摘录自 Charles Shih ，在此表示感谢</p>
<p><a href="https://blog.csdn.net/sch0120/article/details/70256318">关于“.bash_profile”和“.bashrc”区别的总结_Charles Shih 技术博客</a></p>
</blockquote>
<br />

<h2 id="附录2"><a href="#附录2" class="headerlink" title="附录2"></a>附录2</h2><p>其它版本Linux安装命令为：</p>
<blockquote>
<p><strong>Debian&#x2F;Ubuntu 安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install manpages-zh</span><br></pre></td></tr></table></figure>

<p><strong>Arch Linux</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br><span class="line">pacman -S man-pages-zh_cn man-pages-zh_tw</span><br></pre></td></tr></table></figure>

<p><strong>Red Hat&#x2F;CentOS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install man-pages-zh-CN</span><br></pre></td></tr></table></figure>

<p><strong>Fedora</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf update</span><br><span class="line">dnf install man-pages-zh-CN</span><br></pre></td></tr></table></figure>
</blockquote>
<br />

<h2 id="附录3"><a href="#附录3" class="headerlink" title="附录3"></a>附录3</h2><p> man命令并非仅仅能查看命令或者函数的介绍，在linux中，有丰富的帮助手册信息，并且每一个手册都有一个编号。编号和对应内容如下：</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">代表内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">可执行程序或shell命令，如ls</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">系统调用，如chdir</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">库函数，如printf</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">设备或特殊文件，如tty</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">配置文件格式或约定</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">游戏</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">杂项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">管理命令，通常只有root用户可以使用</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">内核例程</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">内置命令，如cd</td>
</tr>
</tbody></table>
<p>比如</p>
<p>man 3 sleep</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grd9533h60j20xz0jsqld.jpg" alt="image"></p>
<br />

<br />

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>感谢以下参考文献 🍻</p>
<p><a href="https://www.wikiwand.com/en/Man_page">man page - Wikiwand</a></p>
<p><a href="https://segmentfault.com/a/1190000019972482">安装中文版 man 帮助命令 - SegmentFault 思否</a></p>
<p><a href="https://blog.csdn.net/sch0120/article/details/70256318">关于“.bash_profile”和“.bashrc”区别的总结_Charles Shih 技术博客</a></p>
<p><a href="https://www.zhihu.com/question/22990045"> .bashrc文件和.bash_profile文件的区别？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://stackoverflow.com/questions/5293737/where-are-the-man-pages-for-c">linux - Where are the man pages for C++? - Stack Overflow</a></p>
<p><a href="https://www.yanbinghu.com/2018/12/04/41455.html">Linux常用命令-man | 守望的个人博客 (yanbinghu.com)</a></p>
<p><a href="https://www.jianshu.com/p/185fe0a4f426">linux 设置中文版man手册 </a></p>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>山光忽西落，池月渐东上。<br>散发乘夕凉，开轩卧闲敞。<br>荷风送香气，竹露滴清响。<br>欲取鸣琴弹，恨无知音赏。<br>感此怀故人，中宵劳梦想。</p>
<p>–  孟浩然 《<a href="https://so.gushiwen.cn/shiwenv_9306064f2630.aspx">夏日南亭怀辛大</a>》</p>

</blockquote>



<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 CLion 和 Valgrind 调试程序检查内存泄漏</title>
    <url>/posts/9487.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1gsc5u2610gj23su2j8dox.jpg"></p>
<p> Valgrind Memcheck 是一个用于检测内存使用问题的工具，比如泄漏、无效的内存访问、不正确的释放和引用未定义的值。CLion提供了配置Valgrind ，但不是开箱即用，需要自己安装然后配置一下，通过本文三言两语你将学会CLion 下 Valgrind 的配置。</p>
<span id="more"></span>



<br />

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind 由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个 CPU 环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。<br>Valgrind 包括如下一些工具：</p>
<blockquote>
<ul>
<li>Memcheck。这是 valgrind 应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。我在项目中目前只用到了该模块，在使用数组或者 OpenCV 的 Mat 时，可以利用该工具查看内存使用是否出现问题。</li>
<li>Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</li>
<li>Cachegrind。它主要用来检查程序中缓存使用出现的问题。</li>
<li>Helgrind。它主要用来检查多线程程序中出现的竞争问题。</li>
<li>Massif。它主要用来检查程序中堆栈使用中出现的问题。</li>
<li>Extension。可以利用 core 提供的功能，自己编写特定的内存调试工具。</li>
</ul>
</blockquote>
<br />

<h2 id="安装Valgrind"><a href="#安装Valgrind" class="headerlink" title="安装Valgrind"></a>安装Valgrind</h2><p>Valgrind 的官网为  <a href="https://valgrind.org/downloads/?src=www.discoversdk.com">Valgrind</a> ，我这里给出 Linux下的安装方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install valgrind</span><br></pre></td></tr></table></figure>

<p>安装好后输入 <code>valgrind --version</code> 可以查看版本号，如下图所示，我的是  3.15.0 . 输入 <code>valgrind --help</code> 可以查看使用帮助。 接着输入 <code>where valgrind</code> 查看安装位置，在CLion 中配置需要用到。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210710203356275.png"></p>
<p>关于 CLion 如何配置 WSL 可参见 <a href="https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html#wsl-general">WSL | CLion (jetbrains.com)</a></p>
<br />

<br />

<h2 id="CLion中配置-Valgrind"><a href="#CLion中配置-Valgrind" class="headerlink" title="CLion中配置 Valgrind"></a>CLion中配置 Valgrind</h2><p>在 <strong>Settings &#x2F; Preferences | Build, Execution, Deployment | Dynamic Analysis Tools | Valgrind</strong>. 下图所示的位置配置 Valgrind 的路径 <code>/usr/bin/valgrind</code> ，然后就大功告成。</p>
<p>另外也可以指定分析选项或使用默认选项，我使用的默认选项。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210710203830352.png"></p>
<p>确保使用的是WSL进行代码的编译及运行，若没有配置WSL请参见   <a href="https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html#wsl-general">WSL | CLion (jetbrains.com)</a></p>
<br />

<h2 id="CLion中使用-Valgrind"><a href="#CLion中使用-Valgrind" class="headerlink" title="CLion中使用 Valgrind"></a>CLion中使用 Valgrind</h2><p>用 Valgrind memcheck 运行代码即可，一旦运行结束即可查看分析报告。</p>
<p>点击①使用Valgrind memcheck运行</p>
<p>在②处常看分析，可以双击就会出现③中的具体内存泄漏的代码</p>
<p>④处是我故意写的内存泄漏的代码 <code>int* p=new int[8];</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210710203757407.png"></p>
<p>要导出结果，请单击<strong>Valgrind</strong>选项卡左窗格中的<strong>导出</strong><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgcl_valgrindexport_b.png">图标，并指定目的地 XML 文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgimage-20210710205249843.png"></p>
 <br />

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.ferranpujolcamins.cat/2020/12/03/debugging-your-program-using-valgrind-and-clion.html">Debugging your program using Valgrind and CLion on Linux | Ferran Pujol Camins</a></p>
<p><a href="https://blog.csdn.net/leonardohaig/article/details/87557055">valgrind安装及使用_leonardohaig的博客-_valgrind 安装</a></p>
<p><a href="https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html#wsl-tooclhain">WSL | CLion (jetbrains.com)</a></p>
<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>教程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL SSH 自启动</title>
    <url>/posts/14733.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1gsc5umbr8dj255p3ft484.jpg"></p>
<p>vbs脚本实现WSL SSH 自启动</p>
<span id="more"></span>

<br />

<p>按键<code>win+R</code> 输入<code>shell:startup</code>系统会自动打开一个目录</p>
<h3 id="增加脚本wsl-ssh-vbs-名字随便"><a href="#增加脚本wsl-ssh-vbs-名字随便" class="headerlink" title="增加脚本wsl_ssh.vbs(名字随便)"></a>增加脚本<code>wsl_ssh.vbs</code>(名字随便)</h3><p>里面填写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set ws = CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">ws.run <span class="string">&quot;wsl  -u root /etc/init.d/ssh start&quot;</span>, vbhide</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1gr8fize385j20nx0alt9k.jpg"></p>
<p>重启电脑就会自动执行啦 。</p>
<br />

<p>检察一下是否启动成功，在  PowerShell  的话输入：  <code> wsl -u root /etc/init.d/ssh status </code>   . 在Linux终端的话输入 <code>/etc/init.d/ssh status</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1gr8fk8dzuwj21690o64m1.jpg"></p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1gr8flxspt8j21690o6h98.jpg"></p>
<p>这样就不用每次手动启动 ssh 了 ，手动启动的话在 PowerShell 输入 ：<code> wsl -u root /etc/init.d/ssh start</code> 或者 <code>wsl sudo /etc/init.d/ssh start</code>再输入密码，也是一样的。</p>
<br />



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/47733615">WSL 服务自动启动的正确方法 )</a></p>
<p><a href="https://www.mingilin.com/2020/02/22/windows/windows-wsl-ssh/">win10 wsl子系统开机自启sshd | 情文のBLOG (mingilin.com)</a></p>
<br />

<br />

<br />

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>custom cursor 个性化你的鼠标光标样式</title>
    <url>/posts/55161.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161119090.jpg"></p>
<p>推荐一款命名为 <code>Custom Cursor </code>的鼠标光标个性化软件，为枯燥的生活增添一点点乐趣。 <code>Custom Cursor </code>除了支持Chrome、Edge等浏览器扩展外，还支持Windows桌面端。</p>
<span id="more"></span>

<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://custom-cursor.com/en">Custom Cursor (custom-cursor.com)</a></p>
<p>官网映入眼帘的就是各种可爱的鼠标光标。 <code>Custom Cursor </code> 能够自定义有趣的鼠标光标，官网有大量免费光标，可使用超过100种不同鼠标光标样式，当然也可以上传自己的光标。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9itbwuhnj21du0r7b0b.jpg"></p>
<p> <code>Custom Cursor</code> 在 YouTube的频道为：</p>
<p><a href="https://www.youtube.com/c/beautifullife450">Beautiful Life - YouTube</a>  </p>
<br />

<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>windows 客户端下载 <a href="https://custom-cursor.com/products/custom-cursor-for-windows">Custom Cursor for Windows - Custom Cursor (custom-cursor.com)</a></p>
<p>chrome 浏览器 <a href="https://chrome.google.com/webstore/detail/custom-cursor-for-chrome/ogdlpmhglpejoiomcodnpjnfgcpmgale/reviews">Custom Cursor for Chrome™ - 自定义光标 - Chrome 网上应用店 (google.com)</a></p>
<p>edge 浏览器 <a href="https://microsoftedge.microsoft.com/addons/detail/custom-cursor-for-microso/ekmpbacnhaailfeebjmpoeifoobmpfhk">Custom Cursor for Microsoft Edge™ - 自定义光标 - Microsoft Edge Addons</a></p>
<p>个人推荐windows客户端的版本，可以比较方便更换或管理鼠标光标样式，平时的话不需要给 <code>Custom Cursor</code> 在后台运行，需要更换样式的时候再打开就行。  </p>
<p>下面演示下 windows 客户端的安装</p>
<p>在 <a href="https://custom-cursor.com/products/custom-cursor-for-windows">Custom Cursor for Windows - Custom Cursor (custom-cursor.com)</a> 点击下图中的 <code>Download</code> 下载完成后，直接安装即可。</p>
<p>你也可以在蓝奏云下载我上传的安装包：</p>
<p><a href="https://yours.lanzout.com/iOD5Mymvcod">https://yours.lanzout.com/iOD5Mymvcod</a> 提取码：2022</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9klwd7gkj217d0oanbt.jpg" alt="下载页面"></p>
<p><a href="https://shadow.elemecdn.com/npm/">https://shadow.elemecdn.com/npm/</a></p>
<p><a href="https://cdn.statically.com/">https://cdn.statically.com/</a></p>
<p>双击安装包，选择语言为 English ，然后继续安装就行（因为没有中文）。点击 OK 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9j8ap6kjj20cu07nwfp.jpg" alt="安装"></p>
<p>点击 Next 。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9knbqa78j20gg0dkwgq.jpg" alt="安装" style="zoom:80%;" />

<p>点击 Next 。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9kow2exuj20ga0djq4r.jpg" alt="安装" style="zoom:80%;" />

<p>点击 install 。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9kqltweaj20gg0de0un.jpg" alt="安装" style="zoom:80%;" />

<p>点击 Finish ，先运行  <code>Custom Cursor</code>  😉。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9krj6d8ij20gg0dg41n.jpg" alt="安装"></p>
  <br />

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="软件基本界面"><a href="#软件基本界面" class="headerlink" title="软件基本界面"></a>软件基本界面</h3><p>下图为  <code>Custom Cursor</code> 的软件界面，点击Home显示当前客户端中拥有的鼠标光标样式。</p>
<p> 点击①就会跳转到添加光标样式的网页。</p>
<p>点击②就是上传自定义鼠标光标样式的界面。</p>
<p>点击③进入到软件的设置界面，鼠标光标的大小、软件界面的语言、是否开机自启动都在里面设置。</p>
<p>点击④恢复windows默认的鼠标光标样式，这很重要，因为有时候你想恢复系统默认的光标，点击④就行了。当然也可以在系统设置中恢复默认，只不过麻烦一点。</p>
<p>点击⑤会隐藏  <code>Custom Cursor</code> 到托盘中，要想关闭   <code>Custom Cursor</code> 则需要在托盘右击，选择 close 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9jrz0xlxj216w0tktlm.jpg" alt="软件界面"></p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20220111110422294.png" alt="系统设置中可恢复默认鼠标光标样式" style="zoom: 67%;" />

<br/>

<h3 id="更换样式"><a href="#更换样式" class="headerlink" title="更换样式"></a>更换样式</h3><p>更换光标的方式就是在  <code>Custom Cursor</code> 选择你喜欢的样式，然后点击 Apply 即可 。Delete的意思是删除  <code>Custom Cursor</code> 客户端中的样式，当然也可以添加其它样式，在下面我将会演示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20220111105323421.png" alt="软件主页"></p>
<br/>

<h3 id="更改光标大小"><a href="#更改光标大小" class="headerlink" title="更改光标大小"></a>更改光标大小</h3><p>点击上文&lt;软件界面&gt;图片中的③，那个设置按钮。更改 Cusor size 就可以改变鼠标光标的大小了，看下图我的鼠标光标就被调的很大了（黄色那个鼠标光标）。</p>
<p>此外，建议取消 开机自启 Run at Windows startup ， 用的时候在打开就行，没必要在后台一直运行。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9k7yw1trj216w0tkn3b.jpg" alt="更改光标大小"></p>
<br/>

<h2 id="下载更多样式"><a href="#下载更多样式" class="headerlink" title="下载更多样式"></a>下载更多样式</h2><p>点击上文&lt;软件界面&gt;图片中的①，那个 More Cursor 按钮。或者直接在浏览器进入 <a href="https://custom-cursor.com/?winclient=1&utm_source=winapp&utm_medium=link_more&utm_campaign=header">Custom Cursor (custom-cursor.com)</a> 这个网页。</p>
<p>寻找喜欢的样式，推荐下面两个样式集合，比较简约可爱，其它图案感觉会影响电脑的使用效率。</p>
<p><a href="https://custom-cursor.com/en/collection/minimal-style">Minimal Cursor Collection - Custom Cursor (custom-cursor.com)</a></p>
<p><a href="https://custom-cursor.com/en/collection/materials">Materials Cursor Collection - Custom Cursor (custom-cursor.com)</a></p>
<p>找到喜欢的后点击那个windows图标，如下图所示的①，由于没安装浏览器拓展  <code>Custom Cursor</code> ，因此不要点到 <code>ADD</code> ,记得是<strong>点windows图标</strong>。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9kgp6inxj21du0r7k3y.jpg" alt="下载喜欢的样式"></p>
<p>在下图①中勾选上，然后点击②中的打开就获得这个样式了，在  <code>Custom Cursor</code> 客户端里面会看见刚刚选择的光标的。按照这样的方法，你就能下载到你喜欢的鼠标光标样式了，给枯燥的生活增加一点点乐趣，哈哈。 😄</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1gy9kunhebbj21e60sltnv.jpg" alt="选择打开">  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://custom-cursor.com/">https://custom-cursor.com/</a></p>
<br />

<br />

<br />

<br />



<blockquote class="blockquote-center">
<p>悠悠天宇旷，切切故乡情。</p>

</blockquote>



<br />

<br />

<br />
]]></content>
      <categories>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee图床迁移至Github并开启CDN</title>
    <url>/posts/20121.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/mmexport1648033893709-sq.jpg"></p>
<p>近几天gitee做了防盗链处理，导致很多使用gitee作为图床的文章中图片挂了，为此决定将图片全部迁移到Github了（我以前两者都使用），本文主要描述了迁移的步骤，以及对原有文章中图片链接的替换。 🙃</p>
<span id="more"></span>

<h2 id="Github-导入-gitee-仓库"><a href="#Github-导入-gitee-仓库" class="headerlink" title="Github 导入 gitee 仓库"></a>Github 导入 gitee 仓库</h2><p>找到 gitee 的仓库地址，我的是：</p>
<p><a href="https://gitee.com/wang_wx/image_bed">https://gitee.com/wang_wx/image_bed</a></p>
<p>对应的clone地址为 <a href="https://gitee.com/wang_wx/image_bed.git">https://gitee.com/wang_wx/image_bed.git</a></p>
<p>然后打开 <a href="https://github.com/">GitHub</a> ，点击右上角的 <code>Import repository</code> ， 填入 <a href="https://gitee.com/wang_wx/image_bed.git">https://gitee.com/wang_wx/image_bed.git</a> 。 新仓库名设置为与原gitee中的相同，我的为 <code>image_bed</code>，设置仓库为公开 Public ，点击开始迁移 <code>Begin Import</code> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1h0pfedoi89j21cl0s8dns.jpg" alt="导入项目"></p>
<p>喝杯咖啡，稍等片刻，就迁移完成了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1h0pfg8op7kj20x70kn43b.jpg" alt="导入完成"></p>
<p>导入完成，接下来我们需要做的就是替换链接，并开启CDN。</p>
<h2 id="链接替换"><a href="#链接替换" class="headerlink" title="链接替换"></a>链接替换</h2><p>使用 VSCode 打开存放markdown文件的文件夹，然后点击 编辑 -&gt; 在文件中替换。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825ly1h0pfj2pgqsj210s0sk4kz.jpg" alt="文件替换"></p>
<p>我们需要做的就是将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gitee.com/wang_wx/image_bed/raw/master</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed</span><br></pre></td></tr></table></figure>

<p>限定文件类型为 *.md</p>
<p><code>https://gitee.com/wang_wx/image_bed/raw/master</code> 当中需要将<code>wang_wx/image_bed</code> 替换为自己gitee中的用户名和仓库名，这很容易找到，在自己markdown图片链接中就能看到。</p>
<p><code>https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed</code> 当中需要将 <code>upwon/image_bed</code> 替换为自己GitHub中的用户名和仓库名。&#96;&#96;gh<code>表示GitHub，不需要更改。 master</code> 表示是master分支，若是就不需要改。</p>
<blockquote>
<p><strong>为什么替换的链接是 <code>https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed</code> 而不是 Github 的原链接 <code>https://github.com/upwon/image_bed/raw/master</code> 呢 ?</strong></p>
<p>答：因为替换为 <code>https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed</code> 会为我们开启CDN，从而国内访问博客时，图片能迅速加载出来。</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20220328104724874.png" alt="替换原gitee链接"></p>
<p>执行为替换后就将所有markdown文件中的链接替换了，若怕自己一下子替换不对，可以先替换一个测试一下是否正确，然后再替换所有。</p>
<p>此外，若原先markdown中直接写的GitHub中的地址</p>
<p>类似于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![](https://github.com/upwon/image_bed/raw/master/2020/202201111216626.png)</span><br></pre></td></tr></table></figure>

<p>也可以执行下替换，从而替换为 <code>jsdelivr</code> CDN 的加速链接。</p>
<p>从</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/upwon/image_bed/raw/master</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed</span><br></pre></td></tr></table></figure>

<p>限定文件类型为 *.md</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20220328105331906.png" alt="替换原GitHub链接"></p>
<p>另外，大家在使用 Typora 或 PicGo 上传图片到 GitHub 时建议直接配置为 jsdelivr 的链接，若有需求可以 Google 搜索 <a href="https://www.google.com/search?q=github+%E5%BC%80%E5%90%AF+jsdelivr&oq=github+%E5%BC%80%E5%90%AF+jsdelivr&aqs=edge..69i57j0i546j69i64.18090j0j9&sourceid=chrome&ie=UTF-8">github 开启 jsdelivr</a> 查看怎么设置。</p>
<h2 id="测试与部署"><a href="#测试与部署" class="headerlink" title="测试与部署"></a>测试与部署</h2><p>替换完后可以本地运行博客，看看有没有问题，正常的话就可以更新修改后的文章到线上博客。</p>
<p><br/>  <br/></p>
<br/>

]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>利用谷歌学术追踪最新论文动态</title>
    <url>/posts/14861.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402142109966.jpg"></p>
<p>利用谷歌学术搜索的快讯来实时追踪最新的论文动态 🎉🎉</p>
<span id="more"></span>



<br />



<p> 在 <a href="https://scholar.google.com/scholar_alerts?view_op=list_alerts&hl=zh-CN">Google 学术搜索 - 快讯</a> 当中可追踪某些主题或某些学者的最新论文动态，会定期在 Gmail邮箱中收到快讯，非常适合学者或研究生。</p>
<p>下图是我订阅过的一些快讯，现在可以取消了，因为<strong>我毕业啦</strong> 。 😉🍻</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161118641.jpg"></p>
<p>定期会在gmail邮箱收到邮件，碰到感兴趣的可以点进去深入阅读。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161118747.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161118764.jpg"></p>
<br />

<br />

<p>祝大家生活愉快，万事胜意 ！ 🍻</p>
<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理器 winget 使用指南</title>
    <url>/posts/36943.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgzqvrxgaj21hc0zkgv6.jpg"></p>
<p>winget 是 windows 10 平台的一个包管理工具，能够在终端通过简单的命令行实现软件的安装、更新、卸载等，与之类似的有 Scoop 和 Chocolatey. 由于 winget 是官方支持，因此安全性、兼容性方面都有保障. 若你和我一样是一个 「更新狂」， 那么你以后更新软件将十分惬意，没有必要去进行一系列繁杂的下载安装 …  ,  只需打开终端输入简单的命令即可 . 🍨</p>
<span id="more"></span>









<br />

<h2 id="安装-winget"><a href="#安装-winget" class="headerlink" title="安装 winget"></a>安装 winget</h2><p>winget是一个安装包管理器，可在Windows 10 计算机上使用 <strong>winget</strong> 命令行工具来检索、安装、升级、删除和配置应用程序.  此工具是 Windows 程序包管理器服务的客户端接口. </p>
<p>可使用多种方法安装 <strong>winget</strong> 工具：</p>
<ul>
<li><p>应用商店</p>
<p>在  Microsoft Store 安装的话会比较简单，因此很推荐 .  在应用商店搜索 <code>应用安装程序</code> ，如下图所示，第一个就是，点进去安装即可. </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgn87bkpsj21ig0vbamz.jpg" alt="搜索应用安装程序"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgnbbg6d6j21ig0vbqa3.jpg" alt="已安装"></p>
<br/>
</li>
<li><p>github下载安装</p>
<p>在 <a href="https://github.com/microsoft/winget-cli/releases">Github Release</a>下载<code>.appxbundle</code>格式的文件，双击打开并运行安装即可.</p>
</li>
</ul>
<p><a href="https://github.com/microsoft/winget-cli">microsoft&#x2F;winget-cli: Windows Package Manager CLI (aka winget) </a> 有英文介绍， <a href="https://docs.microsoft.com/zh-cn/windows/package-manager/winget/">使用 winget 工具安装和管理应用程序 | Microsoft Docs</a> 里面有详细的中文介绍 . </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgn5ehrhsj21cw0pf421.jpg" alt="下载这个"></p>
<blockquote>
<p> 备注</p>
<p> <strong>winget</strong> 工具需要 Windows 10 版本 1709 (10.0.16299) 或更高版本的 Windows 10. </p>
</blockquote>
<br/>

<br/>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h2><h3 id="命令一览"><a href="#命令一览" class="headerlink" title="命令一览"></a>命令一览</h3><p>winget 工具的当前预览版支持以下类型的安装程序：</p>
<ul>
<li>EXE</li>
<li>MSIX</li>
<li>MSI</li>
</ul>
<p>目前winget支持以下的命令 ， 可以在 cmd 或者 powershell 输入 winget ，就能查看所有支持的命令. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The following commands are available:</span><br><span class="line">  install    Installs the given package        安装指定的应用</span><br><span class="line">  show       Shows information about a package 显示具体应用的信息</span><br><span class="line">  <span class="built_in">source</span>     Manage sources of packages       添加、删除和更新winget工具访问的程序包管理器存储库</span><br><span class="line">  search     Find and show basic info of packages   搜索想要的应用</span><br><span class="line">  list       Display installed packages				列出来已经安装的应用</span><br><span class="line">  upgrade    Upgrades the given package		   升级指定的应用</span><br><span class="line">  uninstall  Uninstalls the given package      卸载指定的应用</span><br><span class="line">  <span class="built_in">hash</span>       Helper to <span class="built_in">hash</span> installer files    为安装程序生成 SHA256 哈希</span><br><span class="line">  validate   Validates a manifest file         验证验证清单文件？</span><br><span class="line">  settings   Open settings					   打开winget设置</span><br><span class="line">  features   Shows the status of experimental features  显示实验features的状态</span><br><span class="line">  <span class="built_in">export</span>     Exports a list of the installed packages   导出已安装软件包的列表</span><br><span class="line">  import     Installs all the packages <span class="keyword">in</span> a file        导入要安装软件包的列表</span><br><span class="line">  <span class="built_in">help</span>	显示 winget 工具命令的帮助信息. </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们常用的也就几个，搜索、安装、卸载、升级，下面将会演示每一个的用法. </p>
  <br/>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 <strong>应用安装程序</strong> 后，可以通过在命令提示符下键入“winget”来运行 <strong>winget</strong>. </p>
<p>最常见的使用场景之一是搜索并安装你最喜欢的工具. </p>
<ol>
<li>若要<a href="https://docs.microsoft.com/zh-cn/windows/package-manager/winget/search">搜索</a>某个工具，请键入 <code>winget search &lt;appname&gt;</code>. </li>
<li>确认你需要的工具可用后，可以通过键入 <code>winget install &lt;appname&gt;</code> 来<a href="https://docs.microsoft.com/zh-cn/windows/package-manager/winget/install">安装</a>该工具.  <strong>winget</strong> 工具会启动安装程序，将应用程序安装在你的电脑上.</li>
</ol>
<p>比如， 搜索 <code>winget search music</code> </p>
<p>会出现很多结果，其中有应用的名称、ID、版本以及Tag  ，然后找到你想要安装的应用 ，比如我当前想要安装 <code>Musescore</code> ， 那么只需输入 <code>winget install Musescore.Musescore</code>  或  <code>winget install Musescore</code>   就行了，更推荐前一种，因为前一种包含 ID ，这是独一无二的不会造成错误 . </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgnhiwi32j21ig0vbnpd.jpg"></p>
<blockquote>
<p> 当然如果你很明确你需要的应用，并且你知道它的名称，那么你就不需要去搜索了，你直接就安装就行了，不需要去搜索了，不过一般都需要去搜一下保证名称的正确性 . </p>
</blockquote>
<p>接下来输入 <code>winget install Musescore.Musescore</code> 进行安装 . </p>
<p>有一些软件安装时会弹窗出来申请权限，点击是就行啦 ，如下图所示就是安装成功了. </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgnnhcwwtj21900qh1kx.jpg"></p>
<br/>

<p><strong><font color='cyan'>更改安装路径 !!!</font></strong> </p>
<p>默认的安装路径是在C盘里面，当然安装路径是可以更改的，使用 <code>-l </code>来指定路径，<code>l</code>代表 <code>location </code>的意思. </p>
<p>比如： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install EliasFotinis.DeskPins -l <span class="string">&quot;D:\20200213\Tools\DeskPins&quot;</span></span><br></pre></td></tr></table></figure>

<p>就指定了安装路径为 <code>D:\20200213\Tools\DeskPins</code></p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgxbq5mqfj21690o6h80.jpg"></p>
<p>&#x3D;&#x3D;若需要指定安装路径，则千万切记一定要指定一个空的文件夹作为路径，否则卸载的话会把该路径下的东西全部都给删除了. 不要问我为什么知道&#x3D;&#x3D;</p>
<br />

 

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载的话与安装类似 ，把 <code>winget install</code>   换成  <code>winget uninstall</code></p>
<p>一般卸载前 我会使用 <code>winget list</code> 罗列出来已安装的所有应用，然后找到想要卸载的应用的名字，然后再卸载 . 因为有时候名字变了， 输入 <code>winget uninstall &#39;MuseScore 3&#39;</code>   或  <code>winget uninstall &quot;MuseScore 3&quot; </code></p>
<blockquote>
<p>为什么有引号呢？</p>
<p>因为应用的名字中有空格，因此需要用 <code>‘ ’</code> 或者 <code>“ ”</code>括起来</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgo52slltj21900qh1kx.jpg" alt="winget list"></p>
<p>当前另一种方法卸载就是， 打开 <a href="https://geekuninstaller.com/">geek uninstaller</a> ， 手动卸载也可 ，哈哈哈 </p>
<blockquote>
<p>geek uninstaller 是一款很好用的卸载工具，免费版的就足够用了</p>
<p>不妨一试</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgoitibnwj21cw0pf46p.jpg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgomziekij20wb0m8dmz.jpg"></p>
</blockquote>
<br />

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>一般我都会隔几个月统一更新应用，首先我会在终端输入命令 <code>winget list</code>来获取到现在 的应用列表. 然后在应用列表当中会显示已可更新的应用. 然后我们再更新这些可以更新的应用即可</p>
<p>输入  <code>winget list</code> 后普通不可更新的应用只有三列，可以更新的应用会有四列，第四列是它的最新版本号，表示这个应用有了更新，因此我们只需要更新这个应用即可 . 下面以 YesPlayMusic 为例 ，因为它可更新了. </p>
<p>输入： <code>winget upgrade qier222.yesplaymusic </code> 就行啦</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgp32ks30j21cc0t57wh.jpg"></p>
<p>然后会打印这样的信息，就表示更新成功. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">已找到 YesPlayMusic [qier222.yesplaymusic]</span><br><span class="line">此应用程序由其所有者授权给你. </span><br><span class="line">Microsoft 对第三方程序包概不负责，也不向第三方程序包授予任何许可证. </span><br><span class="line">Downloading https://github.com/qier222/YesPlayMusic/releases/download/v0.4.0/YesPlayMusic-Setup-0.4.0.exe</span><br><span class="line">  ██████████████████████████████  54.9 MB / 54.9 MB</span><br><span class="line">已成功验证安装程序哈希</span><br><span class="line">正在启动程序包安装...</span><br><span class="line">已成功安装</span><br></pre></td></tr></table></figure>

<br />

<h3 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h3><p>导出功能的话，我觉得还是很实用的. 比如说有时候我们重装系统或者想要将一台计算机当中的应用迁移到另外一台计算机当中. 那我们就可以先导出，然后再导入，再进行安装，十分的便利 . </p>
<p>导出命令为： <code>winget export &quot;E:/app.json&quot;</code></p>
<p>后面的路径及文件名自己定义就行. </p>
<p>对于不支持导出的应用的会报： 无法从任何源获得已安装的程序包 ，其余的都导出到指定的文件里面了. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">无法从任何源获得已安装的程序包: Bluetooth Audio Receiver</span><br><span class="line">无法从任何源获得已安装的程序包: Maple</span><br><span class="line">无法从任何源获得已安装的程序包: Ark View</span><br><span class="line">无法从任何源获得已安装的程序包: PDF Reader - View, Edit, Annotate</span><br><span class="line">无法从任何源获得已安装的程序包: 蒲云加速器 2.0.0</span><br><span class="line">无法从任何源获得已安装的程序包: Office</span><br><span class="line">无法从任何源获得已安装的程序包: 中国天气网</span><br><span class="line">无法从任何源获得已安装的程序包: 简约倒计时</span><br><span class="line">无法从任何源获得已安装的程序包: 哔哩</span><br><span class="line">无法从任何源获得已安装的程序包: 网易云音乐-电台</span><br><span class="line">无法从任何源获得已安装的程序包: 极光天气</span><br><span class="line">无法从任何源获得已安装的程序包: Newsflow</span><br><span class="line">无法从任何源获得已安装的程序包: 工具管家</span><br><span class="line">无法从任何源获得已安装的程序包: 彩虹工具箱 2.0.2</span><br></pre></td></tr></table></figure>

<p>就我体验而言，我觉得它的导出不太好用，因为很多很多的应用都无法导出. </p>
<p>导入的话与导出类似，也是输入命令行并指定文件路径即可</p>
<p><code>winget import  &quot;E:/app.json&quot;</code></p>
<br />

<h2 id="设置winget"><a href="#设置winget" class="headerlink" title="设置winget"></a>设置winget</h2><p>winget settings  打开 winget 的设置 json 文件进行配置，有需求的话可以在官方 <a href="https://github.com/microsoft/winget-cli/blob/master/doc/Settings.md">winget-cli&#x2F;Settings.md at master · microsoft&#x2F;winget-cli (github.com)</a> 这里看看怎么配置 . </p>
<p>如果想要更改 winget 显示的进度条视觉效果，可以 输入 winget settings  后在<code>setting.json</code>里增加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;visual&quot;: &#123;</span><br><span class="line">       &quot;progressBar&quot;: &quot;rainbow&quot;</span><br><span class="line">        // 三种样式可选：accent(默认值)、 retro、 rainbow</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>完整的json为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // For documentation on these settings, see: https://aka.ms/winget-settings</span><br><span class="line">    // <span class="string">&quot;source&quot;</span>: &#123;</span><br><span class="line">    //    <span class="string">&quot;autoUpdateIntervalInMinutes&quot;</span>: 5</span><br><span class="line">    // &#125;,</span><br><span class="line">    <span class="string">&quot;visual&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;progressBar&quot;</span>: <span class="string">&quot;rainbow&quot;</span></span><br><span class="line">         // 三种样式可选：accent(默认值)、 retro、 rainbow</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>这样子进度条就会变成彩虹色了，若没有更改设置json下的这个配置，也可以在安装的命令后面加上命令 –rainbow 来启用彩虹进度条.  比如 ： <code>winget install Musescore.Musescore --rainbow</code>  更改json后就不需要手动加 –rainbow 了. </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgpivchmhj21cc0t57wh.jpg" alt="手动 --rainbow"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/ba920825gy1grgpvc46bbj21cc0t5b29.jpg" alt="配置json后"></p>
<br />

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>还有这个其他的命令不太常用，因此我也就不演示了.  </p>
<p>比如: <code> winget show calibre</code> 可以显示应用的一些相关描述，还有下载链接的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> winget show calibre</span><br><span class="line">尝试更新源时失败： winget</span><br><span class="line">已找到 calibre [calibre.calibre]</span><br><span class="line">Version: 5.21.0</span><br><span class="line">Publisher: calibre</span><br><span class="line">Author: Kovid Goyal</span><br><span class="line">Moniker: calibre</span><br><span class="line">Description: calibre is an e-book manager. It can view, convert, edit and catalog e-books <span class="keyword">in</span> all of the major e-book formats. It can also talk to e-book reader devices. It can go out to the internet and fetch metadata <span class="keyword">for</span> your books. It can download newspapers and convert them into e-books <span class="keyword">for</span> convenient reading. It is cross platform, running on Linux, Windows and macOS.</span><br><span class="line">Homepage: https://calibre-ebook.com/</span><br><span class="line">License: GPL-3.0-only</span><br><span class="line">License Url: https://github.com/kovidgoyal/calibre/blob/master/LICENSE</span><br><span class="line">Installer:</span><br><span class="line">  Type: Msi</span><br><span class="line">  Locale: en-US</span><br><span class="line">  Download Url: https://download.calibre-ebook.com/5.21.0/calibre-64bit-5.21.0.msi</span><br><span class="line">  SHA256: 5ac8bbd813210a0d1e9b3c7a8852f11aeec15abcbb89ed2b6edd09f51240c44a</span><br></pre></td></tr></table></figure>







<p>所有支持的命令：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following commands are available:</span><br><span class="line">install    Installs the given package</span><br><span class="line">show       Shows information about a package</span><br><span class="line">source     Manage sources of packages</span><br><span class="line">search     Find and show basic info of packages</span><br><span class="line">list       Display installed packages</span><br><span class="line">upgrade    Upgrades the given package</span><br><span class="line">uninstall  Uninstalls the given package</span><br><span class="line">hash       Helper to hash installer files</span><br><span class="line">validate   Validates a manifest file</span><br><span class="line">settings   Open settings</span><br><span class="line">features   Shows the status of experimental features</span><br><span class="line">export     Exports a list of the installed packages</span><br><span class="line">import     Installs all the packages in a file</span><br></pre></td></tr></table></figure>
</blockquote>
<br />

<br />

<br />

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/package-manager/winget/">使用 winget 工具安装和管理应用程序 | Microsoft Docs</a></p>
<p><a href="https://github.com/microsoft/winget-cli/tree/master/doc">winget-cli&#x2F;doc at master · microsoft&#x2F;winget-cli (github.com)</a></p>
<p><a href="https://sspai.com/post/67005">这或许是 Windows 上最好的包管理工具：Windows Package Manager 1.0 - 少数派 (sspai.com)</a></p>
<p><a href="https://github.com/microsoft/winget-cli/issues/201">Add option to specify winget install directory · Issue #201 · microsoft&#x2F;winget-cli (github.com)</a></p>
<p><a href="https://www.pexels.com/zh-cn/photo/4503273/"> 可持續性的免费素材图片 (pexels.com)</a></p>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>叶上初阳干宿雨、水面清圆，一一风荷举. </p>
<p>–  周邦彦 《<a href="https://so.gushiwen.cn/shiwenv_faf9dc70bff2.aspx">苏幕遮·燎沉香</a>》</p>

</blockquote>



<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>通信专业网页工具和博客推荐</title>
    <url>/posts/1297.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162224324.jpg"></p>
<p>研究生阶段在学习通信(LTE&#x2F;5G)时偶遇到一些工具网站和不错的博客，在此分享给大家。</p>
<span id="more"></span>



<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="在线绘制-LTE资源网格"><a href="#在线绘制-LTE资源网格" class="headerlink" title="在线绘制 LTE资源网格"></a>在线绘制 LTE资源网格</h3><p><a href="http://dhagle.in/LTE">http://dhagle.in/LTE</a></p>
<p> 在线绘制 LTE资源网格 ，太棒了吧，还可以选各种参数。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152324749.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161119149.jpg"></p>
<p>可以根据自己的需求更改 FDD或者TDD 、带宽 、CP类型等等，然后点击 <code>Submit</code> 下方的资源网格就会刷新啦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162219187.png"></p>
<p>网页右上角这边还将不用信道资源的分配用不同颜色区分 ，对应着下方的各个 <code>RE</code> （资源网格上的每个元素称为一个RE Resource Element ，RE 是 LTE 中的最小物理资源，存放一个调制符号）。另外还有饼图列出了各个信道资源的比例，当然 PDSCH 占比是最大的，毕竟要传输业务数据。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162219651.png"></p>
<h3 id="在线绘制-LTE资源网格2"><a href="#在线绘制-LTE资源网格2" class="headerlink" title="在线绘制 LTE资源网格2"></a>在线绘制 LTE资源网格2</h3><p><a href="http://www.lte-bullets.com/">http://www.lte-bullets.com/</a></p>
<p>同样是一个绘制资源网格的工具，可以在 <a href="http://www.lte-bullets.com/visualisation_tool.html">lte-bullets</a> 的网站中下载。</p>
<blockquote>
<p>This tool is free to download and use. It models the allocation of  downlink Resource Elements to the set of Signals and Physical Channels.  The user can configure each of the variables which have an impact upon  the allocation of Resource Elements, e.g. the channel bandwidth, number  of transmit antenna and cell identity. The tool also quantifies  throughput for each modulation scheme and a range of assumed coding  rates.<br>       Results from the tool can be exported into a csv file for  subsequent viewing in Excel. An Excel Macro can be downloaded to read  and format the data.    </p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152325242.png"></p>
<p>安装好后，根据需求设置参数，点击左下角的按钮生成即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152326329.png"></p>
<p>  <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152326756.png"></p>
<p>  <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152327039.png"></p>
<p>还能计算出吞吐量什么的</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152350354.png"></p>
<p>还可以导出成 CSV 文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152350690.png"></p>
<h3 id="5G-NR-LTE-ARFCN-Frequency-Caculator-ARFCN频率计算"><a href="#5G-NR-LTE-ARFCN-Frequency-Caculator-ARFCN频率计算" class="headerlink" title="5G NR&#x2F;LTE ARFCN-Frequency Caculator &#x2F; ARFCN频率计算"></a>5G NR&#x2F;LTE ARFCN-Frequency Caculator &#x2F; ARFCN频率计算</h3><p><a href="https://itecspec.com/3gpp-arfcn-frequency-converter/">5G NR&#x2F;LTE ARFCN-Frequency Caculator (3GPP Specs) – TechSpec (itecspec.com)</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162154750.png"></p>
<h3 id="在线信道编码误码率-比较器"><a href="#在线信道编码误码率-比较器" class="headerlink" title="在线信道编码误码率 比较器"></a>在线信道编码误码率 比较器</h3><p><a href="https://aff3ct.github.io/comparator.html?curve0=162fd1d&curve1=de60d27&xaxis=Eb/N0&yaxes=BER,FER">https://aff3ct.github.io/comparator.html?curve0=162fd1d&amp;curve1=de60d27&amp;xaxis=Eb%2FN0&amp;yaxes=BER%2CFER</a></p>
<p>This page is an online tool dedicated to the <strong>Bit Error Rate (BER) and Frame Error Rate (FER) curve comparisons</strong>. Various type of codes are considered like <strong>the Turbo codes (LTE, LTE-Advanced, CCSDS, etc.), the Low-Density Parity-Check (LDPC) codes (5G, Wi-Fi, WiMAX, CCSDS, WRAN, DVB-S2, etc.), and the more recently introduced Polar codes (5G)</strong>.</p>
<p>本页面是一个在线工具，专门用于比特错误率(BER)和帧错误率(FER)曲线比较。 各种类型的码被认为像 Turbo 码(LTE，LTE-advanced，CCSDS 等) ，低密度奇偶校验(LDPC)码(5 g，Wi-Fi，WiMAX，CCSDS，wlan，DVB-S2等) ，以及最近引入的极性码(5 g)。</p>
<p>The presented results have been simulated with <a href="https://aff3ct.github.io/index.html">AFF3CT</a>: our Open-source communication chain dedicated to the Forward Error Correction (FEC) simulations. The simulated output text files are freely available on our dedicated <a href="https://github.com/aff3ct/error_rate_references/tree/development">GitHub repository</a>.</p>
<p>给出的结果已经被 AFF3CT 模拟: 我们的开源通信链专门用于前向错误更正通信系统(FEC)模拟。 模拟输出的文本文件可以在我们专用的 GitHub 存储库中免费获得。</p>
<p>Do you like the BER&#x2F;FER Comparator? Is it useful in your research works? If yes, you can thank us by citing the following journal article: <strong>A. Cassagne et al., “<a href="https://doi.org/10.1016/j.softx.2019.100345">AFF3CT: A Fast Forward Error Correction Toolbox!</a>,“ *SoftwareX*, 2019</strong>. </p>
<p>你喜欢 ber &#x2F; fer 比较器吗？ 它在你的研究工作中有用吗？ 如果答案是肯定的，你可以通过引用下面的期刊文章来感谢我们: a. Cassagne et A.. ，“ AFF3CT: 一个快速的前向错误更正工具箱！ ” SoftwareX，2019。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200522200211.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200522214142.png"></p>
<BR />



<h2 id="通信博客"><a href="#通信博客" class="headerlink" title="通信博客"></a>通信博客</h2><h3 id="ShareTechnote"><a href="#ShareTechnote" class="headerlink" title="ShareTechnote"></a>ShareTechnote</h3><p><a href="http://www.sharetechnote.com/">ShareTechnote</a></p>
<p>鼎鼎大名的ShareTechnote ，没看过就真的很不应该了， 很多2345G、IoT、WIFI等等协议的解读 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162129758.png"></p>
<h3 id="techplayon"><a href="#techplayon" class="headerlink" title="techplayon"></a>techplayon</h3><p><a href="http://www.techplayon.com/5gnr/">http://www.techplayon.com/5gnr/</a></p>
<p>很多有关5G相关的协议分享与解读，很值得一读。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152356751.png"></p>
<h3 id="How-LTE-Stuff-Works"><a href="#How-LTE-Stuff-Works" class="headerlink" title="How LTE Stuff Works?"></a>How LTE Stuff Works?</h3><p><a href="http://howltestuffworks.blogspot.com/">http://howltestuffworks.blogspot.com/</a></p>
<p>别被名字误会，里面有的内容不仅仅是LTE，还包括5G。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210152357158.png"></p>
<h3 id="5G-NBIOT-LTE-Question-Answers"><a href="#5G-NBIOT-LTE-Question-Answers" class="headerlink" title="5G NBIOT LTE Question Answers"></a>5G NBIOT LTE Question Answers</h3><p><a href="https://www.blacktechnoguys.com/">https://www.blacktechnoguys.com/</a></p>
<blockquote>
<p>Hi, I am a tech freak and specifically a Telecom Enthusiast. I have always been interested in how our mobile phones communicate with the network and each other. I have created this blog to answer the basic and advanced questions that covers basics as far as 4G, NB-IoT and 5G are concerned. The main objective of this blog is to answer all the possible questions related to same that will help our fellow friends to enhance there skills in related filed.</p>
<p>你好，我是一个科技迷，特别是一个电信爱好者。我一直对我们的移动电话如何与网络和彼此之间进行通信很感兴趣。我创建这个博客是为了回答一些基本的和高级的问题，这些问题涵盖了4G、 NB-IoT 和5G 的基本知识。这个博客的主要目的是回答所有可能的问题相同，将帮助我们的朋友提高有关领域的技能。</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210160001513.png"></p>
<h3 id="Long-Term-Evolution-4G"><a href="#Long-Term-Evolution-4G" class="headerlink" title="Long Term Evolution | 4G"></a>Long Term Evolution | 4G</h3><p><a href="https://ltebasics.wordpress.com/">Long Term Evolution | 4G – Get LTE Basics </a></p>
<p>介绍LTE与5G NR 相关的技术。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162232521.png"></p>
<h3 id="BLOG-CommResearch"><a href="#BLOG-CommResearch" class="headerlink" title="BLOG | CommResearch"></a>BLOG | CommResearch</h3><p><a href="https://www.commresearch.com.tw/Blog/Index.aspx#4">BLOG | CommResearch</a></p>
<p>台湾的有关通信的博客。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162122759.png"></p>
<h3 id="ZCL-SPACE"><a href="#ZCL-SPACE" class="headerlink" title="ZCL.SPACE"></a>ZCL.SPACE</h3><p><a href="https://zlearning.netlify.app/">ZCL.SPACE (zlearning.netlify.app)</a></p>
<p>很多数学与通信知识，通信协议解读‘仿真等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162125683.png"></p>
<h3 id="dspLog-Signal-processing-for-communication"><a href="#dspLog-Signal-processing-for-communication" class="headerlink" title="dspLog - Signal processing for communication"></a><a href="http://www.dsplog.com/">dspLog - Signal processing for communication</a></h3><p><a href="http://www.dsplog.com/">dspLog - Signal processing for communication</a></p>
<p>非常棒的一个网站，会详细的介绍如何写仿真代码，里面有很多MIMO的代码值得参考学习。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/202210162157302.png"></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><p><a href="https://www.txrjy.com/forum.php">通信人家园 论坛|通信社区 - Powered by C114 (txrjy.com)</a></p>
</li>
<li><p><a href="https://www.witimes.com/">无线时代 | 个人博客 (witimes.com)</a></p>
</li>
<li><p><a href="http://sdr-x.github.io/">SDR-X</a></p>
</li>
<li><p><a href="http://www.hackrf.net/">HackRF.net</a> ： 开源SDR。</p>
</li>
<li><p><a href="https://blog.csdn.net/m0_45416816?type=blog">我就是你们要找的张小建的博客_CSDN博客-5G NR AS,其他,5G NR R16领域博主</a></p>
</li>
<li><p><a href="https://blog.csdn.net/m_052148?type=blog">阿米尔C的博客_CSDN博客-4GLTE协议开发,5GNR协议开发,其它领域博主</a></p>
</li>
<li><p><a href="https://blog.csdn.net/littleBird_2?type=blog">littleBird_2的博客_CSDN博客-5G,NR,LTE领域博主</a></p>
</li>
<li><p><a href="https://zhuyulab.blog.csdn.net/?type=blog">B417科研笔记的博客_CSDN博客-通信中的常用数学,python,深度学习领域博主</a></p>
</li>
<li><p><a href="https://blog.csdn.net/kakamilan?type=blog">5G菜鸟成长日记的博客_CSDN博客-5G,通信算法,计算机领域博主</a></p>
</li>
<li><p><a href="https://www.cablelabs.com/blog/join-cablelabs-cable-next-gen-conference">Join CableLabs Experts at Light Reading’s Annual Cable Next-Gen Conference - CableLabs</a></p>
</li>
<li><p><a href="https://www.zhihu.com/column/xzclass">鲜枣课堂 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/fu-you-cai-cai/posts">无线深海 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://www.techplayon.com/tar-gz-linux-tar-command-examples/">tar.gz - Linux tar command examples - Techplayon</a></p>
</li>
<li><p><a href="https://najeebgafar.com/multi-language-laravel-8-project/">Multi language Laravel 8 project - Najeebgafar</a></p>
</li>
<li><p><a href="https://pupuweb.com/">PUPUWEB - Information Resource for Emerging Technology Trends and Cybersecurity</a></p>
</li>
<li><p><a href="https://wirelesspi.com/articles/">Articles - Wireless Pi</a></p>
</li>
<li><p><a href="https://blog.3g4g.co.uk/">The 3G4G Blog</a></p>
</li>
</ul>
<BR />

<h2 id="源码仓库"><a href="#源码仓库" class="headerlink" title="源码仓库"></a>源码仓库</h2><h3 id="New-Radio-5G-Utils-5-g-utils"><a href="#New-Radio-5G-Utils-5-g-utils" class="headerlink" title="New_Radio_5G_Utils 5 g utils"></a><a href="https://prtkmishra.github.io/New_Radio_5G_Utils/">New_Radio_5G_Utils 5 g utils</a></h3><p><a href="https://prtkmishra.github.io/New_Radio_5G_Utils/">https://prtkmishra.github.io/New_Radio_5G_Utils&#x2F;</a></p>
<p>This repository contains Physical layer utilities based on 3GPP specs for NR 5G</p>
<p>该存储库包含基于3GPP 规范的 NR 5G 物理层实用程序</p>
<blockquote>
</blockquote>
<p>其它源码仓库后续补充。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>Spotify桌面端去广告教程（Windows/Mac/Linux)</title>
    <url>/posts/54657.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402142104401.jpg"></p>
<p>Spotify桌面端去广告教程（Windows&#x2F;Mac&#x2F;Linux)。屏蔽客户端中的所有横幅、视频和音频广告，Unlocks the skip function of any track，从主页隐藏播客、剧集和有声读物(可选)。</p>
<span id="more"></span>

<h2 id="Windows端"><a href="#Windows端" class="headerlink" title="Windows端"></a>Windows端</h2><p>关闭spotify桌面端，在 <a href="https://github.com/SpotX-CLI/SpotX-Win">SpotX-CLI&#x2F;SpotX-Win: Blocking ads and updates for the desktop version of Spotify, disabling podcasts and more. (github.com)</a> 复制以下命令在Windows的PowerShell执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; (iwr -useb <span class="string">&#x27;https://raw.githubusercontent.com/SpotX-CLI/SpotX-Win/main/Install.ps1&#x27;</span>).Content | iex</span><br></pre></td></tr></table></figure>

<p>根据你的喜好输入y或n来调整脚本的一些功能，也可以和我输一样的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202307161119830.jpg" alt="脚本执行过程"></p>
<p>另一种方式是下载 <a href="https://raw.githack.com/SpotX-CLI/SpotX-Win/main/Install.bat">Install.bat</a> 然后执行即可。</p>
<p>要想卸载可以下载并执行 <a href="https://raw.githack.com/SpotX-CLI/SpotX-Win/main/Uninstall.bat">Uninstall.bat</a> ，或者直接卸载重新安装spotify也可以。</p>
<blockquote>
<p>脚本特性</p>
<ul>
<li><strong>Blocks all banner, video and audio ads in the client</strong></li>
<li>屏蔽客户端中的所有横幅、视频和音频广告</li>
<li><strong>Unlocks the skip function of any track</strong></li>
<li>解锁任何轨道的跳跃功能</li>
<li><strong>Hiding podcasts, episodes and audiobooks from the homepage (optional)</strong></li>
<li>从主页隐藏播客、剧集和有声读物(可选)</li>
<li><strong>Block Spotify automatic updates (optional) 阻止 Spotify 自动更新(可选)</strong></li>
<li><strong>Automatic clearing of <a href="https://github.com/SpotX-CLI/SpotX-Win/discussions/2">audio cache</a> (optional)</strong></li>
<li>自动清除音频缓存(可选)</li>
<li><strong>More experimental features have been activated (<a href="https://github.com/SpotX-CLI/SpotX-Win/discussions/50">see the full list</a>)</strong></li>
<li>更多的实验特性已经被激活(见完整列表)</li>
<li><strong>Disabled Sentry (Prevented Sentry from sending console log&#x2F;error&#x2F;warning to Spotify developers)</strong></li>
<li>禁用哨兵(防止哨兵向 Spotify 开发人员发送控制台日志&#x2F;错误&#x2F;警告)</li>
<li><strong>Disabled logging (Stopped various elements to log user interaction)</strong></li>
<li>禁用日志记录(停止各种元素以记录用户交互)</li>
<li><strong>Removed RTL rules (Removed all right-to-left CSS rules to simplify CSS files)</strong></li>
<li>删除了 RTL 规则(删除了所有从右到左的 CSS 规则以简化 CSS 文件)</li>
<li><strong>Code minification 代码简化</strong></li>
</ul>
</blockquote>
 <br />

<h2 id="Mac端"><a href="#Mac端" class="headerlink" title="Mac端"></a>Mac端</h2><p>关闭spotify桌面端，在 <a href="https://github.com/SpotX-CLI/SpotX-Mac">SpotX-CLI&#x2F;SpotX-Mac: Spotify Ad blocker based on SpotX for MacOS (github.com)</a>  复制以下命令在终端执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sSL https://raw.githubusercontent.com/SpotX-CLI/SpotX-Mac/main/install.sh)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以带一些参数，支持的参数有</p>
<p><code>-c</code> Clear app cache – use if UI-related patches aren’t working<br><code>-e</code> Experimental features – enables experimental features<br><code>-E</code> Exclude feature – disables specified feature(s) [currently only supports <code>leftsidebar</code>]<br><code>-f</code> Force patch – forces re-patching if backup detected<br><code>-h</code> Hide podcasts, episodes and audiobooks on home screen<br><code>-o</code> Old UI – skips forced ‘new UI’ patch<br><code>-p</code> Premium subscription setup – use if premium subscriber<br><code>-u</code> Update block – blocks automatic updates</p>
</blockquote>
<p>卸载请执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sSL https://raw.githubusercontent.com/SpotX-CLI/SpotX-Mac/main/uninstall.sh)</span><br></pre></td></tr></table></figure>

<p>或者直接卸载重新安装spotify也可以。</p>
<br />

<h2 id="Linux端"><a href="#Linux端" class="headerlink" title="Linux端"></a>Linux端</h2><p>关闭spotify桌面端，在 <a href="https://github.com/SpotX-CLI/SpotX-Linux">SpotX-CLI&#x2F;SpotX-Linux: Spotify Ad blocker based on SpotX for Linux (github.com)</a> 复制以下命令在终端执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sSL https://raw.githubusercontent.com/SpotX-CLI/SpotX-Linux/main/install.sh)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以带一些参数，支持的参数有</p>
<p><code>-c</code> Clear app cache – use if UI-related patches aren’t working<br><code>-e</code> Experimental features – enables experimental features<br><code>-f</code> Force patch – forces re-patching if backup detected<br><code>-P</code> Path directory – manually set Spotify directory if not found in PATH<br><code>-p</code> Premium subscription setup – use if premium subscriber</p>
</blockquote>
<p>卸载请执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sSL https://raw.githubusercontent.com/SpotX-CLI/SpotX-Linux/main/uninstall.sh)</span><br></pre></td></tr></table></figure>

<p>或者直接卸载重新安装spotify也可以。</p>
<br />

<p>接下来请尽情享受音乐。🎉🎉</p>
<br />

<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains全家桶及插件激活方式</title>
    <url>/posts/23379.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402142124323.jpg"></p>
<p>JetBrains产品全版本及插件激活（Windows&#x2F;Mac&#x2F;Linux）。</p>
<span id="more"></span>







<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol>
<li><p>打开 <a href="https://3.jetbra.in/">JETBRA.IN CHECKER | IPFS</a> 选择一个链接为绿色的网址点进去。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20221112214802934.png"></p>
</li>
<li><p>下载并解压jetbra.zip，放到一个目录，别删除解压后的文件夹。</p>
</li>
</ol>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20221112215141800.png" alt="点这里下载"></p>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>Windows 双击执行 scripts\install-all-users.vbs</p>
<p>(Mac &#x2F; Linux)在终端执行 scripts&#x2F;install.sh </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20221112215611926.png" alt="windows为例"></p>
<blockquote>
<p>脚本的好处就是不用手动去修改 vmoptions 那个文件了。</p>
<p>可以打开 vmoptions 看一看。</p>
</blockquote>
<blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012305147.jpeg"></p>
<p><strong>一键脚本的原理是什么?</strong></p>
<p>设置环境变量 <IDE>_VM_OPTIONS 指向 ja-netfilter包里的vmoptions文件 ,同时这个文件会自动配置-javaagent ,  这里<IDE>为IDE的名称,比如 IDEA&#x2F;CLION&#x2F;PYCHARM 等</p>
<p>IDE启动之后优先使用<IDE>_VM_OPTIONS 指向的vmoptions文件</p>
<p>注:</p>
<p>一键脚本会对多个IDE设置相应的vmoptions环境变量,</p>
<p>如果你只想为特定IDE设置,修改脚本中的 aJBProducts 变量</p>
<p><a href="https://chip-tail-e93.notion.site/Ja-netfilter-9886afbfe1ed4d5e90a713e63718f647#0d7a3a8faac040d386ece668e1ea31a2">Ja-netfilter常见问题解答,进群必看! (notion.site)</a></p>
</blockquote>
<h2 id="激活IDE"><a href="#激活IDE" class="headerlink" title="激活IDE"></a>激活IDE</h2><p>打开 JetBrains 的 IDE，比如 IntelliJ IDEA Ultimate ，IDE会提示你激活，如果没有可以打开 Help -&gt; register 。如果已有账号登陆就点击 remove license 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012305466.jpeg" alt="移出已有license"></p>
<p>然后选择 activation code 激活码进行激活，来到  <a href="https://3.jetbra.in/">JETBRA.IN CHECKER | IPFS</a>  您下载压缩包的网址，鼠标点击一下就会复制到激活码到剪切板，然后将激活码粘贴到下面第二个图那里的区域，点击 activate 激活即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20221112220435915.png" alt="复制激活码"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012306342.jpeg" alt="输入激活码激活"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012306285.jpeg" alt="激活成功"></p>
<h2 id="激活插件"><a href="#激活插件" class="headerlink" title="激活插件"></a>激活插件</h2><p>同理，去 <a href="https://3.jetbra.in/">JETBRA.IN CHECKER | IPFS</a>  您下载压缩包的网址，找到您需要激活的插件，鼠标点击一下就会复制到激活码到剪切板，然后粘贴再 activate 激活即可。比如 BashSupport Pro。 插件有很多，可以CTRL+F 搜关键字找到。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012306262.jpeg"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202305012307597.jpeg" alt="插件激活成功"></p>
<p>请勿商用，仅供个人测试使用。</p>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>青山隐隐水迢迢，秋尽江南草未凋。</p>
<p>——  唐  杜牧</p>

</blockquote>



<br />

<br />

<br />
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>开源软件商店 WingetUI 使用教程</title>
    <url>/posts/34001.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231716883.jpg"></p>
<p>在<a href="https://www.lifeee.top/posts/36943.html">包管理器 winget 使用指南 | 热夏的博客 (lifeee.top)</a> 一文中介绍了利用 winget 来查找&#x2F;安装&#x2F;更新&#x2F;卸载软件，这种方式是利用终端来进行的。而<a href="https://www.marticliment.com/wingetui/">WingetUI</a>则是一款封装了常见包管理器的可视化GUI软件，本文将为大家介绍 WingetUI 的安装以及使用方法。</p>
<span id="more"></span>



<br />



<p><a href="https://www.marticliment.com/wingetui/">WingetUI</a> 是一款封装了常见包管理器的可视化GUI软件，其可以管理  <a href="https://learn.microsoft.com/en-us/windows/package-manager/">Winget</a>、 <a href="https://scoop.sh/">Scoop</a>、 <a href="https://chocolatey.org/">Chocolatey</a>、<a href="https://pypi.org/">Pip</a> 和 <a href="https://www.npmjs.com/">Npm</a> 的软件或开发包。 WingetUI 目前可以运行在Windows 10 和 Windows 11上。</p>
<p>WingetUI 官网：<a href="https://www.marticliment.com/wingetui/">https://www.marticliment.com/wingetui/</a></p>
<p>WingetUI 有以下特点：</p>
<ul>
<li>WingetUI 能够从 Winget（包括 Microsoft Store）、Scoop、Chocolatey、pip 和 npm 安装、更新和卸载软件包。 WingetUI 可以检测我们手动安装的应用程序是否可以更新。</li>
<li>可以升级和卸载以前安装的软件包，以及卸载内置的 Windows 应用程序。</li>
<li>WingetUI 能够导入和导出软件包，重装系统的时候似乎很有用。😁</li>
<li>WingetUI 在安装前显示软件包相关信息（如许可证、SHA256 哈希值、主页等）。</li>
<li>有超过 14000 个可用软件包（如果启用 Winget、Scoop 和 Chocolatey）</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 WingetUI 多种方法：</p>
<ul>
<li><p><strong><a href="https://github.com/marticliment/WingetUI/releases/latest/download/WingetUI.Installer.exe">点击此处</a></strong> 在github下载WingetUI进行安装。</p>
<p>直接点击 ok ， 然后点击next</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231403975.png"></p>
<p>选择一个安装位置，点击next，进行安装。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231404004.png" style="zoom:80%;" />

<p>第一次启动 WingetUI 会让选择模式，默认设置和定制 WingetUI 模式。推荐不编程的同学选择默认设置，编程且比较极客的同学选择定制 WingetUI 模式。（默认模式和定制模式区别在于：默认模式不启用Scoop、pip 和 npm 这几个软件源，后面可以在设置中启用）</p>
<p>我这里是选择了定制WingetUI 模式。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231407221.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231411033.png" alt="第一次打开是这个样子的"></p>
</li>
<li><p><strong>通过Winget安装WingetUI：</strong></p>
<p>如果您已经安装了 <a href="https://learn.microsoft.com/en-us/windows/package-manager/">Winget</a> ，请执行以下命令来通过 Winget 安装 WingetUI  （<a href="https://www.lifeee.top/posts/36943.html">winget 安装看这里</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install wingetui</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 Scoop 安装 WingetUI：</strong></p>
<p>如果您已经安装了 <a href="https://scoop.sh/">Scoop</a> ，请执行以下两条命令来通过 Scoop 安装 WingetUI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line"></span><br><span class="line">scoop install extras/wingetui</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="搜索-安装软件"><a href="#搜索-安装软件" class="headerlink" title="搜索&#x2F;安装软件"></a>搜索&#x2F;安装软件</h2><p>安装好WingetUI ，点击下图中的①进入搜索页面，在②中输入软件名称进行搜索，在搜索列表中选中想要安装的软件 然后右键点击安装，如图中的③ （也可以选则交互式安装）。要是设置了多个软件源也可以在搜索结束后点击④ “来源” 来按软件源排序，比如我这里就是 winget 排在最前面。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309230020425.png"></p>
<p>若想要查看软件的信息，可以在上图③中选择软件包详情来查看详细信息。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309230028893.png"></p>
<p>如下图①所示，还可以设置要安装的版本，默认是最新。安装的范围，当前用户还是所以用户。</p>
<p>设置完后可以点击②就会按照设定的这些偏好进行安装。</p>
<p>另一种方式是用命令行安装，设置完①后③那里的命令行会自动变化。然后复制命令行在终端执行进行安装。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309230033369.png"></p>
<blockquote>
<p>比较遗憾的是 目前不支持直接设置软件安装的位置。它是通过使用 Winget、Scoop、Chocolatey、Pip 和 Npm 这些包管理器来安装软件包的，这些包管理器默认会将软件安装到其指定的默认安装位置。</p>
<p>对于 Winget 来说，默认情况下，它将软件安装到系统的默认应用程序安装目录（通常是 <code>C:\Program Files</code>）。</p>
<p><a href="https://www.lifeee.top/posts/36943.html">包管理器 winget 使用指南 </a> 这篇文章介绍了<strong>更改安装路径</strong> 的方法。通过 <code>--location</code> 参数来指定软件包的安装位置。但是，WingetUI 目前没有提供界面选项来设置安装位置。</p>
<p>如果希望更精细地控制软件的安装位置，可以考虑直接使用 Winget 命令行工具来安装软件，并通过 <code>--location</code> 参数指定安装位置。以下是使用 Winget 命令行工具安装软件并指定安装位置的示例命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install &lt;package&gt; --location &lt;installation_path&gt;</span><br></pre></td></tr></table></figure>

<p>请将 <code>&lt;package&gt;</code> 替换为软件包的名称，将 <code>&lt;installation_path&gt;</code> 替换为您希望指定的安装位置路径。</p>
<p>比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">winget install EliasFotinis.DeskPins -l <span class="string">&quot;D:\20200213\Tools\DeskPins&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>若需要指定安装路径，则千万切记一定要指定一个空的文件夹作为路径，否则卸载的话会把该路径下的东西全部都给删除了.⚡⚡⚡</strong></p>
<p>我自己比较喜欢在 WingetUI 上右击打开软件包详情页，然后补充上参数，再复制参数到终端进行安装。比如：</p>
<p>在下图①出补充上安装位置参数 <code>-l &quot;D:\20200213\Tools\rss&quot;</code> ，然后点击②复制到终端安装。 （有些软件不支持设置安装路径就没法设置了，比如有些exe文件，点击后都不出安装界面就给你默认安装到C盘了）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231644643.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231646142.png" alt="安装中"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231652447.png" alt="果然安装到了该目录"></p>
</blockquote>
<h2 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h2><p>更新软件操作可以点击下图的①，来到软件更新界面。</p>
<p>要想更新某个软件可以右击选择更新，也可以选择软件包详情，然后进行选择某个历史版本进行更新。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231120981.png"></p>
<p>也可以同是选中多个需要更新的软件，然后点击下图中的②进行更新。（点击③可以全选 点击④可以取消全选 ⭐）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231122709.png"></p>
<p>点击更新所选软件包后，下图①会显示当前在更新的软件包，②处显示在队列中即将更新的软件包。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231126241.png"></p>
<h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><p>卸载软件操作可以点击下图的①，来到已安装软件界面。</p>
<p>要想卸载某个软件可以右击选择卸载，也可以多选然后点击③进行卸载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231132250.png"></p>
<h2 id="软件包导出-导入-重装系统或迁移系统必备"><a href="#软件包导出-导入-重装系统或迁移系统必备" class="headerlink" title="软件包导出&#x2F;导入  重装系统或迁移系统必备"></a>软件包导出&#x2F;导入  重装系统或迁移系统必备</h2><p>在 <a href="https://www.lifeee.top/posts/36943.html">包管理器 winget 使用指南 | 热夏的博客 (lifeee.top)</a> 介绍了使用命令行的导出导入方式。接下来我们看下使用WingetUI怎么操作。</p>
<p>手动选择想要导出的软件包，然后点击导出所选软件包到文件③进行导出。也可以点击②全选，然后导出。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231139307.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231140312.png" alt="点击导出"></p>
<p>导出后，只需要保存好导出的 <code>json</code> 文件就好了，重装系统的时候将这个文件导入进来。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231142706.png" alt="导出的文件长这个样子"></p>
<p>在需要安装软件的电脑安装前面的介绍安装好 WingetUI ，然后把前面导出的 <code>json</code> 文件放你现在需要导入软件的电脑的某个目录下。然后进行下面的操作：</p>
<p>导入的时候，点击①发现软件包，然后点击②从文件导入软件包，接着选中我们的 <code>json</code> 文件。会列举出导入的软件包list，若是不想安装某个软件可以点击③这里的垃圾桶移除掉，最后点击④即可安装。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231148353.png"></p>
<p>简单吧，可以避免我们重装系统后一个一个的去下载、安装，非常节约时间。</p>
<p>此外，WingetUI 还可以设置一些偏好，安装权限，Winget Scoop、Chocolatey、pip 和 npm软件源的一些偏好等，大家可以自行设置。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202309231325901.png"></p>
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第21期：我爱Flutter🎉</title>
    <url>/posts/57809.html</url>
    <content><![CDATA[<p>在第21期的网上冲浪周刊中，我们将为您介绍以下内容：猫哥整理了一份精致的Flutter插件收录，为开发者提供了更方便的工具。同时，macos_ui为Flutter带来了与macOS设计语言相符的组件和主题。</p>
<p>推荐阅读方面，Kotlin技术月报带来了一系列重要消息，包括Kotlin 1.9.20版本发布、Compose Multiplatform 1.5.10版本发布等。而2024年的Kotlin Multiplatform发展路线图更是让人瞩目，特别是Compose for iOS即将进入Beta版阶段。</p>
<p>有趣的工具方面，谷歌即将推出的AI大模型Gemini引人关注，能够无缝融合图像、音频、视频、代码等多个领域。而今日热榜、多摸鱼等工具为用户提供了便捷的获取热门资讯的途径。</p>
<p>宝藏信息方面，手绘线条插画网站bon.design提供了简洁极简的插画素材，而Poe AI平台的StableDiffusionXL图像生成机器人则为艺术创作者提供了创新灵感的空间。</p>
<p>在资讯板块，Google DevFest活动分享了Android开发、Kotlin元编程技术、Jetpack Compose等热门主题。而VSCode最新版本的上线，为开发者带来了更多便捷和功能改进。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402142120298.jpg" alt="杭州青山湖"></p>
<span id="more"></span>





<p>欢迎来到第21期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top///atom.xml">https://www.lifeee.top///atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="Flutter优秀插件收录"><a href="#Flutter优秀插件收录" class="headerlink" title="Flutter优秀插件收录"></a>Flutter优秀插件收录</h2><p><a href="https://flutter.ducafecat.com/pubs/user-journey">Flutter优秀插件</a> 是由哔哩哔哩up主<a href="https://space.bilibili.com/404904528/">猫哥</a>维护的一个项目，收录了flutter比较好用的插件包。</p>
<p>在线地址：<a href="https://flutter.ducafecat.com/pubs/user-journey">https://flutter.ducafecat.com/pubs/user-journey</a></p>
<p>猫哥哔哩哔哩：<a href="https://space.bilibili.com/404904528/">https://space.bilibili.com/404904528/</a></p>
<p>猫哥YouTube：<a href="https://www.youtube.com/@ducafecat">https:&#x2F;&#x2F;www.youtube.com&#x2F;@ducafecat</a></p>
<p>猫哥的博客：<a href="https://ducafecat.com/blog">https://ducafecat.com/blog</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082059738.png"></p>
<h2 id="macOS-Flutter-组件和主题包-macos-ui"><a href="#macOS-Flutter-组件和主题包-macos-ui" class="headerlink" title="macOS Flutter 组件和主题包 macos_ui"></a>macOS Flutter 组件和主题包 macos_ui</h2><p><a href="https://github.com/macosui/macos_ui#macoswindow">macos_ui</a> 实现当前 macOS 样式的 Flutter 组件和主题。</p>
<p>本文介绍了该 macos_ui 包，它提供了实现当前 macOS 设计语言的 Flutter 小部件和主题。它解释了如何使用该包，包括配置窗口、创建侧边栏、使用 SliverToolBar、创建单选按钮以及使用各种 UI 组件（如文本字段、进度圈和级别指示器）。</p>
<p>官网：<a href="https://macosui.dev/">https://macosui.dev</a></p>
<p>开源地址：<a href="https://github.com/macosui/macos_ui">https://github.com/macosui/macos_ui</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082115979.png"></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/1azwMoOaNxEnyBUeZz3xXg">Kotlin 技术月报 | 2023 年 11 月 </a>：Kotlin 1.9.20 版本发布；Compose Multiplatform 1.5.10 版本发布：最佳的入门时机；KMP 2024 路线图发布；Kotlin 在 Github 2023 语言排行榜中进入 Top 12；</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1O-ulQWI1Q5sHXIeG7tPWg">2024 年 Kotlin Multiplatform 发展路线图 | 官方博客</a>：JetBrains 计划在 2024年对核心 Kotlin Multiplatform 技术、Compose Multiplatform、KMP 工具和 KMP 库做出一系列深入改进；主要关注点是让 <strong>Compose for iOS 进入 Beta 版阶段</strong>；还将继续探索 Compose for Web 的可能，特别是 Wasm。</p>
</li>
<li><p>[一起看 I&#x2F;O | Flutter 3 更新详解(<a href="https://mp.weixin.qq.com/s/wdvLHEI-JobQOGaruDNO8g">https://mp.weixin.qq.com/s/wdvLHEI-JobQOGaruDNO8g</a>)：仅 3 个月前，Flutter 宣布了 <a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652093957&idx=1&sn=ea81d1afb73debffd428ef5293c08549&chksm=808c1e40b7fb97567e98dac4ac38dc907d348270c1c4caec18cbe81021665f9f49b0c923f09a&scene=21#wechat_redirect">Flutter 对 Windows 的支持</a>。继 Windows 之后，Flutter 现已稳定支持 macOS 和 Linux！强强强啊！</p>
</li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="谷歌即将推出AI大模型Gemini"><a href="#谷歌即将推出AI大模型Gemini" class="headerlink" title="谷歌即将推出AI大模型Gemini"></a>谷歌即将推出AI大模型Gemini</h2><p> 隆重推出 Gemini，这是谷歌最大、最强大的 AI 模型，可无缝融合图像、音频、视频、代码等。从 12 月 13 日开始，开发人员将能够通过 Google AI Studio 中的 API 使用 Gemini Pro 进行构建。</p>
<p>了解更多： <a href="http://goo.gle/how-its-made-gemini">http://goo.gle/how-its-made-gemini</a> </p>
<p>官网：<a href="https://deepmind.google/technologies/gemini/#introduction">https://deepmind.google/technologies/gemini</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082200799.png"></p>
<h2 id="今日热榜"><a href="#今日热榜" class="headerlink" title="今日热榜"></a><a href="https://tophub.today/">今日热榜</a></h2><p><a href="https://tophub.today/">今日热榜官网 (tophub.today)</a>是一个汇聚了各类热门话题和新闻的网站。该平台通过实时更新，呈现用户当前最受关注和讨论的内容，涵盖了社会、科技、娱乐、体育等多个领域。用户可以在今日热榜上一览热门事件，浏览热门话题的相关新闻、评论和讨论，以获取最新、最热的资讯。这个网站的独特之处在于它提供了一个集中展示当下社会关注点的平台，为用户提供了一个便捷的了解时事热点的途径。</p>
<p>网站：<a href="https://tophub.today/">https://tophub.today/</a></p>
<p>APP下载：<a href="https://tophub.today/app">https://tophub.today/app</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082105481.png"></p>
<h2 id="又一个今日热榜-全站热榜-rebang-today-？"><a href="#又一个今日热榜-全站热榜-rebang-today-？" class="headerlink" title="又一个今日热榜 - 全站热榜 (rebang.today)？"></a>又一个<a href="https://rebang.today/">今日热榜 - 全站热榜 (rebang.today)</a>？</h2><p>又一个今日热榜，不过似乎上面那个<a href="https://tophub.today/">今日热榜官网 (tophub.today)</a>是先出现的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082108987.png"></p>
<h2 id="多摸鱼-全网资讯一站式浏览"><a href="#多摸鱼-全网资讯一站式浏览" class="headerlink" title="多摸鱼 - 全网资讯一站式浏览"></a><a href="https://duomoyu.com/">多摸鱼 - 全网资讯一站式浏览</a></h2><p><a href="https://duomoyu.com/">多摸鱼 - 全网资讯一站式浏览 (duomoyu.com)</a>是一个在线网站，汇集了各大平台的热榜，比如微博、知乎、V2ex等 网站：<a href="https://duomoyu.com/">https://duomoyu.com/</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082106129.png"></p>
<h2 id="Bililive-Go-一个支持多种直播平台的直播录制工具"><a href="#Bililive-Go-一个支持多种直播平台的直播录制工具" class="headerlink" title="Bililive Go - 一个支持多种直播平台的直播录制工具"></a>Bililive Go - 一个支持多种直播平台的直播录制工具</h2><p><a href="https://github.com/hr3lxphr6j/bililive-go">bililive-go</a> 是一个直播录制工具。</p>
<p><strong>支持的网址有：</strong></p>
<table>
<thead>
<tr>
<th>站点</th>
<th>url</th>
<th>支持情况</th>
<th>cookie</th>
</tr>
</thead>
<tbody><tr>
<td>Acfun直播</td>
<td>live.acfun.cn</td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>哔哩哔哩直播</td>
<td>live.bilibili.com</td>
<td>滋瓷</td>
<td>滋瓷</td>
</tr>
<tr>
<td>战旗直播</td>
<td><a href="http://www.zhanqi.tv/">www.zhanqi.tv</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>斗鱼直播</td>
<td><a href="http://www.douyu.com/">www.douyu.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>火猫直播</td>
<td><a href="http://www.huomao.com/">www.huomao.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>龙珠直播</td>
<td>longzhu.com</td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>虎牙直播</td>
<td><a href="http://www.huya.com/">www.huya.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>CC直播</td>
<td>cc.163.com</td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>一直播</td>
<td><a href="http://www.yizhibo.com/">www.yizhibo.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>twitch</td>
<td><a href="http://www.twitch.tv/">www.twitch.tv</a></td>
<td>TODO</td>
<td></td>
</tr>
<tr>
<td>OPENREC</td>
<td><a href="http://www.openrec.tv/">www.openrec.tv</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>企鹅电竞</td>
<td>egame.qq.com</td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>浪live</td>
<td>play.lang.live &amp; <a href="http://www.lang.live/">www.lang.live</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>花椒</td>
<td><a href="http://www.huajiao.com/">www.huajiao.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>抖音直播</td>
<td>live.douyin.com</td>
<td>滋瓷</td>
<td>滋瓷</td>
</tr>
<tr>
<td>猫耳</td>
<td>fm.missevan.com</td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>克拉克拉</td>
<td><a href="http://www.hongdoufm.com/">www.hongdoufm.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>快手</td>
<td>live.kuaishou.com</td>
<td>滋瓷</td>
<td>滋瓷</td>
</tr>
<tr>
<td>YY直播</td>
<td><a href="http://www.yy.com/">www.yy.com</a></td>
<td>滋瓷</td>
<td></td>
</tr>
<tr>
<td>微博直播</td>
<td>weibo.com</td>
<td>滋瓷</td>
<td></td>
</tr>
</tbody></table>
<p>开源地址：<a href="https://github.com/hr3lxphr6j/bililive-go">https://github.com/hr3lxphr6j/bililive-go</a></p>
<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="手绘线条插画网站"><a href="#手绘线条插画网站" class="headerlink" title="手绘线条插画网站"></a><a href="https://bon.design/">手绘线条插画网站</a></h2><p><a href="https://bon.design/">bon.design</a>是一个免费可商用的线条插画素材网站，画风是极简风，类型有很多，运动、建筑、自然、人物等，有png和svg格式下载。</p>
<p><img data-src="https://i.imgur.com/mYstITf.png"></p>
<p>网址：<a href="https://bon.design/">bon.design</a></p>
<h2 id="Poe-AI-平台添加了-StableDiffusionXL-图像生成机器人"><a href="#Poe-AI-平台添加了-StableDiffusionXL-图像生成机器人" class="headerlink" title="Poe AI 平台添加了 StableDiffusionXL 图像生成机器人"></a>Poe AI 平台添加了 StableDiffusionXL 图像生成机器人</h2><p>Poe AI 平台的用户可以通过与 StableDiffusionXL 互动，探索艺术创作的新境界。无论是生成独特的视觉艺术品，还是探索抽象的图像表达，这一机器人为创作者提供了一个创新和灵感迸发的平台。</p>
<p>免费用户每天可以生成 100 张 AI 绘画图片，速度非常快，体验非常好。</p>
<p>网址：<a href="https://poe.com/">https://poe.com/</a></p>
<p>APP or 桌面端下载：<a href="https://poe.com/download">https://poe.com/download</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312082132730.png"></p>
<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li>一年一度的北京 Google DevFest (谷歌开发者节) 活动已于 11 月 19 日举办，下面是活动中 Kotlin 相关一些主题分享：<ul>
<li><a href="https://www.bilibili.com/video/BV11Q4y147NA/">Android 应用，怎么开发你来定！</a> </li>
<li><a href="https://www.bilibili.com/video/BV1Xe411f76D/">使用 Kotlin 元编程技术提升开发效率</a></li>
<li><a href="https://www.bilibili.com/video/BV1yu4y1w7uP/">Jetpack Compose 现在能做什么</a></li>
<li><a href="https://www.bilibili.com/video/BV19G411U7uT/">从 Android 到 Kotlin 跨平台</a></li>
</ul>
</li>
<li>Kotlin 元编程新工具，增加了对 K2 编译器的支持，以及一个独立的源代码生成器，以提高灵活性和功能 !🔥 <a href="https://twitter.com/AndroidDev/status/1732793165835354156">https://twitter.com/AndroidDev/status/1732793165835354156</a></li>
<li>🎉 11 月发布的 <a href="https://twitter.com/code">@VSCode</a> 已上线！发现新增功能：  <ul>
<li>🖼️ 浮动编辑器窗口 </li>
<li>📈 JavaScript 堆快照 !</li>
<li>Python 类型层次结构显示 </li>
<li>💬改进了 GitHub Copilot 中的内联聊天</li>
</ul>
</li>
</ul>
<p>发行说明： <a href="https://code.visualstudio.com/updates/v1_85">https://code.visualstudio.com/updates/v1_85</a>  </p>
<p>下载： <a href="https://code.visualstudio.com/">https://code.visualstudio.com</a> </p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第23期：圣诞快乐🎄</title>
    <url>/posts/35341.html</url>
    <content><![CDATA[<p>在第23期的网上冲浪周刊中，我们为您精选了丰富的技术内容，包括Android动画、UI自动化项目、Flutter全埋点等。推荐阅读中涵盖Kotlin技术月报和Gemini Pro评测等热门话题。有趣的工具包括PDF转Markdown工具、Linux命令搜索和开源协作平台AppFlowy。宝藏信息中推荐Go语言学习指南和GPT导航站，同时分享了圣诞主题Lofi音乐。整体而言，本期周刊为您提供了丰富的技术资源和有趣发现，希望能够为您的学习和探索带来启发。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232352753.jpg" alt="封面图 https://www.pexels.com/zh-cn/photo/2842732/"></p>
<span id="more"></span>





<p>欢迎来到第23期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top///atom.xml">https://www.lifeee.top///atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/4SMosElfSliCKeJ7wrSSBg">360度解析Android动画：哪个更引人注目？ </a>：Android动画是每一个开发者必备的技能，它具有简单易用、灵活性强等优点。通过掌握属性动画的原理和高级技巧，可以让开发者创建出更加丰富、生动的动画效果。本文介绍了动画的基本以及高级使用，并给出了最佳实践的建议。</li>
<li><a href="https://mp.weixin.qq.com/s/CX9j63Wxe8qlvqVMjyRhpg">云音乐自研客户端UI自动化项目</a>：本文介绍了云音乐在UI自动化测试上的一站式解决方案，采用录制的方式解决录制门槛高、效率低下的问题，在回放过程中前置准备用例执行环境以及结合曙光埋点提升用例执行的稳定性，并且会保留执行过程中的现场信息以便后续溯因。最后通过私有云部署，在云端即可统一调度Android和iOS设备来执行任务。目前该套方案在云音乐所有业务线均已覆盖。+</li>
<li><a href="https://mp.weixin.qq.com/s/Hyb_iOhhmbCZOPxdZ0BsQw">Flutter 全埋点的实现</a>：使用 Dart AOP 实现的 Flutter App 全埋点</li>
<li><a href="https://mp.weixin.qq.com/s/nVrXZk5GFnQkjZiFOl8zdQ">全栈必备之SQL简明手册 </a></li>
<li><a href="https://mp.weixin.qq.com/s/j62_CEeVPVZVPERp0pIHUw">Android面试官问协程，你会如何选择应对这些高级问题？</a></li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="marker快速、高精度地将-PDF-转换为-Markdown"><a href="#marker快速、高精度地将-PDF-转换为-Markdown" class="headerlink" title="marker快速、高精度地将 PDF 转换为 Markdown"></a><a href="https://github.com/VikParuchuri/marker">marker</a>快速、高精度地将 PDF 转换为 Markdown</h2><p><a href="https://github.com/VikParuchuri/marker">marker</a>可以将 PDF、EPUB 和 MOBI 转换为 Markdown。其支持一系列 PDF 文档（针对书籍和科学论文进行了优化），可以删除页眉&#x2F;页脚，将大多数方程转换为latex，支持多种语言，适用于 GPU、CPU 或 MPS。与英语类似的语言（西班牙语、法语、德语、俄语等）拥有最好的支持，目前也支持中文、日语、韩语和印地语，但可能效果不佳。</p>
<p>开源地址：<a href="https://github.com/VikParuchuri/marker">https://github.com/VikParuchuri/marker</a></p>
<h2 id="Linux命令大全搜索工具：Linux-Command"><a href="#Linux命令大全搜索工具：Linux-Command" class="headerlink" title="Linux命令大全搜索工具：Linux Command"></a>Linux命令大全搜索工具：<a href="https://git.io/linux">Linux Command</a></h2><p><a href="https://git.io/linux">Linux Command</a>是一个收集了超过580个Linux命令的非盈利性仓库。该仓库生成了一个web网站，方便用户查询和学习Linux命令手册、详解等内容。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232255914.png"></p>
<p>在线网站：<a href="https://wangchujiang.com/linux-command/">https://wangchujiang.com/linux-command/</a></p>
<p>开源地址：<a href="https://github.com/jaywcjlove/linux-command">https://github.com/jaywcjlove/linux-command</a></p>
<h2 id="Notion开源平替：AppFlowy"><a href="#Notion开源平替：AppFlowy" class="headerlink" title="Notion开源平替：AppFlowy"></a>Notion开源平替：AppFlowy</h2><p>AppFlowy 是一个开源的协作工作平台，旨在帮助团队更高效地协作和管理项目。它类似于 Notion，但有一些关键的区别。首先，AppFlowy 是开源的，这意味着用户可以自由地查看、修改和分发平台的源代码。这提供了更大的控制和定制性。其次，AppFlowy 使用 Rust 和 Flutter 构建，这使其具有出色的性能和可扩展性。 </p>
<p>AppFlowy 具有以下功能：</p>
<ul>
<li>笔记和文档：AppFlowy 使您可以创建和编辑笔记、文档和其他类型的文本内容。</li>
<li>任务管理：AppFlowy 可帮助您跟踪任务、截止日期和优先级。</li>
<li>项目管理：AppFlowy 可帮助您创建和管理项目。</li>
<li>协作：AppFlowy 使您可以与其他用户协作，以创建和编辑文档、任务和项目。</li>
</ul>
<p>AppFlowy 适用于各种用途，包括：</p>
<ul>
<li>个人使用：AppFlowy 可以用作个人笔记应用程序、任务管理器或项目管理工具。</li>
<li>团队使用：AppFlowy 可以帮助团队更有效地协作和管理项目。</li>
<li>企业使用：AppFlowy 可以用作企业协作和项目管理平台。</li>
</ul>
<p>AppFlowy 仍在开发中，但它已经成为一个功能强大的协作工作平台。如果您正在寻找一个开源、可定制且功能强大的协作工作平台，那么 AppFlowy 是一个不错的选择。</p>
<p>开源地址：<a href="https://github.com/AppFlowy-IO/AppFlowy">https://github.com/AppFlowy-IO/AppFlowy</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312162155093.png"></p>
<h2 id="Google-Play-游戏-手游登陆-PC-端"><a href="#Google-Play-游戏-手游登陆-PC-端" class="headerlink" title="Google Play 游戏 手游登陆 PC 端"></a>Google Play 游戏 手游登陆 PC 端</h2><p>使用 Google Play 游戏 Beta 版，在 PC 端也能畅玩手游。如要开始体验，请在符合<a href="https://play.google.com/googleplaygames#section-system-requirements">最低要求</a>的计算机上下载该应用。</p>
<p> 计算机配置最低要求</p>
<ul>
<li><em>操作系统</em>: Windows 10 (v2004)</li>
<li><em>存储</em>: 具有 10 GB 可用存储空间的固态硬盘 (SSD)</li>
<li><em>图片</em>: IntelⓇ UHD 显卡 630 GPU 或同等显卡</li>
<li><em>处理器</em>: 4 个 CPU 实体内核（有些游戏需要 Intel CPU）</li>
<li><em>内存</em>: 8 GB RAM</li>
<li>Windows 管理员账号</li>
<li>必须开启硬件虚拟化功能</li>
</ul>
<p>下载地址：<a href="https://play.google.com/googleplaygames">Google Play 游戏 - 在 PC 上畅玩 Android 游戏</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312161639678.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312161644474.png"></p>
<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Go语言学习指南：-GoGuide"><a href="#Go语言学习指南：-GoGuide" class="headerlink" title="Go语言学习指南：**GoGuide**"></a>Go语言学习指南：**<a href="https://github.com/coderit666/GoGuide">GoGuide</a>**</h2><p><a href="https://github.com/coderit666/GoGuide">GoGuide</a>「Go语言学习指南」一份涵盖大部分 Golang 程序员所需要掌握的核心知识，拥有 Go语言教程、Go开源书籍、Go语言入门教程、Go语言学习路线。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232301167.png"></p>
<p>开源地址：<a href="https://github.com/coderit666/GoGuide">https://github.com/coderit666/GoGuide</a></p>
<h2 id="Where-GPT导航"><a href="#Where-GPT导航" class="headerlink" title="Where-GPT导航"></a><a href="https://gpt-where.life/">Where-GPT导航</a></h2><p><a href="https://gpt-where.life/">https://gpt-where.life/</a> 是一个chatGPT导航网站，收录了很多GPT延伸的工具。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232222900.png"></p>
<p>网址：<a href="https://gpt-where.life/">https://gpt-where.life/</a> </p>
<h2 id="chatGPT导航站-aifuturecome"><a href="#chatGPT导航站-aifuturecome" class="headerlink" title="chatGPT导航站 | aifuturecome"></a><a href="https://www.aifuturecome.com/">chatGPT导航站 | aifuturecome</a></h2><p> <a href="https://www.aifuturecome.com/">https://www.aifuturecome.com/</a>  是一个chatGPT导航网站，一站式解决chatGPT有关问题。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232217321.png"></p>
<p>网址： <a href="https://www.aifuturecome.com/">https://www.aifuturecome.com/</a> </p>
<h2 id="音乐推荐：Christmas-lofi-radio-圣诞主题Lofi"><a href="#音乐推荐：Christmas-lofi-radio-圣诞主题Lofi" class="headerlink" title="音乐推荐：Christmas lofi radio 圣诞主题Lofi"></a>音乐推荐：Christmas lofi radio 圣诞主题Lofi</h2><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312232241663.png"></p>
<p>地址：<a href="https://www.youtube.com/watch?v=pt4qkWORaRQ&ab_channel=LofiGirl">https://www.youtube.com/watch?v=pt4qkWORaRQ&ab_channel&#x3D;LofiGirl</a></p>
<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://mp.weixin.qq.com/s/BFdy3EYuqUWTK_dBnf_JQQ">CMU评测：Gemini Pro相比GPT3.5，全线溃败！代码公开可复现</a></p>
</li>
<li><p><a href="https://www.qbitai.com/2023/12/107799.html">谷歌发布新大语言模型：零样本生成10秒视频达SOTA！网友：压力给到Runway&#x2F;Pika | 量子位 (qbitai.com)</a></p>
</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第25期：新年新气象🌱</title>
    <url>/posts/38961.html</url>
    <content><![CDATA[<p>欢迎阅读第25期技术资讯！这期我们推荐了一系列精彩的技术文章、工具和开源项目。在推荐阅读中，介绍2023年现代安卓开发的趋势，设计安全可靠的API的方法，以及Java 有哪些常见的误区问题。在有趣的工具部分，我们介绍了SmartDNS，一款本地DNS服务器，以及One Tab Group，一款多功能的标签页&#x2F;标签组管理器。此外，还推荐了GitHub520、one-api、FreeControl和猫抓等实用工具。宝藏信息中，我们带来了Google Bard API、GitHub Web IDE等项目，以及一款能够在PC上控制Android设备的FreeControl。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401072002887.jpg"></p>
<span id="more"></span>





<p>欢迎来到第25期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top///atom.xml">https://www.lifeee.top///atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://juejin.cn/post/7229151797415051322">2023年的现代安卓开发</a>：Jetpack Compose、Android Jetpack、Material Design、Clean Architecture</li>
<li><a href="https://mp.weixin.qq.com/s/foFc9iSeBUTD2I5QnvIyaw">如何设计安全可靠的 API ？</a>：使用 HTTPS、使用 OAuth 2.0、使用 WebAuthn、使用分级 API Key、授权、限流、版本控制、白名单、定期检查 OWASP API 安全风险清单、使用 API 网关、错误处理、输入验证。</li>
<li>【[干货建议收藏]我们对 Java 有哪些常见的误区？】<a href="https://www.bilibili.com/video/BV14e41167CM?vd_source=1e1aa0f06f98286544f4193f7bfd4bdc">https://www.bilibili.com/video/BV14e41167CM?vd_source=1e1aa0f06f98286544f4193f7bfd4bdc</a></li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h1 id="Obsidian-使用-picgo自动上传图片"><a href="#Obsidian-使用-picgo自动上传图片" class="headerlink" title="Obsidian 使用 picgo自动上传图片"></a>Obsidian 使用 picgo自动上传图片</h1><p><a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin/tree/master">obsidian-image-auto-upload-plugin</a> 是一个 Obsidian 插件，用于自动上传图片到图床中。</p>
<p>配置步骤为：</p>
<ol>
<li><p>安装 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 或者 <a href="https://github.com/Kuingsmile/PicList">PicList</a> ，并进行配置，配置参考<a href="https://github.com/Molunerfinn/PicGo">官网</a> </p>
<blockquote>
<p><a href="https://github.com/Kuingsmile/PicList">PicList</a> 是 PicGo 的升级版，主要添加了相册云删除和云存储管理两个功能。</p>
</blockquote>
</li>
<li><p>开启 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 或者 <a href="https://github.com/Kuingsmile/PicList">PicList</a>的 Server 服务，并记住端口号</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401102231073.png" style="zoom: 67%;" />
</li>
<li><p>在Obsidian 安装插件 <strong>Image auto upload plugin</strong></p>
</li>
<li><p>打开插件配置项，设置为<code>http://127.0.0.1:&#123;&#123;PicGo设置的端口号&#125;&#125;/upload</code>（例如：<code>http://127.0.0.1:36686/upload</code>）</p>
</li>
<li><p>在 Obsidian  Ctrl+V 粘贴剪切板中的图片就会自动上传</p>
</li>
</ol>
<p>详细使用步骤可参见 <a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin/blob/master/readme-zh.md">Obsidian Image Auto Upload Plugin</a> </p>
<p>开源地址： <a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin">https://github.com/renmu123/obsidian-image-auto-upload-plugin</a>  </p>
<h2 id="One-Tab-Group-标签页-标签组管理器"><a href="#One-Tab-Group-标签页-标签组管理器" class="headerlink" title="One Tab Group - 标签页&#x2F;标签组管理器"></a><a href="https://www.onetab.group/">One Tab Group - 标签页&#x2F;标签组管理器</a></h2><p>One Tab Group 一款集多功能于一身的代替 <code>OneTab</code>&#x2F;<code>Session Buddy</code> 的下一代标签页&#x2F;标签组管理器, 帮助你有效地管理、组织您的浏览器标签页，支持云同步以及同步到 Notion 等功能。可以理解为是扩展 OneTab 的代替品，除了继承它的功能外，还有以下特性：</p>
<p>✨ <strong>特性</strong></p>
<ul>
<li><p>⚡️ 有效地在会话中组织您的标签页、标签组</p>
</li>
<li><p>🗂️ 保存&#x2F;恢复&#x2F;重组标签页、标签组</p>
<ul>
<li>在当前窗口中</li>
<li>在新窗口中</li>
<li>恢复为休眠模式以节省内存</li>
</ul>
</li>
<li><p>🔄 同步您正在浏览（打开的）标签页、标签组</p>
</li>
<li><p>🤏 轻松通过拖拉拽的方式管理您的会话</p>
</li>
<li><p>⌨️ 支持命令行面板界面 - 轻松通过命令行面板探索您打开的标签页、标签组</p>
</li>
<li><p>🏷️ 可视化网络书签 - 将链接转化为一个可视化的网络书签，便于您分享给他人</p>
</li>
<li><p>🔲 支持单列 ｜ 双列 ｜ 时间线布局</p>
</li>
<li><p>🌛 支持暗色模式</p>
</li>
<li><p>🌍 多语言支持（中文、英文）</p>
</li>
<li><p>💾 会话备份方案</p>
<ul>
<li>📑 保存您的会话为一个 JSON 文件</li>
<li>📧 发送会话备份文件到您的邮箱（需登录）</li>
</ul>
</li>
<li><p>📥 支持导入方案</p>
<ul>
<li>🔖 支持将 <code>OneTab</code> 的数据导入到 <code>One Tab Group</code></li>
<li>🔖 支持将 <code>SessionBuddy</code> 的数据导入到 <code>One Tab Group</code></li>
</ul>
</li>
<li><p>🔍 支持在所有标签页中模糊搜索</p>
</li>
<li><p>🧹 休眠您打开的标签页以节省内存</p>
</li>
<li><p>☁️ 支持云备份同步、Notion 同步</p>
</li>
<li><p>❤️ 收藏您喜爱的 Session</p>
</li>
<li><p>✨ 将 Session 作为链接和任何人分享</p>
</li>
</ul>
<p>chrome安装地址：<a href="https://chromewebstore.google.com/detail/one-tab-group-%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%A0%87%E7%AD%BE%E7%BB%84%E7%AE%A1%E7%90%86%E5%99%A8/lajbajamkpmkmldodfbljkjihppdclbm">One Tab Group - 标签页&#x2F;标签组管理器 (google.com)</a></p>
<p>edge安装地址：<a href="https://microsoftedge.microsoft.com/addons/detail/one-tab-group-%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%A0%87%E7%AD%BE%E7%BB%84%E7%AE%A1%E7%90%86/njmgdlgmnlinpieohfpmiipenmgilpga">One Tab Group - 标签页&#x2F;标签组管理器 - Microsoft Edge Addons</a></p>
<p>官网：<a href="https://www.onetab.group/">https://www.onetab.group/</a></p>
<h2 id="Github520：加速访问Github"><a href="#Github520：加速访问Github" class="headerlink" title="Github520：加速访问Github"></a><a href="https://github.com/521xueweihan/GitHub520">Github520：加速访问Github</a></h2><p>让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。（无需安装，通过修改本地 hosts 文件）</p>
<p>使用方法：<a href="https://github.com/521xueweihan/GitHub520#%E4%BA%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">https://github.com/521xueweihan/GitHub520#%E4%BA%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95</a></p>
<p>开源地址：<a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202312162155093.png"></p>
<h2 id="one-api：OpenAI-接口管理"><a href="#one-api：OpenAI-接口管理" class="headerlink" title="one-api：OpenAI 接口管理"></a><a href="https://github.com/songquanpeng/one-api">one-api：OpenAI 接口管理</a></h2><p>OpenAI 接口管理 &amp; 分发系统，支持 Azure、Anthropic Claude、Google PaLM 2 &amp; Gemini、智谱 ChatGLM、百度文心一言、讯飞星火认知、阿里通义千问、360 智脑以及腾讯混元，可用于二次分发管理 key，仅单可执行文件，已打包好 Docker 镜像，一键部署，开箱即用。</p>
<p>开源地址：<a href="https://github.com/songquanpeng/one-api">https://github.com/songquanpeng/one-api</a></p>
<h2 id="FreeControl：基于scrcpy的GUI"><a href="#FreeControl：基于scrcpy的GUI" class="headerlink" title="FreeControl：基于scrcpy的GUI"></a><a href="https://github.com/pdone/FreeControl">FreeControl：基于scrcpy的GUI</a></h2><p>FreeControl是基于开源项目<a href="https://github.com/Genymobile/scrcpy"><strong>scrcpy</strong></a>的进行开发的，可以在PC控制Android设备。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401072014776.png"></p>
<p>开源地址：<a href="https://github.com/pdone/FreeControl">https://github.com/pdone/FreeControl</a></p>
<h2 id="猫抓资源嗅探扩展，能够帮你筛选列出当前页面的资源"><a href="#猫抓资源嗅探扩展，能够帮你筛选列出当前页面的资源" class="headerlink" title="猫抓资源嗅探扩展，能够帮你筛选列出当前页面的资源"></a>猫抓资源嗅探扩展，能够帮你筛选列出当前页面的资源</h2><p>猫抓Cat Catch 是一款网页资源嗅探扩展，能帮你下载网页视频，支持M3U8，支持媒体控制，包括倍速、画中画、全屏、截图等。</p>
<p>Chrome安装地址：<a href="https://chrome.google.com/webstore/detail/jfedfbgedapdagkghmgibemcoggfppbb">https://chrome.google.com/webstore/detail/jfedfbgedapdagkghmgibemcoggfppbb</a></p>
<p>Edge安装地址：<a href="https://microsoftedge.microsoft.com/addons/detail/oohmdefbjalncfplafanlagojlakmjci">https://microsoftedge.microsoft.com/addons/detail/oohmdefbjalncfplafanlagojlakmjci</a></p>
<p>Firefox安装地址：<a href="https://addons.mozilla.org/addon/cat-catch/">https://addons.mozilla.org/addon/cat-catch/</a></p>
<p>开源地址：<a href="https://github.com/xifangczy/cat-catch?tab=readme-ov-file">https://github.com/xifangczy/cat-catch?tab=readme-ov-file</a></p>
<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Google-Bard-API-轻松向-Google-Bard-发送请求"><a href="#Google-Bard-API-轻松向-Google-Bard-发送请求" class="headerlink" title="Google Bard API 轻松向 Google Bard 发送请求"></a><a href="https://github.com/ra83205/google-bard-api">Google Bard API</a> 轻松向 Google Bard 发送请求</h2><p>用于与Google Bard进行交互的FastAPI封装，允许用户通过一个简单的API发送消息给Google Bard，并接收响应</p>
<p>Google Bard 是 Google 开发的出色的对话式人工智能。该项目包含一个用于轻松向 Google Bard 发送请求的综合库，以及一个简化的 API 服务器，允许用户通过一个简单的API发送消息给Google Bard，并接收响应。 </p>
<p>开源地址：<a href="https://github.com/ra83205/google-bard-api">https://github.com/ra83205/google-bard-api</a></p>
<h2 id="GitHub-Web-IDE：浏览器拓展"><a href="#GitHub-Web-IDE：浏览器拓展" class="headerlink" title="GitHub Web IDE：浏览器拓展"></a>GitHub Web IDE：浏览器拓展</h2><p>GitHub Web IDE是是一款浏览器拓展，能够通过在线IDE浏览 Github 代码。</p>
<p>Chrome 安装地址：<a href="https://chrome.google.com/webstore/detail/adjiklnjodbiaioggfpbpkhbfcnhgkfe">https://chrome.google.com/webstore/detail/adjiklnjodbiaioggfpbpkhbfcnhgkfe</a></p>
<p>Firefox 安装地址：<a href="https://addons.mozilla.org/firefox/addon/github-web-ide">https://addons.mozilla.org/firefox/addon/github-web-ide</a></p>
<p>Edge 安装地址：<a href="https://microsoftedge.microsoft.com/addons/detail/akjbkjciknacicbnkfjbnlaeednpadcf">https://microsoftedge.microsoft.com/addons/detail/akjbkjciknacicbnkfjbnlaeednpadcf</a></p>
<h2 id="播客推荐：肥话连篇"><a href="#播客推荐：肥话连篇" class="headerlink" title="播客推荐：肥话连篇"></a>播客推荐：肥话连篇</h2><p>肥话连篇是一档生活闲聊博客，小宇宙： <a href="https://www.xiaoyuzhoufm.com/podcast/61d50d72ee197a3aac3dac42">肥话连篇 | 小宇宙</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401071927156.png"></p>
<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><a href="https://www.gov.cn/yaowen/liebiao/202401/content_6923849.htm">泰国宣布将对华永久免签</a></li>
<li><a href="https://www.theverge.com/2024/1/4/24023809/microsoft-copilot-key-keyboard-windows-laptops-pcs">微软计划在键盘上新增 Copilot 按键</a></li>
<li><a href="https://workspace.dingtalk.com/welcome?from=dingtalk">2024 年 1 月 4 日，钉钉个人版正式上线。</a>：钉钉个人版旨在为小团队、个人用户和高校大学生等群体提供丰富的 AI 工具和服务，致力于成为 AI 时代的个人助理，提升个人和小团队的生产力。</li>
</ul>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第27期：大寒已至，暖春将启🍃</title>
    <url>/posts/4820.html</url>
    <content><![CDATA[<p>欢迎阅读第27期技术资讯！这期我们推荐了一系列精彩的技术文章、工具和开源项目。在推荐阅读中，介绍了Instagram如何在短时间内迅速扩大用户规模，网易云音乐的自动化测试实践以及Android图像加载库Coil。在有趣的工具部分，我们介绍能够裁剪保存网页内容的浏览器扩展”MaoXian Web Clipper”和免费的Web防火墙软件雷池防火墙社区版。此外，还介绍了一些宝藏信息，如一本图解算法的入门书《Hello 算法》，以及解锁Medium付费文章的在线网站和浏览器扩展。最后，推荐了一档泛文化类播客《鲸鱼赫兹》，以探索不同城市生活的话题和可能性。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401211710726.jpg" alt="封面图https://www.pexels.com/zh-cn/photo/1105391"></p>
<span id="more"></span>





<p>欢迎来到第27期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top///atom.xml">https://www.lifeee.top///atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million">How Instagram scaled to 14 million users with only 3 engineers (engineerscodex.com)</a>：Instagram 的早期架构，从 2010 年 10 月到 2011 年 12 月，Instagram 在短短一年多的时间里，用户数量从 0 增长到 1,400 万。他们只用了 3 名工程师就完成了这一任务。</li>
<li><a href="https://mp.weixin.qq.com/s/-E8sVIgQ9IK--nrXO_95rw">客户端自动化测试在网易云音乐的实践与落地</a>：网易云音乐自动化测试 Saturn 平台设计思路、技术演进，专项，落地成果。</li>
<li><a href="https://medium.com/@awesomeAndroid/exploring-coil-a-powerful-image-loading-library-for-android-a5d12d96e5f6">探索 Coil：一个强大的 Android 图像加载库</a>  &amp;  <a href="https://mp.weixin.qq.com/s/VCBTeb9k-Ua8_Uzu76gaKg">Coil - Android开源图像加载库</a> ：在 Android 应用程序开发领域，高效显示图像对于提供流畅且具有视觉吸引力的用户体验至关重要。处理图像加载、缓存和显示可能具有挑战性，但幸运的是，有一些库可以简化该过程。 Coil 就是这样一个库，它是一个轻量级、多功能的 Android 图像加载库。</li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="网页的内容裁剪：毛线网摘"><a href="#网页的内容裁剪：毛线网摘" class="headerlink" title="网页的内容裁剪：毛线网摘"></a>网页的内容裁剪：<a href="https://github.com/mika-cn/maoxian-web-clipper">毛线网摘</a></h2><p><a href="https://github.com/mika-cn/maoxian-web-clipper">毛线网摘</a> 一个可以将网页的内容裁剪并保存到<strong>本地电脑</strong>的浏览器扩展。使用它，你可以避免网站挂了，网址失效，图片失效等问题。 它可以将网页保存为 HTML 格式或 Markdown 格式，图片样式等也会一同保存下来。</p>
<p>详细介绍可以查看 <a href="https://www.appinn.com/maoxian-web-clipper-2/">小众软件-毛线网摘使用</a> or <a href="https://mika-cn.github.io/maoxian-web-clipper/index-zh-CN.html">MaoXian Web Clipper - 作者Mika的介绍</a></p>
<p>安装：</p>
<ul>
<li>Firefox （火狐浏览器）- <a href="https://addons.mozilla.org/zh-CN/firefox/addon/maoxian-web-clipper/">https://addons.mozilla.org/zh-CN/firefox/addon/maoxian-web-clipper/</a></li>
<li>Chromium （谷歌浏览器社区版）- <a href="https://mika-cn.github.io/maoxian-web-clipper/install-by-extension-file-zh-CN.html">安装</a></li>
</ul>
<p>开源地址：<a href="https://github.com/mika-cn/maoxian-web-clipper">https://github.com/mika-cn/maoxian-web-clipper</a></p>
<h2 id="Github全球第一的免费waf防火墙雷池社区版"><a href="#Github全球第一的免费waf防火墙雷池社区版" class="headerlink" title="Github全球第一的免费waf防火墙雷池社区版"></a>Github全球第一的免费waf防火墙雷池社区版</h2><p>就在前不久，<a href="https://github.com/chaitin/SafeLine">雷池防火墙社区版</a>在Github上的Star数已经超过了老前辈ModSecurity，成为了全球第一的免费Web防火墙软件。<a href="https://github.com/chaitin/SafeLine">雷池防火墙社区版</a>是一款足够简单、足够好用、足够强的免费 WAF。基于业界领先的语义引擎检测技术，作为反向代理接入，保护你的网站不受黑客攻击。</p>
<p>雷池的工作原理是接收源Web站点的流量，然后经过检测和清洗，遇到恶意流量会拦截，然后将处理后的流量转发到源站。</p>
<p><strong>特性</strong></p>
<ul>
<li>便捷性</li>
</ul>
<p>采用容器化部署，一条命令即可完成安装，0 成本上手。安全配置开箱即用，无需人工维护，可实现安全躺平式管理。</p>
<ul>
<li>安全性</li>
</ul>
<p>首创业内领先的智能语义分析算法，精准检测、低误报、难绕过。语义分析算法无规则，面对未知特征的 0day 攻击不再手足无措。</p>
<ul>
<li>高性能</li>
</ul>
<p>无规则引擎，线性安全检测算法，平均请求检测延迟在 1 毫秒级别。并发能力强，单核轻松检测 2000+ TPS，只要硬件足够强，可支撑的流量规模无上限。</p>
<ul>
<li>高可用</li>
</ul>
<p>流量处理引擎基于 Nginx 开发，性能与稳定性均可得到保障。内置完善的健康检查机制，服务可用性高达 99.99%。****</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401182310171.png"></p>
<p>官网：<a href="https://waf-ce.chaitin.cn/">https://waf-ce.chaitin.cn/</a></p>
<p>开源地址：<a href="https://github.com/chaitin/SafeLine">https://github.com/chaitin/SafeLine</a></p>
<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Hello-算法"><a href="#Hello-算法" class="headerlink" title="Hello 算法"></a>Hello 算法</h2><p><a href="https://www.hello-algo.com/">Hello 算法</a>  是一本动画图解、能运行、可提问的数据结构与算法入门书，支持 Java, C++, Python, Go, JS, TS, C#, Swift 等语言。</p>
<p>“一本通俗易懂的数据结构与算法入门书，引导读者手脑并用地学习，强烈推荐算法初学者阅读。”</p>
<p>特性：</p>
<ul>
<li>全书采用动画图解，内容清晰易懂、学习曲线平滑，引导初学者探索数据结构与算法的知识地图。</li>
<li>源代码可一键运行，帮助读者在练习中提升编程技能，了解算法工作原理和数据结构底层实现。</li>
<li>鼓励读者互助学习，提问与评论通常可在两日内得到回复。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401172138001.png"></p>
<p>在线地址：<a href="https://www.hello-algo.com/">https://www.hello-algo.com/</a></p>
<p>开源地址：<a href="https://github.com/krahets/hello-algo">https://github.com/krahets/hello-algo</a></p>
<h2 id="ReadMedium-解锁Medium付费文章"><a href="#ReadMedium-解锁Medium付费文章" class="headerlink" title="ReadMedium 解锁Medium付费文章"></a><a href="https://readmedium.com/">ReadMedium</a> 解锁Medium付费文章</h2><p><a href="https://readmedium.com/">ReadMedium - Read Translated Articles for Free!</a> 是一个在线网站，能够解析Medium付费文章，因此免费就可以阅读Medium会员文章了。</p>
<p>使用方式：复制Medium付费会员文章的链接，打开ReadMedium官网粘贴，点击 <code>Go</code> 即可解析文章免费阅读，或者在将“read”添加到付费文章网址前面即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401152327309.png"></p>
<blockquote>
<p>Medium简介：</p>
<p><a href="https://medium.com/">Medium</a> 是一个国外的在线内容发布平台，提供各种领域的原创文章和博客。这个网站上的作者可以分享自己的想法、经验和见解，读者可以通过浏览不同主题的文章来获取有关技术、科学、写作、自我提升等方面的知识和见解。Medium 提供了一个开放的平台，让作者和读者可以互动和交流，同时也为写作爱好者提供了一个展示和推广自己作品的机会。</p>
</blockquote>
<p>在线地址：<a href="https://readmedium.com/">https://readmedium.com/</a></p>
<h2 id="油猴脚本一键解锁Medium"><a href="#油猴脚本一键解锁Medium" class="headerlink" title="油猴脚本一键解锁Medium"></a>油猴脚本一键解锁Medium</h2><p><a href="https://greasyfork.org/zh-CN/scripts/481493-medium-unlocker-2023-12-06-updated">Medium解锁</a> 是一个油猴脚本，能够自动检测Medium文章（包括子域名和自定义域名），替换URL为readmedium.com来解锁Medium付费文章，使用的时候只需要点击一下按钮即可。原理其实替换URL为<a href="https://readmedium.com/">ReadMedium</a> 这个网站来解锁Medium付费文章。</p>
<p>安装地址：<a href="https://greasyfork.org/zh-CN/scripts/481493-medium-unlocker-2023-12-06-updated">https://greasyfork.org/zh-CN/scripts/481493-medium-unlocker-2023-12-06-updated</a></p>
<blockquote>
<p>首先需要安装一个用户脚本管理器,根据当前使用的浏览器来<a href="https://greasyfork.org/zh-CN">选择一个用户脚本管理器</a>。</p>
<p><a href="https://greasyfork.org/scripts/481493-medium-unlocker-2023-12-06-updated">Medium 解锁</a>页面点击安装，或者直接复制main.js的全部内容手动添加脚本。</p>
<p><strong>使用方法</strong></p>
<p>点击文章页面出现的绿色悬浮球</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401152326399.png"></p>
<h2 id="浏览器扩展medium-parser-extension解锁Medium"><a href="#浏览器扩展medium-parser-extension解锁Medium" class="headerlink" title="浏览器扩展medium-parser-extension解锁Medium"></a>浏览器扩展<a href="https://github.com/Xatta-Trone/medium-parser-extension">medium-parser-extension</a>解锁Medium</h2><p>推荐没法安装油猴脚本的同学再安装<a href="https://github.com/Xatta-Trone/medium-parser-extension">medium-parser-extension</a>，原因是油猴脚本更加轻量级。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401152335426.png"></p>
<p>安装地址：<a href="https://chrome.google.com/webstore/detail/medium-parser/egejbknaophaadmhijkepokfchkbnelc?hl=en&authuser=0">https://chrome.google.com/webstore/detail/medium-parser/egejbknaophaadmhijkepokfchkbnelc?hl=en&authuser=0</a></p>
<p>开源地址：<a href="https://github.com/Xatta-Trone/medium-parser-extension">https://github.com/Xatta-Trone/medium-parser-extension</a></p>
<blockquote>
<p>无法访问chrome商店的同学可以在 <a href="https://github.com/Xatta-Trone/medium-parser-extension">Xatta-Trone&#x2F;medium-parser-extension: Read medium.com and medium based articles using google web cache. (github.com)</a> 下载后手动安装</p>
</blockquote>
<h2 id="播客推荐：鲸鱼赫兹"><a href="#播客推荐：鲸鱼赫兹" class="headerlink" title="播客推荐：鲸鱼赫兹"></a>播客推荐：<a href="https://www.xiaoyuzhoufm.com/podcast/60acac17cd0329ebb0a9243b?s=eyJ1IjoiNWViZmQyY2MyMWFjODU4MDQxMzViYjkzIn0=">鲸鱼赫兹</a></h2><p>《鲸鱼赫兹》是一档自由探索城市风味的泛文化类播客，每周二更新。 我们一起聊聊不同的城市生活，分享风味的各种话题，回归日常的、自然的表达，探讨城市生活的不同方式和可能。</p>
<p> 这里有姥姥熬的红豆沙，有四月末的香樟树，有日本宇治的抹茶…… 那些关于人、关于季节、关于城市的风味，其实是生活与时间的对话。 </p>
<p>小宇宙收听链接： <a href="https://www.xiaoyuzhoufm.com/podcast/60acac17cd0329ebb0a9243b?s=eyJ1IjoiNWViZmQyY2MyMWFjODU4MDQxMzViYjkzIn0=">鲸鱼赫兹 | 小宇宙 </a></p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401211556199.png"></p>
<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><a href="https://www.cls.cn/detail/1574005">小米首款5G卫星移动终端入网   财联社 </a>：该设备支持天通卫星通信制式，以及 5G-增强移动宽带（eMBB）技术，搭载安卓系统，这将是小米首款5G卫星移动终端。</li>
<li><a href="https://www.zhihu.com/question/639927719">iPhone15 价格跌至史上最低，苹果公司罕见促销难挡股价跌势  知乎 )</a></li>
<li><a href="https://www.huxiu.com/article/2559805.html">拼不到30岁的杭漂，开始回流北上广深-虎嗅网 (huxiu.com)</a></li>
<li><a href="https://deepmind.google/discover/blog/alphageometry-an-olympiad-level-ai-system-for-geometry/">谷歌 DeepMind 的 AI 新突破：构建 AGI 关键一步</a></li>
<li><a href="https://www.bloomberg.com/news/articles/2024-01-18/youtube-and-spotify-join-netflix-in-not-launching-apple-vision-pro-apps">流媒体 YouTube 和 Spotify 将不会为苹果头显开发专门应用，跟 Netflix 一样。</a></li>
<li><a href="https://www.ithome.com/0/745/256.htm">华为纯血鸿蒙 HarmonyOS NEXT 开发者预览版首批 Beta 招募开启，支持 Mate 60 &#x2F; Pro、X5 机型 - IT之家 </a></li>
</ul>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第29期： 有钱没钱回家过年 🧧</title>
    <url>/posts/30183.html</url>
    <content><![CDATA[<p>欢迎阅读第29期技术资讯！这期我们推荐了一些技术相关的文章、工具和信息。在推荐阅读中，介绍使用Compose实现龙头绘制、对2024年前端技术发展的预测、Android架构中新引入的UseCase概念等。此外,还介绍了几款有意思的工具软件,如Microsoft的视频编辑软件Clipchamp、Python数据可视化工具PyGWalker、开发者瑞士军刀DevToys工具等。文章还分享了独立开发者Sindre Sorhus的多个知名软件作品、开源Android电视直播软件my-tv,以及IPtv直播源地址。最后推荐了一档热门新闻播客《新闻酸菜馆》。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402142100562.jpg" alt="封面图 https://www.pexels.com/zh-cn/photo/900097/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第29期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top///atom.xml">https://www.lifeee.top///atom.xml</a></p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><p><a href="https://juejin.cn/post/7325132087282384923">龙年了，一起用Compose来画龙头吧 - 掘金 </a></p>
</li>
<li><p><a href="https://juejin.cn/post/7322347847412531254">2024 前端预测 - 中文翻译</a> | <a href="https://buttondown.email/whatever_jamie/archive/frontend-predictions-for-2024/">Frontend predictions for 2024 - 原文</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oiMUAoXoiGXjDFkRo6o9SQ">Android 最新官方架构推荐引入 UseCase，这是个啥？该怎么写？</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7308001278420320275">安卓开发转鸿蒙开发到底有多简单？ </a></p>
</li>
<li><p><a href="https://juejin.cn/post/7324535599657697331">毕业 10 年，也成了 Android 10 年老开发，与你分享我的 2023  </a></p>
</li>
<li><p><a href="https://juejin.cn/post/7329573754987528229">图解 VSCode 源码架构</a></p>
</li>
</ul>
<br />

<h2 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h2><h3 id="Lepton-Search-AI-对话式搜索引擎"><a href="#Lepton-Search-AI-对话式搜索引擎" class="headerlink" title="Lepton Search: AI 对话式搜索引擎"></a><a href="https://search.lepton.run/">Lepton Search</a>: AI 对话式搜索引擎</h3><p><a href="https://search.lepton.run/">Lepton</a> 开源了一款基于 AI 对话式搜索引擎 <a href="https://search.lepton.run/">Lepton Search</a>， 当用户输入问题时，Lepton Search 会主动搜索互联网数据并整理成有条理和逻辑的答案，同时提供信息来源。Lepton Search 的后端部署在 Lepton AI，输出速度大约可以达到每秒 200 个 token，有两个默认支持的搜索引擎：Bing 和 Google。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402012244201.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402012308111.png"></p>
<blockquote>
<p>Lepton AI 由前阿里巴巴副总裁贾扬清创建，旨在建立高效的 AI 应用平台</p>
<p><a href="https://www.lepton.ai/">Build AI The Simple Way | Lepton AI</a></p>
</blockquote>
<p>体验地址：<a href="https://search.lepton.run/">https://search.lepton.run/</a></p>
<p>开源地址：<a href="https://github.com/leptonai/search_with_lepton">https://github.com/leptonai/search_with_lepton</a></p>
<br />

<h3 id="微软的剪辑软件出品便捷易用的视频编辑器-Clipchamp"><a href="#微软的剪辑软件出品便捷易用的视频编辑器-Clipchamp" class="headerlink" title="微软的剪辑软件出品便捷易用的视频编辑器 Clipchamp"></a>微软的剪辑软件出品便捷易用的视频编辑器 <a href="https://clipchamp.com/zh-hans/">Clipchamp</a></h3><p><a href="https://clipchamp.com/zh-hans/">Clipchamp</a> 是一款简单易用的视频剪辑软件，比较适合非专业人士。并且可以免费使用微软的文字转语音、自动生成字幕、调整视频大小、使用免版税素材、使用AI创建视频等等。该软件有网页版，也有Windows桌面版。个人感觉用起来不如剪映、必剪这种符合国人习惯。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401292227499.png"></p>
<p>体验地址：<a href="https://clipchamp.com/zh-hans/">https://clipchamp.com/zh-hans/</a></p>
<br />

<h3 id="python可视化工具-PyGWalker"><a href="#python可视化工具-PyGWalker" class="headerlink" title="python可视化工具 PyGWalker"></a>python可视化工具 PyGWalker</h3><p><a href="https://github.com/Kanaries/pygwalker"><strong>PyGWalker</strong></a>是个在Jupyter Notebook环境中运行的可视化探索式分析工具，仅一条命令即可生成一个可交互的图形界面，以类似Tableau&#x2F;PowerBI的方式，通过拖拽字段进行数据分析。</p>
<p>过去在python中进行数据可视化分析时，经常需要查询大量的可视化类的代码，并编写胶水代码将其应用在数据集上。PyGWalker的目标是通过一行代码，将数据集转化为一个可视化分析工具，只需拖拉拽即可生成图表，从而减少数据分析师在数据可视化上的时间成本。</p>
<blockquote>
<p>为什么叫PyGWalker？PyGWalker，全称为”Python binding of Graphic Walker”，将Jupyter Notebook(或类Jupyter Notebook)和<a href="https://github.com/Kanaries/graphic-walker">Graphic Walker</a>集成。Graphic Walker是一个轻量级的Tableau&#x2F;Power BI开源替代品，可以帮助数据分析师使用简单的拖拉拽操作，进行数据可视化和探索。</p>
</blockquote>
<blockquote>
<p>如果你喜欢使用R语言，你可以在R中使用<a href="https://github.com/Kanaries/GWalkR">GWalkR</a>。</p>
</blockquote>
<p><img data-src="https://user-images.githubusercontent.com/8137814/221879671-70379d15-81ac-44b9-b267-a8fa3842a0d9.png"></p>
<p>使用地址：<a href="https://github.com/Kanaries/pygwalker/blob/main/docs/README.zh.md">https://github.com/Kanaries/pygwalker/blob/main/docs/README.zh.md</a></p>
<p>开源地址：<a href="https://github.com/Kanaries/pygwalker/tree/main">Kanaries&#x2F;pygwalker: PyGWalker: Turn your pandas dataframe into an interactive UI for visual analysis (github.com)</a></p>
<br />

<h3 id="开发者的瑞士军刀-DevToys-Windows-平台"><a href="#开发者的瑞士军刀-DevToys-Windows-平台" class="headerlink" title="开发者的瑞士军刀 DevToys [Windows 平台]"></a>开发者的瑞士军刀 <a href="https://devtoys.app/">DevToys</a> [Windows 平台]</h3><p> <a href="https://devtoys.app/">DevToys</a> 是一款Windows 平台免费、开源、离线的开发者工具箱。DevToys 可以帮助开发者完成日常开发任务，例如格式化 JSON、比较文本和测试 RegExp。无需使用许多不可信的网站来处理您的数据执行简单的任务。通过智能检测，DevToys 可以检测用于复制到 Windows 剪贴板的数据的最佳工具。</p>
<p>安装教程可查看 <a href="https://github.com/veler/DevToys#how-to-install-as-an-end-user">https://github.com/veler/DevToys#how-to-install-as-an-end-user</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401261943279.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401261949274.png"></p>
<p>网站：<a href="https://devtoys.app/">https://devtoys.app/</a></p>
<p>开源地址：<a href="https://github.com/veler/DevToys#introduction">https://github.com/veler/DevToys</a></p>
<br />

<h3 id="Redomi：在不同音乐平台之间切换音乐-Android平台"><a href="#Redomi：在不同音乐平台之间切换音乐-Android平台" class="headerlink" title="Redomi：在不同音乐平台之间切换音乐 [Android平台]"></a><a href="https://github.com/acszo/Redomi">Redomi</a>：在不同音乐平台之间切换音乐 [Android平台]</h3><p><a href="https://github.com/acszo/Redomi">Redomi</a> 是一款Android应用，用于将A音乐平台的链接转换为B音乐平台的链接。</p>
<p>支持的音乐平台：</p>
<ul>
<li>Youtube music (+ Revanced, InnerTune, ViMusic)<br>YouTube 音乐（+ Revanced、InnerTune、ViMusic）</li>
<li>Youtube (+ Revanced, NewPipe, LibreTube)<br>YouTube（+ Revanced、NewPipe、LibreTube）</li>
<li>Spotify</li>
<li>Deezer  </li>
<li>Tidal  </li>
<li>Amazon Music  </li>
<li>Apple Music  </li>
<li>Soundcloud  </li>
<li>Napster</li>
</ul>
<p>开源地址：<a href="https://github.com/acszo/Redomi">https://github.com/acszo/Redomi</a></p>
<br />

<h2 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h2><h3 id="专注MacOS应用的独立开发者-Sindre-Sorhus"><a href="#专注MacOS应用的独立开发者-Sindre-Sorhus" class="headerlink" title="专注MacOS应用的独立开发者 Sindre Sorhus"></a>专注MacOS应用的独立开发者 <a href="https://sindresorhus.com/apps">Sindre Sorhus</a></h3><p> <a href="https://sindresorhus.com/apps">Sindre Sorhus</a>  他是一位来自挪威的程序员，以创建和维护各种开源软件项目而闻名。Sindre Sorhus在开源社区中有着广泛的影响力，他的软件项目在GitHub上得到了大量的关注和贡献。他的项目涵盖了各种领域，包括前端开发、后端开发、命令行工具、编辑器插件等等。</p>
<p>一些Sindre Sorhus的知名软件项目包括：<a href="https://sindresorhus.com/command-x">Command X</a> 、<a href="https://sindresorhus.com/one-task">One Task</a> 、<a href="https://sindresorhus.com/menu-bar-calendar">Menu Bar Calendar </a>等等，这些软件项目是Sindre Sorhus为开发者社区做出的贡献的一部分，他的软件以简洁、易用和高质量著称，被广泛使用和赞赏。他还维护了多个优秀的开源项目，比如 <a href="https://github.com/sindresorhus/awesome">awesome</a> (287K Star)、<a href="https://github.com/sindresorhus/awesome-nodejs">awesome-nodejs</a> (54.5K Star)等项目。</p>
<p>App 列表地址： <a href="https://sindresorhus.com/apps">https://sindresorhus.com/apps</a></p>
<p>开源地址： <a href="https://github.com/sindresorhus">https://github.com/sindresorhus</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401261904175.png"></p>
<br />

<h3 id="安卓电视直播软件，内置直播源-my-tv"><a href="#安卓电视直播软件，内置直播源-my-tv" class="headerlink" title="安卓电视直播软件，内置直播源 my-tv"></a>安卓电视直播软件，内置直播源 <a href="https://github.com/lizongying/my-tv">my-tv</a></h3><p><a href="https://github.com/lizongying/my-tv">my-tv</a> 是一款安卓电视直播软件，内置直播源。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401292305957.png"></p>
<p>开源地址：<a href="https://github.com/lizongying/my-tv">https://github.com/lizongying/my-tv</a></p>
<br />

<h3 id="IPTV直播源"><a href="#IPTV直播源" class="headerlink" title="IPTV直播源"></a>IPTV直播源</h3><p>IPTV直播源抓取 自动整合好趣网直播源+TVBox直播源+其他网上直播源 择取分辨率、速度最佳视频流 定期更新。</p>
<p><strong>国内加速：</strong></p>
<ul>
<li><a href="https://mirror.ghproxy.com/https://raw.githubusercontent.com/joevess/IPTV/main/home.m3u8">央视台+卫视台直播源</a></li>
<li><a href="https://mirror.ghproxy.com/https://raw.githubusercontent.com/joevess/IPTV/main/sources/home_sources.m3u8">央视台+卫视台直播源(含备用源)</a></li>
<li><a href="https://mirror.ghproxy.com/https://raw.githubusercontent.com/joevess/IPTV/main/iptv.m3u8">央视台+卫视台+其他地方台直播源</a></li>
<li><a href="https://mirror.ghproxy.com/https://raw.githubusercontent.com/joevess/IPTV/main/sources/iptv_sources.m3u8">央视台+卫视台+其他地方台直播源(含备用源)</a></li>
</ul>
<p><strong>直连访问：</strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/joevess/IPTV/main/home.m3u8">央视台+卫视台直播源</a></li>
<li><a href="https://raw.githubusercontent.com/joevess/IPTV/main/sources/home_sources.m3u8">央视台+卫视台直播源(含备用源)</a></li>
<li><a href="https://raw.githubusercontent.com/joevess/IPTV/main/iptv.m3u8">央视台+卫视台+其他地方台直播源</a></li>
<li><a href="https://raw.githubusercontent.com/joevess/IPTV/main/sources/iptv_sources.m3u8">央视台+卫视台+其他地方台直播源(含备用源)</a></li>
</ul>
<p>开源地址：<a href="https://github.com/joevess/IPTV">https://github.com/joevess/IPTV</a></p>
<br />

<h3 id="互联网最全黑话词典（2024版）"><a href="#互联网最全黑话词典（2024版）" class="headerlink" title="互联网最全黑话词典（2024版）"></a>互联网最全黑话词典（2024版）</h3><p>1.目前最全的互联网黑话词典，收录词条<strong>超过</strong>5000条，超3.5万字，共34个章节，还会持续更新的。</p>
<p>2.黑话词典的意义更多在于解读官话、套话，用人话说心里话，当然也可以让互联网小白快速掌握专用词汇和爱用黑话的朋友对吹。</p>
<p>3.最好的互联网科普读物，帮助大家在<strong>职场生存，求职面试</strong>等过程中更能运筹帷幄。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401292258193.png"></p>
<p>阅读地址：<a href="https://nujuo8y1qx.feishu.cn/docs/doccnGbXj47lGM1iqHk7L1UyW8p">https://nujuo8y1qx.feishu.cn/docs/doccnGbXj47lGM1iqHk7L1UyW8p</a></p>
 <br />

<h3 id="播客推荐：新闻酸菜馆"><a href="#播客推荐：新闻酸菜馆" class="headerlink" title="播客推荐：新闻酸菜馆"></a>播客推荐：<a href="https://www.xiaoyuzhoufm.com/podcast/5e2aadff418a84a046540ad9">新闻酸菜馆</a></h3><p>《新闻酸菜馆》是一档关注独立网络原创电台群体，关注民间话语权的播客。新闻酸菜馆网络电台创立于2011年10月15日。节目内容是以轻松的形式闲聊每周热门新闻话题，与各行业人物对话，深度探析新闻事件背后的思考，是中文网络电台里一档独具特色的新闻评论节目。凭借风格诙谐幽默，评论客观辛辣，分析视角独特，在华人世界广受好评，听众职业和年龄分布十分广泛，是国内发展最为迅猛的网络电台之一。</p>
<p>小宇宙收听链接：  <a href="https://www.xiaoyuzhoufm.com/podcast/5e2aadff418a84a046540ad9">新闻酸菜馆</a></p>
<p>Apple 播客收听链接 ：<a href="https://podcasts.apple.com/cn/podcast/%E6%96%B0%E9%97%BB%E9%85%B8%E8%8F%9C%E9%A6%86/id473501583">《新闻酸菜馆》- Apple 播客</a></p>
<p>荔枝FM收听链接：<a href="https://m.lizhi.fm/vod/user/348">新闻酸菜馆</a></p>
<p>主播博客：<a href="https://since1989.org/">我是王掌柜 – 新闻酸菜馆|极客电台|自媒体联盟</a></p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202401292236850.png"></p>
<br />



<h2 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h2><ul>
<li><a href="https://www.qbitai.com/2024/01/117357.html">高德发布2024年”温暖回家路”服务计划，科技驱动打造春运数字化标配 | 量子位</a></li>
<li><a href="https://www.ithome.com/0/747/636.htm">第三方抢票软件不比官方快：铁路 12306 已进行升级，拦截恶意“抢票”软件 </a></li>
<li><a href="https://www.ithome.com/0/747/268.htm">淘宝启动华为鸿蒙原生应用开发 </a></li>
<li><a href="https://www.qbitai.com/2024/01/115937.html">特斯拉FSD V12在美推送！AI算法黑箱端到端控制，摒弃人类规则程序</a></li>
<li><a href="https://www.36kr.com/p/2623949746346118">10天狂赚13亿的「幻兽帕鲁」凭什么？</a></li>
<li><a href="https://www.xiaohongshu.com/explore/65b6f890000000002c016888">小红书上线关于「风险地点」举报专线的公告</a></li>
<li><a href="https://www.qbitai.com/2024/01/116791.html">GPT-4不偷懒了！OpenAI连甩五个大模型，价格最低打两折 </a>:<ul>
<li>新的GPT-4 Turbo预览模型</li>
<li>新的GPT-3.5 Turbo型号</li>
<li>新的文本审核模型</li>
<li>两种新文本嵌入模型</li>
</ul>
</li>
</ul>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第31期： 万物复苏🌱</title>
    <url>/posts/63498.html</url>
    <content><![CDATA[<p>欢迎阅读第31期技术资讯！本期我们推荐了Flutter 3.19、Android Sunflower、Google AI Dart SDK等技术，介绍了Obsidian 笔记画廊插件、微信 Markdown 编辑器、dockge等工具，分享了科大讯飞 iflycode 智能编程助手、go-proxy-bingai 微软 New Bing 演示站点等资源，推荐了必应每日超清壁纸采集、521GitHub镜像站、微信聊天记录可视化分析WechatVisualization等工具。</p>
<p><img data-src="https://s2.loli.net/2024/02/23/86s7evMFR3tANDk.jpg" alt="封面图 https://www.pexels.com/zh-cn/photo/6602657/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第31期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/ApWcBosSvTVXJBTIxGkhlA">这技术年货真的很哇塞啊！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&mid=2247603186&idx=1&sn=e8cd21269c1031fc4d0bf30ccb97f877&chksm=fa3fcaa7c9a9f6d8d909878053ac324a4ca1a77bf47980ae8e4519b8d958742675e9986b1f13">代码人生攻略：程序员们如何为自己编织一份明朗未来？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/JRdT4vJutvNZ66uqqjYEPg">Flutter 3.19 发布，快来看看有什么更新吧？</a>: </p>
<ul>
<li><strong>Gemini Dart SDK</strong>: 生成式 AI 能力，可生成文本、图像、代码等。</li>
<li><strong>滚动优化</strong>: 修复多指滑动问题，提供更精细的滚动控制。</li>
<li><strong>动画样式</strong>: 快速覆盖 Widget 中的默认动画行为。</li>
<li><strong>Impeller 性能提升</strong>: Android OpenGL 预览，性能优化。</li>
<li><strong>Android 新功能</strong>: Deeplinking 验证器，Share.invoke 支持，Native assets，THLC 模式，自定义文本选择菜单项。</li>
</ul>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/nTUx7yh9LSJnZ0PTONEv6w">Flutter 2024 路线规划，更多可期待的功能正在路上 </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/rCmVVKnlZXAGBxKTACe1zA">探索Android Sunflower：打造完美园艺体验的Jetpack应用 </a></p>
<br /></li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="Obsidian-笔记画廊插件-Note-Gallery"><a href="#Obsidian-笔记画廊插件-Note-Gallery" class="headerlink" title="Obsidian 笔记画廊插件 Note Gallery"></a><a href="https://github.com/pashashocky/obsidian-note-gallery">Obsidian 笔记画廊插件 Note Gallery</a></h2><p><a href="https://github.com/pashashocky/obsidian-note-gallery">Note Gallery</a> 是一款 Obsidian的插件，能够展示笔记画廊。</p>
<p>简单使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~~~note-gallery</span><br><span class="line">sort: desc</span><br><span class="line">limit: 9</span><br><span class="line">~~~~</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402231958676.png"></p>
<p>开源地址：<a href="https://github.com/pashashocky/obsidian-note-gallery">https://github.com/pashashocky/obsidian-note-gallery</a></p>
<p>使用教程：<a href="https://github.com/pashashocky/obsidian-note-gallery?tab=readme-ov-file#quickstart">https://github.com/pashashocky/obsidian-note-gallery?tab=readme-ov-file#quickstart</a></p>
<br />

<h2 id="一款高度简洁的微信-Markdown-编辑器"><a href="#一款高度简洁的微信-Markdown-编辑器" class="headerlink" title="一款高度简洁的微信 Markdown 编辑器"></a>一款高度简洁的微信 Markdown 编辑器</h2><p><a href="https://doocs.github.io/md/">微信 Markdown 编辑器 </a> 是一款高度简洁的微信 Markdown 编辑器：支持 Markdown 所有基础语法、色盘取色、一键复制并粘贴到公众号后台、多图上传、一键下载文档、自定义 CSS 样式、一键重置等特性。</p>
<blockquote>
<p> 一个我特别喜欢的特效是可以把超链接提取出来放到文章底部 ！ ✨✨✨</p>
</blockquote>
<p><img data-src="https://fastly.jsdelivr.net/gh/upwon/MyPicture@master/img/image-20240216175824380.png" alt="image-20240216175824380"></p>
<p>在线地址：<a href="https://doocs.github.io/md/">https://doocs.github.io/md/</a></p>
<p>开源地址：<a href="https://gitee.com/Doocs/md">https://gitee.com/Doocs/md</a></p>
<br />

<h2 id="dockge-简洁易用的-Docker-compose-yaml-管理器"><a href="#dockge-简洁易用的-Docker-compose-yaml-管理器" class="headerlink" title="dockge : 简洁易用的 Docker compose.yaml 管理器"></a><a href="https://github.com/louislam/dockge">dockge</a> : 简洁易用的 Docker compose.yaml 管理器</h2><p><a href="https://github.com/louislam/dockge">dockge</a> 是一款简洁易用的 Docker compose.yaml 管理器，任何修改都是响应式的，能够实时在终端输出。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161506115.png"></p>
<p>开源地址：<a href="https://github.com/louislam/dockge">https://github.com/louislam/dockge</a></p>
<p>安装教程：<a href="https://dockge.kuma.pet/">https://dockge.kuma.pet/</a></p>
<br />

<h2 id="Google-AI-Dart-SDK："><a href="#Google-AI-Dart-SDK：" class="headerlink" title="Google AI Dart SDK："></a>Google AI Dart SDK：</h2><p><a href="https://pub.dev/packages/google_generative_ai">google_generative_ai</a> 是一款全新的 <a href="http://pub.dev/">pub.dev</a> 包，可以让开发者在Dart 和 Flutter 应用程序中利用 Gemini API 构建 生成式 AI 应用。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161726937.png"></p>
<p>包地址：<a href="https://pub.dev/packages/google_generative_ai">https://pub.dev/packages/google_generative_ai</a></p>
<p>博文介绍：<a href="https://medium.com/flutter/harness-the-gemini-api-in-your-dart-and-flutter-apps-00573e560381">https://medium.com/flutter/harness-the-gemini-api-in-your-dart-and-flutter-apps-00573e560381</a> ：这篇文章介绍了 Google AI Dart SDK，这是一个用于在 Dart 和 Flutter 应用程序中利用 Gemini API 进行生成式 AI 开发的工具包。文章还提供了快速入门指南和示例，帮助开发者开始使用 Gemini API。</p>
<p>Twitter：<a href="https://twitter.com/FlutterDev/status/1758219637114687744">https://twitter.com/FlutterDev/status/1758219637114687744</a></p>
<br />

<h2 id="科大讯飞-iflycode-智能编程助手"><a href="#科大讯飞-iflycode-智能编程助手" class="headerlink" title="科大讯飞 iflycode 智能编程助手"></a>科大讯飞 iflycode 智能编程助手</h2><p>iFlyCode 是科大讯飞推出的智能编程助手，基于讯飞星火大模型，可以帮助开发者提高编程效率。iFlyCode 的主要功能包括：</p>
<ul>
<li><p><strong>代码生成：</strong>根据自然语言描述生成代码，支持多种编程语言。</p>
</li>
<li><p><strong>代码补齐：</strong>自动补齐代码，提高编程效率。</p>
</li>
<li><p><strong>代码纠错：</strong>检测并修复代码错误。</p>
</li>
<li><p><strong>代码解释：</strong>解释代码逻辑，帮助开发者理解代码。</p>
</li>
<li><p><strong>生成单元测试：</strong>自动生成单元测试，提高代码质量。</p>
</li>
</ul>
<p>支持语言：Python、Java、JavaScript、C++等多种语言</p>
<p>支持IDE：VSCode、JetBrains系列（IntelliJ IDEA、Clion、PyCharm、WebStorm、Android Studio等）</p>
<p>iFlyCode 目前处于公测阶段，可以免费使用。</p>
<blockquote>
<p>即日起至2024年12月底，我们将向平台的新老用户继续开放个人版免费试用的活动，以此来感谢你们一直以来的支持与厚爱。</p>
<p>iFlyCode产品运营团队<br>2023年11月30日   </p>
<p>from : <a href="https://iflycode.xfyun.cn/">iFlyCode (xfyun.cn)</a></p>
</blockquote>
<p><strong>iFlyCode 的优势：</strong></p>
<ul>
<li><strong>中文支持：</strong>iFlyCode 支持中文输入和输出，这对于中国开发者来说更加方便。</li>
<li><strong>代码生成：</strong>iFlyCode 可以根据自然语言描述生成代码，这可以帮助开发者快速完成代码编写。</li>
<li><strong>代码解释：</strong>iFlyCode 可以对代码进行解释，帮助开发者理解代码的逻辑。</li>
<li><strong>单元测试生成：</strong>iFlyCode 可以自动生成单元测试，帮助开发者提高代码质量。</li>
<li><strong>价格：</strong>iFlyCode 的价格比 Copilot 等同类产品更低。</li>
</ul>
<p><strong>iFlyCode 的不足：</strong></p>
<ul>
<li><strong>代码风格：</strong>iFlyCode 生成的代码风格欠佳，需要开发者进行调整。</li>
<li><strong>代码质量：</strong>iFlyCode 生成的代码质量有待提高，可能存在 bug。</li>
<li><strong>社区支持：</strong>iFlyCode 的社区支持相对较弱，缺乏学习和交流的资源。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161551381.png" alt="注册截图"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161647244.png" alt="体验截图"></p>
<p>官网：<a href="https://iflycode.xfyun.cn/">https://iflycode.xfyun.cn/</a></p>
<br />

<h2 id="go-proxy-bingai：微软-New-Bing-演示站点"><a href="#go-proxy-bingai：微软-New-Bing-演示站点" class="headerlink" title="go-proxy-bingai：微软 New Bing 演示站点"></a><a href="https://github.com/adams549659584/go-proxy-bingai">go-proxy-bingai</a>：微软 New Bing 演示站点</h2><p>基于微软 New Bing 用 Vue3 和 Go 简单定制的微软 New Bing 演示站点，拥有一致的 UI 体验，支持 ChatGPT 提示词，国内可用，基本兼容微软 Bing AI 所有功能，无需登录即可畅聊。</p>
<p>⭐ Bing 官方聊天服务器（相对较快和稳定，推荐）不可用时，可参考以下方案</p>
<blockquote>
<ol>
<li>可用 ModHeader 添加 X-Forwarded-For 请求头，对应 URL 是 wss:&#x2F;&#x2F;sydney.bing.com&#x2F;sydney&#x2F;ChatHub，具体可参考 <a href="https://github.com/adams549659584/go-proxy-bingai/issues/71">issues #71</a> 及 <a href="https://zhuanlan.zhihu.com/p/606655303">https://zhuanlan.zhihu.com/p/606655303</a></li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>本地部署再部署一份作为聊天中转服务，或下载 Release 直接运行，自定义聊天服务器中填入 <a href="http://localhost:8080，并选择。/">http://localhost:8080，并选择。</a></li>
</ol>
</blockquote>
<p>⭐ 聊天服务器 (暂时默认 Cloudflare Workers，请求数每天限额 100,000，撑不了多久 ，推荐自行部署，参考下面 <a href="https://github.com/adams549659584/go-proxy-bingai#%E9%83%A8%E7%BD%B2%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8">部署聊天服务器</a> ) 可在右上角 设置 &#x3D;&gt; 服务选择 中切换</p>
<p>⭐ 国内可用 （部署服务器需要直连 <a href="http://www.bing.com/">www.bing.com</a> 不重定向 CN ，可配置 socks 连接）</p>
<p>⭐ 支持现有开源 ChatGPT 提示词库</p>
<p>⭐ 需要画图等高级功能时(需选更有创造力模式或右上角 设置 &#x3D;&gt; 图像创建 )，可登录微软账号设置用户 Cookie 进行体验</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161937948.png"></p>
<p>开源地址：<a href="https://github.com/adams549659584/go-proxy-bingai">https://github.com/adams549659584/go-proxy-bingai</a></p>
<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="必应每日超清壁纸采集"><a href="#必应每日超清壁纸采集" class="headerlink" title="必应每日超清壁纸采集"></a>必应每日超清壁纸采集</h2><p>作者 <a href="https://www.wdbyte.com/">未读代码</a> 利用 GitHub 的 Actions 功能，进行每日的必应壁纸的抓取，存放在 GitHub 仓库之中。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402131516372.png"></p>
<p>在线网站：<a href="https://bing.wdbyte.com/">https://bing.wdbyte.com/</a></p>
<p>开源地址：<a href="https://github.com/niumoo/bing-wallpaper">https://github.com/niumoo/bing-wallpaper</a></p>
 <br />

<h2 id="必应每日超清壁纸api"><a href="#必应每日超清壁纸api" class="headerlink" title="必应每日超清壁纸api"></a>必应每日超清壁纸api</h2><p>根据 <a href="https://blog.hulebaji.me/posts/29253/#%E5%BF%85%E5%BA%94%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E5%9B%BE%E7%89%87">虎了吧唧</a> 的方法 ， 在 文档中插入以下代码即可显示必应壁纸每天更新的最新壁纸，以下代码三选一就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://api.dujin.org/bing/1366.php&quot; alt=&quot;1399像素Bing每日图片&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;https://api.dujin.org/bing/1920.php&quot; alt=&quot;1920像素Bing每日图片超高清&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;https://api.dujin.org/bing/m.php&quot; alt=&quot;1080*1920每日图片手机超高清&quot; /&gt;</span><br></pre></td></tr></table></figure>



<p>比如，插入 <code>&lt;img src=&quot;https://api.dujin.org/bing/1920.php&quot; alt=&quot;1920像素Bing每日图片超高清&quot; /&gt;</code> 的效果是：</p>
<img data-src="https://api.dujin.org/bing/1920.php" alt="1920像素Bing每日图片超高清" />





<br />

<h2 id="521GitHub镜像站"><a href="#521GitHub镜像站" class="headerlink" title="521GitHub镜像站"></a><a href="https://521github.com/">521GitHub镜像站</a></h2><p><a href="https://521github.com/">521GitHub镜像站</a>  是一个安全、可靠的 GitHub 镜像站，可帮助用户快速、稳定地访问 GitHub。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161917401.png"></p>
<p>在线地址：<a href="https://521github.com/">https://521github.com/</a></p>
<br />

<h2 id="微信聊天记录可视化分析-WechatVisualization"><a href="#微信聊天记录可视化分析-WechatVisualization" class="headerlink" title="微信聊天记录可视化分析 WechatVisualization"></a>微信聊天记录可视化分析 <a href="https://github.com/Jasmine969/WechatVisualization">WechatVisualization</a></h2><p><a href="https://github.com/Jasmine969/WechatVisualization">WechatVisualization</a> 是一款 Python 开发的脚本，用于对微信聊天记录进行分析和可视化。</p>
<p>详细内容可查看作者简介 <a href="https://mp.weixin.qq.com/s/ekVMbA5EH-GNHq_QQ4whaQ">微信聊天记录可视化工具WechatVisualization发布了 </a></p>
<p>（<a href="https://github.com/LC044/WeChatMsg">WeChatMsg: 提取微信聊天记录，将其导出成HTML、Word、CSV文档永久保存，对聊天记录进行分析生成年度聊天报告</a> 也是该作者开发的）</p>
<p>软件网站：<a href="https://memotrace.lc044.love/">https://memotrace.lc044.love/</a></p>
<p>开源地址：<a href="https://github.com/Jasmine969/WechatVisualization">https://github.com/Jasmine969/WechatVisualization</a></p>
<br />

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://www.qbitai.com/2024/02/122387.html?utm_source=pocket_reader">OPPO公布全新AI战略  </a>：OPPO 致力于成为 AI 手机的贡献者和普及者。</p>
</li>
<li><p><a href="https://www.ithome.com/0/751/479.htm">6499 元起，小米 14 Ultra 手机正式发布：搭载高通骁龙 8 Gen3，支持双向卫星通讯  </a></p>
</li>
<li><p>OpenAI 全新文本转视频模型 <a href="https://openai.com/sora">sora</a> ，<a href="https://openai.com/sora">sora</a> 是 OpenAI 全新文本转视频模型，Sora 可以创建长达 60 秒的视频，其中包含高度详细的场景、复杂的摄像机运动以及充满活力的情感的多个角色。</p>
<p>Twitter ：<a href="https://twitter.com/OpenAI/status/1758192957386342435">https://twitter.com/OpenAI/status/1758192957386342435</a></p>
</li>
<li><p><a href="https://www.ithome.com/0/751/678.htm">好莱坞暂未惊慌：业内人士称 OpenAI 文本生成视频工具 Sora 尚不足以颠覆电影业  </a></p>
</li>
<li><p><a href="https://www.qbitai.com/2024/02/122611.html">Gemini 1.5实测：我看Sora一眼假；还有更多惊艳功能  </a></p>
</li>
<li><p><a href="https://www.qbitai.com/2024/02/122699.html">谷歌最强开源大模型亮相！Gemini技术下放，笔记本就能跑，可商用 </a></p>
</li>
<li><p><a href="https://www.ithome.com/0/750/779.htm">比亚迪秦 PLUS 荣耀版上市，售 7.98 万元起  </a></p>
</li>
<li><p><a href="https://www.ithome.com/0/751/675.htm">外卖小哥网约车司机等纳入最低工资保障，工作时间达上限停止派单  </a></p>
</li>
</ul>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
<hr>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第33期</title>
    <url>/posts/36684.html</url>
    <content><![CDATA[<p>欢迎阅读第33期技术资讯！本期我们推荐了Android 15预览版多项创新功能如通知管理、窗口记录以及文件完整性保护，Flutter生态中的MiniTex文本渲染器及其在跨平台上的运用等技术，此外，涵盖了Kotlin 2.0.0-Beta4的更新内容，以及一系列Android开发者实用工具和技术要点，包括内存泄漏、必备插件、依赖管理和热修复方案Tinker。文章还推介了几款有趣的工具，如跨平台多媒体应用Miru App、MacOS应用更新检查工具latest、Windows桌面美化工具DWMBlurGlass。同时，特别推荐了方便快捷的开发者参考资料站点Quick Reference，满足您随时查阅技术细节的需求。最后，提及了一站式AI开发平台扣子和在线音视频处理工具ffmpeg-online。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403091333548.jpg" alt="封面图 https://www.pexels.com/zh-cn/photo/17935433/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第33期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/JYeqP_-XNk7Bqow8Jompzg">2024 ，Android 15 预览版来了 </a> ：引入“通知冷却”功能，限制同一来源的连续通知，降低音量提醒；提供新的 API <code>setupFsVerity</code>，利用 Linux 内核中 fs-verity 功能，保护文件完整性；允许用户仅共享或记录某个应用窗口，而不是整个设备屏幕；</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/cJqZ-WkJ24E4IRaDic8rNQ">Android 15 新功能与亮点大总结  </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/p2hdpXXhN8dST8mJtWq5pg">免加载字体的 Flutter 文本渲染器 —— MiniTex  </a>：MiniTex 是一个文本渲染器，同时具备文本排版能力，借助 MiniTex，Flutter Web CanvasKit 应用可以在不加载字体文件的情况下，依然可以渲染多国语言。MiniTex 支持在 MPFlutter 和 Flutter Web 中使用，开源，免费。本文主要介绍 MiniTex 的实现原理以及使用方法。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/lTmgTV_Jf2C1rMsVN6s0NQ">Jetpack Compose 1.6 发布：性能大升级、拖放新功能、文本新变化</a>：Jetpack Compose 1.6 发布，带来了性能优化、文本改进、拖放支持等新功能。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/POvHlrDV5F9YubvEaSX_Bw">Android内存泄漏知识点  </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/QcvvBhZZBO7RGPMUyT9KRQ">10款对Android开发者来说必不可少的Android Studio插件 </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/C4krqPlptwOypyuslBlcug">使用 Gradle 版本目录进行依赖管理 - Android </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-huH9wFk64db-5UHV3DY-g">拥抱生成式AI，FlutterFlow 低代码移动应用开发平台获2550万美元融资  </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/DI4F2zuRIiXHegT15DUbdg">Android热修复首选方案Tinker探究  </a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/AWrjhOv2RpUDVY37SQBvoA">Kotlin 技术月报 | 2024 年 2 月 </a> ：</p>
<ul>
<li>Kotlin 2.0.0-Beta4 版本发布，K2 编译器稳定性持续提升，Gradle 构建工具方面也有改进。</li>
<li>Kotlin&#x2F;JS 支持类型安全的纯 JavaScript 对象、使用 npm 作为包管理器、导出 List, Map, Set 等集合类型。</li>
<li>Amper 2024 年 2 月更新，支持 Gradle version catalogs、依赖补全、在 IDEA 中创建项目、支持 Fleet 等 IDE。</li>
<li>Jetpack Lifecycle 支持 Kotlin 跨平台，核心 Lifecycle API 现在包含在与 Kotlin Multiplatform 兼容的工件中。</li>
</ul>
<br />

<br /></li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="跨平台开源视频，漫画，小说应用-Miru-App"><a href="#跨平台开源视频，漫画，小说应用-Miru-App" class="headerlink" title="跨平台开源视频，漫画，小说应用 Miru App"></a>跨平台开源视频，漫画，小说应用 <a href="https://github.com/miru-project/miru-app">Miru App</a></h2><p>Miru App 是一款免费，开源的 ，支持视频，漫画，小说扩展源的多功能应用，支持 Android，Windows，Web。</p>
<p>安装好后点开扩展仓库，目前已经提供了一些扩展源，包括有视频、漫画、动漫、小说各个网站平台，选择需要的源安装即可。</p>
<p><strong>特性</strong></p>
<ul>
<li>支持 <code>windows</code>，<code>android</code></li>
<li>友好的扩展编写支持，调试日志</li>
<li>扩展使用 JavaScript 语言，开发简单</li>
<li>支持自定义扩展仓库</li>
<li>官方扩展仓库提供视频源，无需编写任何扩展即可使用</li>
<li>支持在线观看多种视频，漫画，小说源，实现多平台的统一</li>
<li>统一系统 UI 的设计语言</li>
<li>自动获取 TMDB 元数据信息</li>
</ul>
<p><img data-src="https://fastly.jsdelivr.net/gh/upwon/MyPicture@master/img/screenshot.webp"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161812039.png" alt="扩展仓库"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161819255.png" alt="体验截图"></p>
<p>开源地址：<a href="https://github.com/miru-project/miru-app">https://github.com/miru-project/miru-app</a></p>
<p>TG 频道 ：  <a href="https://t.me/MiruChat">https://t.me/MiruChat</a></p>
<br />

<h2 id="保存-MacOS-应用最新：-latest"><a href="#保存-MacOS-应用最新：-latest" class="headerlink" title="保存 MacOS 应用最新： latest"></a>保存 MacOS 应用最新： <a href="https://github.com/mangerlahn/latest">latest</a></h2><p><a href="https://github.com/mangerlahn/latest">latest</a> 是一款免费开源的 macOS 应用程序，可轻松检查所有已安装应用程序的更新状态，并一键获取最新版本。</p>
<p><img data-src="https://s2.loli.net/2024/02/16/ekCDQfAcxB9FoWH.png"></p>
<p>开源地址：<a href="https://github.com/mangerlahn/latest">https://github.com/mangerlahn/latest</a></p>
<br />

<h2 id="DWMBlurGlass-给全局系统标题栏添加自定义效果-Windows平台"><a href="#DWMBlurGlass-给全局系统标题栏添加自定义效果-Windows平台" class="headerlink" title="DWMBlurGlass 给全局系统标题栏添加自定义效果 [Windows平台]"></a><a href="https://github.com/Maplespe/DWMBlurGlass?tab=readme-ov-file">DWMBlurGlass</a> 给全局系统标题栏添加自定义效果 [Windows平台]</h2><p><a href="https://github.com/Maplespe/DWMBlurGlass?tab=readme-ov-file">DWMBlurGlass</a> 是一款 Windows 桌面应用，可以给全局系统标题栏添加自定义效果实现美化，支持win10和win11。 </p>
<p><strong>特效</strong></p>
<ul>
<li>为全局系统标题栏添加自定义效果</li>
<li>可自定义全局或仅标题栏的模糊强度</li>
<li>可自定义标题栏混合颜色</li>
<li>可自定义标题栏文本颜色</li>
<li>可添加Aero反射和视差效果</li>
<li>可还原win7样式标题栏按钮高度</li>
<li>支持为使用旧版win7API DwmEnableBlurBehindWindow 的程序启用模糊效果</li>
<li>支持 <code>Blur</code>, <code>Aero</code>, <code>Acrylic</code>, <code>Mica(仅win11)</code> 效果</li>
<li>可单独设置 亮&#x2F;暗 颜色模式颜色，跟随系统自动切换</li>
<li>提供 <code>CustomBlur</code>、<code>AccentBlur</code>、<code>SystemBackdrop</code> 模糊方法可选</li>
<li>第三方主题支持</li>
</ul>
<p><img data-src="https://s2.loli.net/2024/02/16/DrRO4XPiBdjN521.png"></p>
<p>开源地址：<a href="https://github.com/Maplespe/DWMBlurGlass">https://github.com/Maplespe/DWMBlurGlass</a></p>
<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="为开发人员分享快速参考备忘清单-速查表-：reference"><a href="#为开发人员分享快速参考备忘清单-速查表-：reference" class="headerlink" title="为开发人员分享快速参考备忘清单(速查表) ：reference"></a>为开发人员分享快速参考备忘清单(速查表) ：<a href="https://github.com/jaywcjlove/reference">reference</a></h2><p><a href="https://wangchujiang.com/reference/">Quick Reference</a> 一个为开发人员分享快速参考备忘清单(速查表)的在线网站。</p>
<p><img data-src="https://s2.loli.net/2024/02/16/yptnbUraTi8VS1g.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161858206.png"></p>
<p>在线地址：<a href="https://wangchujiang.com/reference/">https://wangchujiang.com/reference/</a></p>
<p>开源地址：<a href="https://github.com/jaywcjlove/reference">https://github.com/jaywcjlove/reference</a></p>
<p>自行部署教程：<a href="https://mp.weixin.qq.com/s/hravSQOfvw1Eu5odNCWaFA">https://mp.weixin.qq.com/s/hravSQOfvw1Eu5odNCWaFA</a></p>
<br />

<h2 id="一站式-AI-开发平台-扣子"><a href="#一站式-AI-开发平台-扣子" class="headerlink" title="一站式 AI 开发平台 扣子"></a>一站式 AI 开发平台 <a href="https://www.coze.cn/">扣子</a></h2><p>扣子是新一代 AI 大模型智能体开发平台。整合了插件、长短期记忆、工作流、卡片等丰富能力，扣子能帮你低门槛、快速搭建个性化或具备商业价值的智能体，并一键发布到豆包、飞书、微信服务号等各个渠道！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403082327866.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403082329068.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403082329839.png"></p>
<p>在线地址：<a href="https://www.coze.cn/">https://www.coze.cn/</a></p>
<br />

<h2 id="ffmpeg-online-：在线处理音视频"><a href="#ffmpeg-online-：在线处理音视频" class="headerlink" title="ffmpeg-online ：在线处理音视频"></a><a href="https://ffmpeg-online.vercel.app/?inputOptions=-i&output=output.mp4&outputOptions=">ffmpeg-online</a> ：在线处理音视频</h2><p><a href="https://ffmpeg-online.vercel.app/?inputOptions=-i&output=output.mp4&outputOptions=">ffmpeg-online</a>  是一个基于 <a href="https://github.com/ffmpegwasm/ffmpeg.wasm">ffmpeg.wasm</a> 的在线网站，可用于在线处理音频和视频。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202402161924945.png"></p>
<p>体验地址：<a href="https://ffmpeg-online.vercel.app/?inputOptions=-i&output=output.mp4&outputOptions=">https://ffmpeg-online.vercel.app/?inputOptions=-i&output=output.mp4&outputOptions=</a></p>
<p> <a href="https://github.com/ffmpegwasm/ffmpeg.wasm">ffmpeg.wasm</a> 地址： <a href="https://github.com/ffmpegwasm/ffmpeg.wasm">https://github.com/ffmpegwasm/ffmpeg.wasm</a> </p>
<br />

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://www.iplaysoft.com/news/6106?utm_source=pocket_reader">凉了！微软正式 “砍掉” 大家都喜欢的安卓子系统！ </a>:  在 Windows 上运行安卓 APP 是无数网友对 Win11 最感兴趣的功能之一，发布后引来了叫好声一片！甚至很多人都是奔着这功能去升级 Win11的。然而非常痛心的是，微软发布公告宣布正式放弃 WSA！</p>
</li>
<li><p><a href="https://www.qbitai.com/2024/03/126453.html?utm_source=pocket_reader">GPT-4王冠没掉！Claude 3竞技场人类投票成绩出炉：仅居第三 | 量子位 (qbitai.com)</a>：人工智能模型Claude 3在“大模型竞技场”（LMSYS Chatbot Arena Leaderboard）上的人类投票成绩。经过约20000张投票，Claude 3的“大杯”模型(Opus)获得了1233分，位列第三，成为首个能在排行榜上与GPT-4-Turbo系列竞争的模型。然而，Claude 3并未超越GPT-4系列，其中GPT-4 Turbo的两个版本以相同的最高分1251分占据榜首位置。</p>
</li>
<li><p><a href="https://www.36kr.com/p/2676078636283398">暴跌90%，77亿市值灰飞烟灭，元宇宙第一股，崩了-36氪 (36kr.com)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/2fX4D2RJ8e_l_UfQo4ZGbQ">漫画家鸟山明因急性硬膜下血肿去世，享年68岁，曾创作《阿拉蕾》《龙珠》等经典作品</a></p>
</li>
</ul>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
<hr>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第37期</title>
    <url>/posts/43500.html</url>
    <content><![CDATA[<p>欢迎阅读第37期技术资讯！欢迎阅读本期技术资讯！在<strong>软件开发</strong>领域，Twitter 分享了 Compose 开发规范和检查，助您避免常见错误；Android Studio Iguana 发布了新版本，带来了 AppQualityInsights 中的版本控制、Compose UI 检查和预览的渐进式渲染等新特性。<strong>工具推荐</strong>方面方面，我们介绍了高性能分布式存储数据库 Garnet，可无缝替换 Redis；类似 uTools 的工具 Fluent Search，可提升您的工作效率；软件下载网站，助您找到所需软件；Windows 白噪音应用 Ambie，可帮助您集中注意力、睡眠和放松；Mac 翻译和 OCR 软件 Bob，可轻松进行文本翻译和识别；跨平台划词翻译和 OCR 软件 pot，以及开源划词翻译软件 TTime，让您在不同平台也能轻松进行划词翻译和 OCR 操作。<strong>宝藏信息</strong>方面，分享了无限制创建 Gmail 小号的方法，免费的闯关式 SQL 自学教程网站 SQL 之母，以及本地部署免费的 GPT3.5-API的aurora。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404062339649.jpg" alt="封面图 宁波四月·2024"></p>
<span id="more"></span>



<br />

<p>欢迎来到第37期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/TNykGX5S_nYPGw44l0UYMg">Twitter 的 17 条 Compose 开发规范和检查：帮你避坑～  </a>：文章翻译自Twitter官方的Compose规则文档，分享了Twitter在使用Compose进行开发过程中总结出的一套最佳实践和规则。这些规则覆盖了状态管理、可组合函数的使用、参数定义、CompositionLocals、Modifiers等多个方面，旨在提高代码质量和可维护性。</p>
<p>文章详细介绍了每一条规则的内容、目的和实施方法，包括但不限于：</p>
<ol>
<li>保持状态的提升，避免向下传递ViewModels或State实例。</li>
<li>使用<code>@Immutable</code>注解确保数据的不可变性。</li>
<li>避免使用不稳定的集合。</li>
<li>不使用可变类型作为函数参数。</li>
<li>可组合函数不应同时发射布局和返回结果。</li>
<li>避免发射多片段的布局节点。</li>
<li>为CompositionLocals和预览注解使用合适的命名。</li>
<li>明确声明可组合函数之间的依赖关系。</li>
</ol>
<p>文章还提到了如何使用ktlint和Detekt工具来集成和执行这些规则检查，以及如何将自定义的CompositionLocal添加到允许列表中。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/xpkDZjF8SOfnBDqX2IVvvw">使用 ML Kit 文档扫描器 API 轻松将文档扫描功能添加至您的应用 </a>：文章宣布了ML Kit文档扫描器API的推出，这是一个全新的API，它允许开发者在不具备机器学习知识的情况下，无缝集成由机器学习驱动的文档扫描功能。该API提供了以下优势：</p>
<ul>
<li>高质量且一致的用户界面，用于数字化处理实体文档。</li>
<li>精准的角点和边缘检测技术，实现精确的文档检测。</li>
<li>用户可以裁剪扫描的文档、添加滤镜，并去除瑕疵。</li>
<li>数字化文件可以以PDF和JPEG格式发送回应用。</li>
<li>设备端处理，保护用户隐私。</li>
<li>无需相机权限的完整解决方案。</li>
</ul>
</li>
<li><p><a href="https://juejin.cn/post/7299799127625170955">移动端APP版本治理</a>：文章提出了一系列方案来提升版本更新率，包括升级交互设计、提醒策略、提示文案、更新渠道、触达投放和其他策略。这些方案旨在通过不同的方式提醒和引导用户更新到最新版本。</p>
<p>最后，文章建议制定流程SOP，形成一个完整的版本治理策略，以实现自动化和流程化的版本更新管理。</p>
</li>
<li><p><a href="https://m.okjike.com/originalPosts/65fb8bf1164d89e6019b33d7">如何有效听播客？分享我的播客管理流～ 作为一个播客深度爱好</a>：文章分享了作者作为播客深度爱好者如何有效管理和利用播客内容进行自我提升的方法和工具。作者提到了具体操作步骤，包括在谷歌应用商店下载插件、在小宇宙复制播客链接、使用浏览器扩展程序下载音频、上传到飞书妙记或通义听悟进行文字转换。最后，作者会整理笔记并提炼知识点，放入Notion知识库中，以便最大程度吸收所听内容。</p>
</li>
<li><p><a href="https://juejin.cn/post/7340920192996229130">Android Studio Iguana | 2023.2.1 发布，快来看看有什么更新吧 </a>：文章介绍了Android Studio Iguana版本（2023.2.1）的更新内容，包括AppQualityInsights中的版本控制、Compose UI检查和预览的渐进式渲染、BaselineProfiles向导和支持Gradle版本目录等新特性。</p>
</li>
<li><p><a href="https://juejin.cn/post/6946416845537116190">Flutter 组件 | 手牵手，一起走 CompositedTransformFollower 与 CompositedTransformTarget </a>：文章首先介绍了CompositedTransformTarget和CompositedTransformFollower这两个Flutter组件的作用和用途。作者通过分析Slider组件的源码，解释了这两个组件如何在Slider中被用来处理Overlay提示框的显示和位置变换。</p>
<p>作者提供了几个使用这两个组件的精简案例，展示了如何通过CompositedTransformFollower和CompositedTransformTarget实现Overlay提示信息的显示和隐藏，以及如何控制Overlay的相对位置。案例中使用了LayerLink来建立目标组件和跟随组件之间的连接，并通过设置对齐方式、偏移量和锚点来控制Overlay的位置。</p>
<p>文章还讨论了变换一致性的问题，指出使用这两个组件可以确保Overlay在滑动、缩放、旋转等操作中与目标组件保持一致的变换关系，无需进行复杂的计算。</p>
<p>最后，作者指出CompositedTransformFollower并不仅限于Overlay使用，也可以在Stack中用于普通组件之间的绑定关系，尽管在普通组件间这并不是必要的。</p>
</li>
<li><p><a href="https://www.codedump.info/post/20220304-weekly-8/">周刊（第8期）：技术配图的一些心得 - codedump的网络日志</a>：本文分享了作者在技术配图方面的心得体会，强调了配图在技术沟通中的重要性，并通过区分、联系、组合等多个原则举例说明如何有效地制作和运用技术配图。</p>
</li>
<li><p><a href="https://juejin.cn/post/7310474225809784884">当 App 有了系统权限，真的可以为所欲为？  </a>：文章讨论了一个热门的Android App如何利用Android系统漏洞获得系统权限，并列举了App在获取权限后所做的一系列行为。这些行为包括自启动和关联启动的修改、通知权限的开启、监听通知内容、获取用户使用手机的信息、修改系统设置等。文章还提到了App对不同手机厂商的特定处理，如华为、Oppo、Vivo和Xiaomi。</p>
</li>
<li><p><a href="https://juejin.cn/post/7329573765087019034">Flutter 新一代混合栈管理框架—— Fusion 让混合开发如此简单  </a> ：文章详细介绍了Fusion框架，这是一个旨在帮助开发者在使用Flutter与Native进行混合开发时减少两者之间的隔阂，提升开发体验的框架。Fusion采用引擎复用方案，确保APP在多次跳转中始终只有一份FlutterEngine实例，从而提高性能和降低内存占用。</p>
<p>Fusion解决了混合开发中常见的一些问题，如状态栏图标颜色显示不正确、任务界面应用名称不显示等，并彻底解决了黑屏、白屏、闪屏等问题。此外，Fusion支持应用在后台被系统回收后所有Flutter页面的正常恢复。</p>
<p>文章还提供了Fusion的使用指南，包括初始化、Flutter容器的创建、路由API、FlutterPlugin注册、自定义Channel、生命周期监听、全局通信以及返回拦截等功能的实现方法。Fusion目前支持Android和iOS平台，并正在适配纯鸿蒙平台。</p>
</li>
</ul>
<br />

<br />


<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="高性能的分布式存储数据库-Garnet-，-无缝替换Redis"><a href="#高性能的分布式存储数据库-Garnet-，-无缝替换Redis" class="headerlink" title="高性能的分布式存储数据库 Garnet ， 无缝替换Redis"></a>高性能的分布式存储数据库 Garnet ， 无缝替换Redis</h2><p>Garnet，这是一个由微软研究院开发的新型远程缓存存储系统，基于C# .NET 8.0构建。Garnet的设计目标是实现极速、可扩展和低延迟的性能。它支持单节点线程扩展、分片集群执行，以及复制、检查点、故障转移和事务处理功能。Garnet可以在主内存和分层存储（如SSD和Azure存储）上运行，并提供丰富的API接口和强大的可扩展性模型。</p>
<p>Garnet使用Redis的RESP协议作为主要通信协议，因此可以无缝替换Redis，而无需修改客户端代码。与其他开源缓存存储相比，Garnet在性能、延迟、可扩展性和持久性方面都有显著提升。尽管Garnet是一个研究项目，但其质量和稳定性已经得到了微软内部团队的认可和部署。</p>
<p>优势：</p>
<ul>
<li>Garnet 采用流行的 RESP 线路协议作为起点，这使得可以从当今大多数编程语言（例如 C# 中的 StackExchange.Redis）中可用的未经修改的 Redis 客户端使用 Garnet。</li>
<li>相对于同类开源缓存存储，Garnet 通过许多客户端连接和小批量提供更好的吞吐量和可扩展性，从而节省大型应用程序和服务的成本。</li>
<li>Garnet 使用启用了加速 TCP 的Azure  VM 展示了极低的客户端延迟（在 99.9% 时通常低于 300 微秒），这对于现实场景至关重要。</li>
<li>Garnet 基于最新的 .NET 技术，具有跨平台、可扩展和现代化的特点。它被设计为易于开发和发展，而不会牺牲常见情况下的性能。我们利用 .NET 丰富的库生态系统来扩展 API，并提供开放的优化机会。由于我们对 .NET 的精心使用，Garnet 在 Linux 和 Windows 上都实现了最先进的性能。</li>
</ul>
<blockquote>
<p>Garnet 实现了广泛的 API，包括原始字符串（例如，获取、设置和密钥过期）、分析（例如，HyperLogLog 和 Bitmap）和对象（例如，排序集和列表）操作。它可以以客户端 RESP 事务和我们自己的 C# 服务器端存储过程的形式处理多密钥事务，并允许用户在原始字符串和新对象类型上定义自定义操作，所有这些都以 C# 的便利性和安全性实现，导致开发自定义扩展的门槛较低。</p>
<p>Garnet 使用快速且可插拔的网络层，支持未来的扩展，例如利用内核旁路堆栈。它使用强大的 .NET SslStream 库支持安全传输层安全 (TLS) 通信以及基本访问控制。 Garnet 的存储层称为 Tsavorite，是从我们之前的开源项目 FASTER 中分叉出来的，包括强大的数据库功能，例如线程可扩展性、分层存储支持（内存、SSD 和云存储）、快速非阻塞检查点、恢复、操作日志记录以实现持久性、多键事务支持以及更好的内存管理和重用。最后，Garnet 支持集群操作模式，支持分片、复制和动态密钥迁移。</p>
</blockquote>
<p>在 <a href="https://microsoft.github.io/garnet/docs/benchmarking/overview">https://microsoft.github.io/garnet/docs/benchmarking/overview</a> 网站上展示了一些关键结果，将 Garnet 与领先的开源缓存存储进行比较。</p>
<p>开源地址：<a href="https://github.com/microsoft/garnet">https://github.com/microsoft/garnet</a></p>
<br />

<h2 id="类似uTools的工具-Fluent-Search"><a href="#类似uTools的工具-Fluent-Search" class="headerlink" title="类似uTools的工具 Fluent Search"></a>类似uTools的工具 Fluent Search</h2><p>Fluent Search 可以轻松搜索正在运行的应用程序、浏览器选项卡、文件和应用程序内内容，专供 Windows 10&#x2F;11 用户使用。搜索标签可让您轻松过滤搜索结果。使用搜索标签查找特定书签、特定格式的文件、特定搜索引擎的网页结果等。<br>Fluent Search 使用先进的机器学习模型来了解您的使用模式并根据您的常用工作流程建议结果。<br>搜索屏幕让您无需鼠标即可使用计算机。在屏幕上的每个可点击对象上，Fluent Search 都会显示一个可以使用键盘触发的标签。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403312312220.png"></p>
<p>官网：<a href="https://fluentsearch.net/">https://fluentsearch.net/</a></p>
<p>微软应用商店：<a href="https://apps.microsoft.com/detail/9nk1hlwhnp8s?hl=zh-cn&gl=HK">https://apps.microsoft.com/detail/9nk1hlwhnp8s?hl=zh-cn&gl=HK</a>：   Fluent Search 适用于 Windows 10&#x2F;11，可从 Microsoft Store 下载。 </p>
<p>Twitter：<a href="https://twitter.com/FluentSearch">Fluent Search (@FluentSearch) &#x2F; X (twitter.com)</a></p>
<br />

<h2 id="软件下载网站-https-filecr-com"><a href="#软件下载网站-https-filecr-com" class="headerlink" title="软件下载网站 https://filecr.com/"></a>软件下载网站 <a href="https://filecr.com/">https://filecr.com/</a></h2><p><a href="https://filecr.com/">https://filecr.com/</a> 是一个软件下载网站，可下载Windows、macOS、Android应用的正版应用和开心版应用。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403312330236.png"></p>
<p>网址：<a href="https://filecr.com/">https://filecr.com/</a></p>
<br />

<h2 id="Ambie：-Windows平台白噪音应用"><a href="#Ambie：-Windows平台白噪音应用" class="headerlink" title="Ambie： Windows平台白噪音应用"></a>Ambie： Windows平台白噪音应用</h2><p>Ambie 是一款播放白噪音和自然声音的应用程序，可帮助您集中注意力、睡眠和放松。对于许多人来说，在完成任务时有背景噪音有助于集中注意力。 Ambie 有一系列不错的内置声音可供选择，例如雨声和海浪声，可以帮助您。这些也可以用来帮助您睡眠、放松和减压。如果您从 Microsoft Store 下载 Ambie，您将可以访问在线声音目录，您可以下载这些声音来扩展您的库。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404032251047.png"></p>
<p>微软应用商店下载：<a href="https://apps.microsoft.com/store/detail/ambie-white-noise/9P07XNM5CHP0?cid=ambierepo">https://apps.microsoft.com/store/detail/ambie-white-noise/9P07XNM5CHP0?cid=ambierepo</a></p>
<p>开源地址：<a href="https://github.com/jenius-apps/ambie">https://github.com/jenius-apps/ambie</a></p>
<br />

<h2 id="Bob-翻译-OCR-软件-Mac平台"><a href="#Bob-翻译-OCR-软件-Mac平台" class="headerlink" title="Bob 翻译 &amp; OCR 软件  Mac平台"></a>Bob 翻译 &amp; OCR 软件  Mac平台</h2><p>Bob是一款功能强大的翻译和OCR软件，专为macOS用户打造。它提供了一种简便的方式来在任何应用程序中进行文本翻译和识别，无需离开当前正在使用的程序。这意味着用户可以即用即走，无需中断工作流程，提高了工作效率。</p>
<p>该软件的特点是简单、快捷和高效，它通过一个直观的界面使用户能够轻松地进行翻译和OCR操作。Bob还提供了一个快速上手指南，帮助新用户快速了解如何使用该软件。</p>
<p>主要特性：</p>
<ul>
<li><strong>翻译功能</strong>：划词翻译、截图翻译、输入翻译、翻译多开、自定义插件、自动识别语种、驼峰拆分、蛇形拆分、AppleScript 调用、PopClip 调用</li>
<li><strong>OCR 功能</strong>：截图 OCR、静默截图 OCR、访达选图 OCR、离线识别、连续识别、二维码识别、自动复制、智能分段</li>
</ul>
<p>支持的服务：</p>
<ul>
<li><strong>文本翻译</strong>：系统翻译、火山翻译、腾讯翻译君、阿里翻译、百度翻译、有道翻译、彩云小译、小牛翻译、Google 翻译、Microsoft 翻译、Amazon 翻译、DeepL 翻译、OpenAI 翻译</li>
<li><strong>文本识别</strong>：离线文本识别、火山 OCR、腾讯 OCR、腾讯图片翻译、百度 OCR、有道 OCR、Google OCR</li>
<li><strong>语音合成</strong>：离线语音合成、火山语音合成 、腾讯语音合成、Google 语音合成、Microsoft 语音合成</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404022213753.png"></p>
<p>网址： <a href="https://bobtranslate.com/">https://bobtranslate.com/</a>    （Bob 不是开源软件）</p>
<p>使用演示：<a href="https://github.com/ripperhe/Bob">https://github.com/ripperhe/Bob</a></p>
<br />

<h2 id="跨平台划词翻译和OCR软件-pot"><a href="#跨平台划词翻译和OCR软件-pot" class="headerlink" title="跨平台划词翻译和OCR软件 pot"></a>跨平台划词翻译和OCR软件 <a href="https://github.com/pot-app/pot-desktop">pot</a></h2><p><a href="https://github.com/pot-app/pot-desktop">pot</a> （派了个萌的翻译器）是一个跨平台的划词翻译软件，支持多个操作系统，包括Windows、macOS和Linux。项目使用了Tauri框架，结合了JavaScript和Rust编程语言进行开发。</p>
<p><strong>项目特点：</strong></p>
<ul>
<li>支持划词翻译、输入翻译、剪切板监听模式和截图OCR功能。</li>
<li>支持多接口并行翻译、文字识别和语音合成。</li>
<li>提供了插件系统，允许用户通过安装额外的插件来扩展软件功能。</li>
<li>支持Wayland显示服务器协议，适用于多种桌面环境。</li>
</ul>
<p><strong>安装指南：</strong></p>
<ul>
<li>Windows: 可以通过Winget安装，或者手动下载exe安装包。</li>
<li>macOS: 可以通过Homebrew安装，或者手动下载dmg安装包。</li>
<li>Linux: 可以通过APT或Flatpak安装，或者手动下载deb安装包。</li>
</ul>
<p><strong>外部调用：</strong> Pot提供了HTTP接口，允许其他软件通过发送HTTP请求来调用Pot的翻译功能。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404022221922.png"></p>
<p>安装指南：<a href="https://github.com/pot-app/pot-desktop#%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">https://github.com/pot-app/pot-desktop#%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97</a></p>
<p>网站：<a href="https://pot-app.com/">https://pot-app.com/</a></p>
<p>开源地址：<a href="https://github.com/pot-app/pot-desktop">https://github.com/pot-app/pot-desktop</a></p>
<p>同类软件：<a href="https://ttime.timerecord.cn/">TTime | 一款简洁、高效、高颜值的输入、截图、划词翻译AI软件 (timerecord.cn)</a></p>
<br />

<h2 id="开源划词翻译软件-TTime"><a href="#开源划词翻译软件-TTime" class="headerlink" title="开源划词翻译软件 TTime"></a>开源划词翻译软件 <a href="https://ttime.timerecord.cn/">TTime</a></h2><p><a href="https://ttime.timerecord.cn/">TTime</a> 是一款开源的简洁高效的输入、截图、划词翻译软件，主要功能包括：<code>输入翻译</code>、<code>截图翻译</code>、<code>划词翻译</code>、<code>悬浮球翻译</code>、<code>截图OCR</code>、<code>静默截图OCR</code>、<code>剪贴板监听翻译</code>。支持 Windows和Mac平台。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404022231895.png"></p>
<p>网站：<a href="https://ttime.timerecord.cn/">https://ttime.timerecord.cn/</a></p>
<p>使用介绍：<a href="https://ttime.v1.timerecord.cn/pages/1c1de2/#%E7%AE%80%E4%BB%8B">https://ttime.v1.timerecord.cn/pages/1c1de2/#%E7%AE%80%E4%BB%8B</a></p>
<p>开源地址：<a href="https://github.com/InkTimeRecord/TTime">https://github.com/InkTimeRecord/TTime</a></p>
<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="无限制造-Gmail-小号，但指向同一个邮箱"><a href="#无限制造-Gmail-小号，但指向同一个邮箱" class="headerlink" title="无限制造 Gmail 小号，但指向同一个邮箱"></a>无限制造 Gmail 小号，但指向同一个邮箱</h2><p><a href="https://mp.weixin.qq.com/s/gGMD13i2u5TwP3Q67JemDA?utm_source=pocket_saves">Gmail 诞生二十周年，无限创建 Gmail 小号 </a> 一文分享了一个无限创建Gmail小号的方法，利用Gmail支持的点（.）和加号（+）在用户名中的变化，来创建多个指向同一邮箱的小号。这样做可以在不同网站使用不同邮箱地址注册账号，并方便管理通过不同地址发送的邮件。同时，这也有助于识别哪个网站可能泄露了个人信息。</p>
<p>具体方法为：</p>
<p>Gmail 跟其他常见的邮箱地址最不同的地方，就是不支持底线 _ ，相反却支持点 . 和加号 +。而这个制造小号的方法，就是有效利用 . 和 + 。</p>
<p>我们以 <a href="mailto:ddl123@gmail.com">ddl123@gmail.com</a> 举例。</p>
<ol>
<li><strong>利用点（.）</strong>：在Gmail地址的用户名部分任意位置添加点（.），例如<code>ddl.123@gmail.com</code>或<code>ddl...123@gmail.com</code>。Gmail会将这些带有不同数量和位置的点的地址视为同一个邮箱。</li>
<li><strong>使用加号（+）</strong>：在用户名和@之间插入加号（+）加上任意字串，如<code>ddl123+bbc456@gmail.com</code>。可以添加多个加号和不同的字串，例如<code>ddl123+b+b+c+1+2+3@gmail.com</code>。</li>
<li><strong>创建特定用途的小号</strong>：根据不同的网站和服务，使用加号（+）创建具有唯一标识的小号，如<code>ddl123+Apple@gmail.com</code>、<code>ddl123+Facebook@gmail.com</code>、<code>ddl123+Twitter@gmail.com</code>等。</li>
<li><strong>追踪垃圾邮件来源</strong>：当收到垃圾邮件时，通过检查收件人地址可以识别出是哪个网站或服务泄露了你的信息。</li>
</ol>
<p>原文：<a href="https://mp.weixin.qq.com/s/gGMD13i2u5TwP3Q67JemDA?utm_source=pocket_saves">Gmail 诞生二十周年，无限创建 Gmail 小号 </a></p>
<br />

<h2 id="免费的闯关式-SQL-自学教程网站-SQL之母"><a href="#免费的闯关式-SQL-自学教程网站-SQL之母" class="headerlink" title="免费的闯关式 SQL 自学教程网站 SQL之母 "></a>免费的闯关式 SQL 自学教程网站 <a href="http://sqlmother.yupi.icu/#/learn">SQL之母 </a></h2><p><a href="http://sqlmother.yupi.icu/#/learn">SQL之母 </a>是一个完全免费的闯关式 SQL 自学教程网站，结合作者自己的 SQL 学习实践经验，编写了 30 多个关卡，用户可以在线提交 SQL 代码做题闯关，目标是从 0 到 1 地带大家掌握常用的 SQL 语法。</p>
<p>此外，网站支持自由选择关卡、自定义关卡、SQL 在线练习广场等功能。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404032131770.png"></p>
<p>在线体验：<a href="http://sqlmother.yupi.icu/">http://sqlmother.yupi.icu</a>  </p>
<p>视频演示：<a href="https://www.bilibili.com/video/BV1pV4y1i7LW">https://www.bilibili.com/video/BV1pV4y1i7LW</a> </p>
<br />

<h2 id="本地部署免费的GPT3-5-API：aurora"><a href="#本地部署免费的GPT3-5-API：aurora" class="headerlink" title="本地部署免费的GPT3.5-API：aurora"></a>本地部署免费的GPT3.5-API：<a href="https://github.com/aurora-develop/aurora?tab=readme-ov-file">aurora</a></h2><p>通过本地部署 <a href="https://github.com/aurora-develop/aurora?tab=readme-ov-file">aurora</a> 可以获得本地可调用的 GPT3.5-API ，当然也可以 部署到 Docker 上面。</p>
<p>开源地址：<a href="https://github.com/aurora-develop/aurora">https://github.com/aurora-develop/aurora</a></p>
<br />

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://www.36kr.com/p/2715592796174208">今天起，ChatGPT无需注册就能用了</a>: 文章报道了OpenAI的一项新政策，即用户现在可以直接使用ChatGPT，无需进行账号注册和登录。这一变化是为了让更多的人能够轻松接触和使用AI。尽管如此，只有ChatGPT的3.5版本对所有用户开放，GPT-4的使用仍然需要传统的登录方法。</p>
</li>
<li><p><a href="https://www.36kr.com/p/2713125455607689">iOS史诗级更新来了，比iPhone 16更值得期待 </a>: 在WWDC 2024上发布的iOS 18更新，预计将包括外观个性化、主屏幕自定义、支持与安卓互传文件等功能。iOS 18的更新可能会使iPhone与安卓系统在功能上更加接近，例如支持RCS富媒体通信标准，允许iOS和安卓用户直接互相发送消息、图片、文件等。文章还提到，苹果计划将AI技术集成到iOS 18的各个方面，Siri将得到显著增强，提供更强的自然对话能力和与快捷指令的深度集成。苹果在AI领域的布局相比其他智能手机厂商较慢，但最近有消息称苹果计划引入谷歌的Gemini大模型，并与OpenAI探讨合作可能性。由于中国法律的要求，苹果可能需要与国内科技公司合作才能在中国提供大模型服务。</p>
</li>
<li><p><a href="https://www.ithome.com/0/759/966.htm">Opera 成为首个集成本地 LLM 的浏览器</a>：Opera 浏览器推出了最新的 Opera One 版本，成为首个试行支持150种本地大语言模型（LLM）的主流浏览器，旨在提供更强的隐私性和处理速度。</p>
</li>
<li><p><a href="https://www.ifanr.com/1579912">5.5G 正式商用！增加 0.5G，不止让你网速快上十倍  </a></p>
</li>
<li><p><a href="https://www.landiannews.com/archives/103193.html">开源社区的悲哀：前有苹果白嫖curl 现在微软试图白嫖FFmpeg - 蓝点网 </a>：文章讨论了微软与FFmpeg之间的争议，指出微软试图以一次性支付解决依赖FFmpeg的Microsoft Teams的问题，而FFmpeg团队寻求长期维护支持合同，反映了开源社区在商业利益面前的困境。</p>
</li>
<li><p><a href="https://www.coolapk.com/feed/54173048?shareKey=MjgyMWRhMWIyNTdlNjYwZDZjOWU~">【笔电月报】2024.3 笔记本电脑避坑指南&#x2F;科普&#x2F;吐槽 来自 夏蒙乾 - 酷安 </a></p>
</li>
<li><p><a href="https://m.ithome.com/html/760233.htm">小米 14 周年 2024 年米粉节开启：手机换电池换屏 8 折、换新机享优惠 </a></p>
</li>
</ul>
<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于    <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>3-C++核心编程</title>
    <url>/posts/4ba6638b.html</url>
    <content><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gg3mydqmatj24mo334x5d.jpg" alt="close-up-photo-of-rice-plains-2589457s"></p>
<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<p>本阶段主要针对C++<code>&lt;mark&gt;面向对象&lt;/mark&gt;</code>编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<span id="more"></span>

<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​	在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​	<strong>代码区：</strong></p>
<p>​		存放 CPU 执行的机器指令</p>
<p>​		代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​		代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​	<strong>全局区：</strong></p>
<p>​		全局变量和静态变量存放在此.</p>
<p>​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​		&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545017602518.png"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​	<strong>栈区：</strong></p>
<p>​		由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>​	<strong>堆区：</strong></p>
<p>​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​		在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​	C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p>
<p>​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p>
<p>​	语法：<code> new 数据类型</code></p>
<p>​	利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>​	</p>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p>
<p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​	人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​	车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​	具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​	在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545533548532.png"></p>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545533829184.png"></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在&#x3D;&#x3D;堆区&#x3D;&#x3D;重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-3-2"><a href="#4-3-2" class="headerlink" title="4.3.2"></a>4.3.2</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1544861202252.png"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image0020.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545881904150.png"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545882158050.png"></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/clip_image002.jpg"></p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</li>
<li>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1545985945198.png"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​	3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
<p>本文转载于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<p align="right">
    🚀 <a href="#C++核心编程" target="_blank">回到顶部</a> 
</p>







<p align="right">
    🏡 <a href="https://upwon.github.io/" target="_self">回到首页</a> 
</p>


]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>转载</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第35期</title>
    <url>/posts/14475.html</url>
    <content><![CDATA[<p>欢迎阅读第35期技术资讯！欢迎阅读本期技术资讯！本期在工具推荐方面，我们发现了SuperDrag这款智能浏览器鼠标拖拽扩展，它能根据不同的拖拽内容执行相应操作，如打开链接、保存图片或搜索文本。Surfingkeys则为Chrome和Firefox用户提供了类似Vim的键盘快捷键操作方式，极大提升了浏览效率。RSSHub Radar和RSS+两个工具简化了RSS订阅源的发现和订阅过程，而Mihon作为一款Android端的免费开源漫画阅读器，支持丰富的图源扩展。在Python包管理方面，我们介绍了uv，这是一个用Rust编写的快速安装程序和解析器，旨在替代pip。此外，我们还分享了中国法律快查手册和Z-Library桌面端下载信息，以及基于Kimi Chat的AI渐进式阅读法，帮助读者高效处理大量阅读材料。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403241911541.jpg" alt="封面图 西湖三月·2024"></p>
<span id="more"></span>



<br />

<p>欢迎来到第35期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/EKKsnbRKqeowf7koDlN_EA">Flutter 项目架构技术指南  </a>:  文章详细探讨了Flutter项目中代码组织架构的关键方面，提供了设计原则SOLID、Clean Architecture架构模式，以及MVC、MVP、MVVM架构模式的介绍和建议。SOLID原则包括单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，有助于提高代码质量、可维护性和可扩展性。Clean Architecture通过将应用程序分解为实体层、数据层、领域层和表示层，实现了代码的可维护性、可测试性和可扩展性。文章还介绍了MVC、MVP、MVVM三种常见的架构模式，每种模式都有其特点和适用场景。此外，文章推荐了一些优秀的Flutter插件，如freezed、get_it和Equatable，并提供了状态管理的相关信息。最后，文章提供了一系列的Flutter学习路径资源，供读者进一步学习和实践。</p>
</li>
<li><p><a href="https://juejin.cn/post/7348363812949278759">Android OutOfMemoryError原理解析</a>：文章深入分析了Android应用中OutOfMemoryError（OOM）的原因，探讨了不同情况下OOM的发生机制，并提供了内存优化的思路和黑科技方案，通过inlinehook修改LargeObjectSpace的计数，理论上可以增加可用堆内存。</p>
</li>
<li><p><a href="https://juejin.cn/post/7348320601997672487">Compose编程思想 – Compose中重组风险和优化 </a>：文章深入探讨了Compose框架中的重组机制，包括重组的风险、优化策略，以及如何正确使用<code>remember</code>和<code>derivedStateOf</code>来管理状态，同时对<code>CompositionLocal</code>的使用提出了建议。</p>
</li>
<li><p><a href="https://juejin.cn/post/7341720847880798235">这是一篇DeepLink入门指南 </a> ：文章首先定义了DeepLink为能够将用户直接导航到应用中特定部分的URI。作者解释了DeepLink在移动互联时代的重要性，尤其是在App间引流和用户增长方面。文章接着介绍了DeepLink的几种形式，包括URL Scheme、App Links、Universal Links、H5链接和Deferred Deeplink，每种形式都有其特点和适用场景。URL Scheme允许应用响应其他应用的唤起，但无法处理未安装的场景；App Links和Universal Links解决了未安装App时的跳转问题，但Android中的App Links受限于其他应用的处理；H5链接提供了灵活的策略，但增加了网页环节；Deferred Deeplink则是对未安装场景的增强，能够在安装后复原应用场景。最后，文章提供了在Android中实现DeepLink的基本步骤，包括在AndroidManifest中添加Intent过滤器、读取Intent传递的数据和使用ADB测试DeepLink。</p>
</li>
<li><p><a href="https://juejin.cn/post/7341840038964477971">2024年Android项目开发模板开源与相关介绍 </a>：文章详细介绍了一个Android项目开发模板，该模板基于Gradle 8.0+和最新的Android SDK版本构建，使用了Kotlin语言和流行的组件化与路由方案。模板中使用了Hilt进行依赖注入，以解耦各个组件，同时采用了MVI和UserCase的架构模式来开发页面。UI布局基于XML，并使用ViewBinding与MVI架构相结合。文章还讨论了如何通过buildSrc和gradle.kts进行依赖版本管理，以及如何通过自定义Plugin来简化组件配置。此外，文章还提供了源码链接，供读者参考和学习。</p>
<br />

<br /></li>
</ul>
<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="浏览器鼠标超级拖拽扩展-SuperDrag"><a href="#浏览器鼠标超级拖拽扩展-SuperDrag" class="headerlink" title="浏览器鼠标超级拖拽扩展: SuperDrag"></a>浏览器鼠标超级拖拽扩展: SuperDrag</h2><p>SuperDrag是一款功能简洁的鼠标超级拖拽扩展程序，可以智能识别场景和拖拽内容。具体来说，当拖拽的是链接时，它会在新标签页中打开；当拖拽的是图片时，它会自动保存到默认的下载路径；当拖拽的是文本时，它会识别为关键字并进行搜索。拓展后执行的操作都是可以配置的。</p>
<p>扩展的主要特性：</p>
<ul>
<li>支持按键取消和自动取消操作；</li>
<li>支持方向可选：四面八方、上下、左右。四面八方可选斜向和正向</li>
<li>允许拖拽类型：文字、链接、图片；</li>
<li>文本支持搜索和复制；</li>
<li>文本搜索支持四面八方分别设置前台或后台；</li>
<li>文本搜索预置搜索常用引擎，可自定义；</li>
<li>链接支持打开、复制链接URL、复制链接文本、搜索链接文本；</li>
<li>链接打开方式支持四面八方分别设置前台或后台；</li>
<li>搜索链接文本可选择预置搜索引擎，可自定义。</li>
<li>图片支持打开图片指向网站、打开图片、复制图片、复制图片链接、下载图片、以图搜图；</li>
<li>图片打开方式支持四面八方分别设置前台或后台；</li>
<li>以图搜图可选择预置搜索引擎，可自定义。</li>
</ul>
<p><img data-src="https://s2.loli.net/2024/02/25/fWu64OocILkdnpD.png"></p>
<p>开源地址：<a href="https://github.com/zzm-note/SuperDrag">https://github.com/zzm-note/SuperDrag</a></p>
<p>安装地址 Edge商店：<a href="https://microsoftedge.microsoft.com/addons/detail/nlefalggllbckbaegjonehiokkddgcbn">https://microsoftedge.microsoft.com/addons/detail/nlefalggllbckbaegjonehiokkddgcbn</a></p>
<p>安装地址 Chrome商店：<a href="https://chrome.google.com/webstore/detail/superdrag/nmnjeedgpnieleiebjaabgaaeccnddbf">https://chrome.google.com/webstore/detail/superdrag/nmnjeedgpnieleiebjaabgaaeccnddbf</a></p>
<br />

<h2 id="Surfingkeys-–-用快捷键高效操作浏览器"><a href="#Surfingkeys-–-用快捷键高效操作浏览器" class="headerlink" title="Surfingkeys – 用快捷键高效操作浏览器"></a>Surfingkeys – 用快捷键高效操作浏览器</h2><p>Surfingkeys 是一个 Chrome 和 Firefox 浏览器的扩展，它为用户提供了类似 Vim 的键盘快捷键操作方式，以提高浏览网页和浏览器操作的效率。用户可以使用键盘快捷键来导航、打开链接、搜索等等，而无需使用鼠标。Surfingkeys 还支持自定义配置和脚本扩展，使用户能够根据自己的需求来定制其功能。</p>
<p>Surfingkeys有三种模式：normal，visual和insert。标准模式是 Vim 中的默认模式。大部分操作都需要在标准模式下完成。在 Surfingkeys 中也是如此，在标准模式下可以通过 j&#x2F;k 或者 d&#x2F;u 上下滚动，通过h&#x2F;l 来左右滚动。当然常用的 gg&#x2F;G 这种操作也都支持。完整的快捷键列表如下（可通过 ? 呼出）。</p>
<p>在标准模式下，可以通过 f 来打开超链接，用 F 来在新标签页后台打开。按下 f 后，会在超链接处展示提示符。详细实用教程推荐阅读：<a href="https://sspai.com/post/63692">Surfingkeys 实用向推荐</a>。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403042334477.png"></p>
<p>开源地址：<a href="https://github.com/brookhong/Surfingkeys">https://github.com/brookhong/Surfingkeys</a></p>
<p>安装地址：</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/surfingkeys/gfbliohnnapiefjpjlpjnehglfpaknnc">Surfingkeys - Chrome 网上应用店</a></li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/surfingkeys_ff/">Surfingkeys – Get this Extension for 🦊 Firefox</a></li>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/kgnghhfkloifoabeaobjkgagcecbnppg">Surfingkeys - Microsoft Edge Addons</a></li>
<li><a href="https://apps.apple.com/us/app/surfingkeys/id1609752330">Surfingkeys on the Mac App Store</a></li>
</ul>
<br />

<h2 id="RSSHub-Radar-浏览器扩展"><a href="#RSSHub-Radar-浏览器扩展" class="headerlink" title="RSSHub Radar 浏览器扩展"></a>RSSHub Radar 浏览器扩展</h2><p>RSSHub Radar是一个浏览器扩展，它简化了发现和订阅当前页面相关的RSS和RSSHub订阅源的过程。</p>
<p>特性：</p>
<ul>
<li><strong>发现和订阅RSS：</strong> 用户可以轻松发现和订阅当前页面相关的RSS订阅源。</li>
<li><strong>探索RSSHub：</strong> 快速探索并订阅当前页面支持的RSSHub。</li>
<li><strong>识别支持的RSSHub：</strong> 快速识别当前网站支持的RSSHub。</li>
<li><strong>一键RSS订阅：</strong> 支持一键订阅到多个平台，如Tiny Tiny RSS, Miniflux, FreshRSS, Feedly, Inoreader, Feedbin, The Old Reader, Feeds.Pub, Local Reader等。</li>
<li><strong>兼容性：</strong> 已测试并确认与Chrome、Edge和Firefox浏览器兼容，其他基于Chromium的浏览器也应该可以运行。</li>
</ul>
<p>支持以下浏览器，点击下载</p>
<table>
<thead>
<tr>
<th><a href="https://chrome.google.com/webstore/detail/kefjpfngnndepjbopdmoebkipbgkggaa"><img data-src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_128x128.png" width="48" /></a></th>
<th><a href="https://microsoftedge.microsoft.com/addons/detail/gangkeiaobmjcjokiofpkfpcobpbmnln"><img data-src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_128x128.png" width="48" /></a></th>
<th><a href="https://addons.mozilla.org/zh-CN/firefox/addon/rsshub-radar/"><img data-src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_128x128.png" width="48" /></a></th>
<th><a href="https://apps.apple.com/us/app/rsshub-radar/id1610744717?l=zh&mt=12"><img data-src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_128x128.png" width="48" /></a></th>
<th><a href="https://chrome.google.com/webstore/detail/kefjpfngnndepjbopdmoebkipbgkggaa"><img data-src="https://i.imgur.com/ofOUkIB.png" width="48" /></a></th>
<th><a href="https://chrome.google.com/webstore/detail/kefjpfngnndepjbopdmoebkipbgkggaa"><img data-src="https://i.imgur.com/9RH7UNb.png" width="48" /></a></th>
<th><a href="https://chrome.google.com/webstore/detail/kefjpfngnndepjbopdmoebkipbgkggaa"><img data-src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/vivaldi/vivaldi_128x128.png" width="48" /></a></th>
</tr>
</thead>
</table>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403202352344.png"></p>
<p>开源地址：<a href="https://github.com/DIYgod/RSSHub-Radar">https://github.com/DIYgod/RSSHub-Radar</a></p>
<br />

<h2 id="RSS-显示当前网站所有的-RSS"><a href="#RSS-显示当前网站所有的-RSS" class="headerlink" title="RSS+ : 显示当前网站所有的 RSS"></a>RSS+ : 显示当前网站所有的 RSS</h2><p>RSS+ 是一个功能强大的用户脚本，它能够在用户访问任何网站时，自动查找并显示该网站的所有RSS订阅源。这个脚本特别适合那些希望快速找到并订阅网站更新的用户。脚本的特点是简单易用，只需安装后，访问任何网站，RSS+ 就会自动检测并列出可用的RSS源。</p>
<p>脚本支持的RSS平台包括但不限于：小红书、微博、贴吧、知乎、雪球、起点、斗鱼、BiliBili、CSDN、v2ex、草榴、Instagram、Twitter、YouTube、GitHub、Reddit、Medium、Dribbble等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403202354390.png"></p>
<p>安装地址：<a href="https://greasyfork.org/zh-CN/scripts/373252-rss-show-site-all-rss">https://greasyfork.org/zh-CN/scripts/373252-rss-show-site-all-rss</a></p>
<br />

<h2 id="适用于-Android-的免费开源漫画阅读器-Mihon"><a href="#适用于-Android-的免费开源漫画阅读器-Mihon" class="headerlink" title="适用于 Android 的免费开源漫画阅读器 Mihon"></a>适用于 Android 的免费开源漫画阅读器 Mihon</h2><p><strong>Mihon</strong> 是一款安卓端的<strong>免费、开源漫画阅读器</strong>，支持漫画在线阅读与下载。</p>
<p>它支持安装各种**图源扩展**插件****，每个图源都是一个漫画资源网站。</p>
<p>资源极其丰富，包含中文、英文、日文等多种语言图源，我们可以自由选择安装。</p>
<p>特性：</p>
<ul>
<li>本地阅读内容。</li>
<li>具有多个查看器、阅读方向和其他设置的可配置阅读器。</li>
<li>浅色和深色主题。</li>
<li>在本地创建备份以离线读取或存储到您所需的云服务。</li>
</ul>
<p>详细使用方法可以查看 <a href="https://mp.weixin.qq.com/s?__biz=MzU4MjE3MTE4MQ==&mid=2247503782&idx=1&sn=103bf58a4ff518596b0240e575f6cc63&scene=58&subscene=0">免费漫画神器 Tachiyomi 最佳替代 Mihon 下载与使用教程 </a></p>
<p>开源地址：<a href="https://github.com/mihonapp/mihon">https://github.com/mihonapp/mihon</a></p>
<br />

<h2 id="一个非常快的-Python-包安装程序和解析器：uv"><a href="#一个非常快的-Python-包安装程序和解析器：uv" class="headerlink" title="一个非常快的 Python 包安装程序和解析器：uv"></a>一个非常快的 Python 包安装程序和解析器：<a href="https://github.com/astral-sh/uv">uv</a></h2><p>一个非常快的 Python 包安装程序和解析器，用 Rust 编写。设计为 <code>pip</code> 和 <code>pip-compile</code> 的直接替代品。</p>
<p>特性：</p>
<ul>
<li><p>⚖️ 常见 <code>pip</code> 、 <code>pip-tools</code> 和 <code>virtualenv</code> 命令的直接替换。</p>
</li>
<li><p>⚡️ 比 <code>pip</code> 和 <code>pip-tools</code> （ <code>pip-compile</code> 和 <code>pip-sync</code> ）快 10-100 倍。</p>
</li>
<li><p>💾 磁盘空间效率高，具有用于重复数据删除的全局缓存。</p>
</li>
<li><p>🐍  可通过 <code>curl</code> 、 <code>pip</code> 、 <code>pipx</code> 等安装。 uv 是一个静态二进制文件，无需 Rust 或 Python 即可安装。</p>
</li>
<li><p>🧪  针对前 10,000 个 PyPI 包进行了大规模测试。</p>
</li>
<li><p>🖥️ 支持 macOS、Linux 和 Windows。</p>
</li>
<li><p>🧰 高级功能，例如依赖版本覆盖和替代解决策略。</p>
</li>
<li><p>⁉️  具有冲突跟踪解析器的一流错误消息。</p>
</li>
<li><p>🤝 支持各种高级 <code>pip</code> 功能，包括可编辑安装、Git 依赖项、直接 URL 依赖项、本地依赖项、约束、源代码分发、HTML 和 JSON 索引等。</p>
</li>
</ul>
<p>开源地址：<a href="https://github.com/astral-sh/uv">https://github.com/astral-sh/uv</a></p>
<br />

<h2 id="LLaMA-Factory：-高效微调大模型"><a href="#LLaMA-Factory：-高效微调大模型" class="headerlink" title="LLaMA-Factory： 高效微调大模型"></a>LLaMA-Factory： 高效微调大模型</h2><p>LLaMA-Factory项目提供了一个统一的平台，用于微调大型语言模型。它支持多种模型，如LLaMA、Mistral、Mixtral-MoE等，并集成了多种训练方法，包括全参数微调、冻结微调、LoRA、QLoRA、预训练、有监督微调、奖励建模、PPO和DPO训练。项目还提供了多种数据集，以便于用户进行训练和评估。此外，LLaMA-Factory支持OpenAI风格的API，使得模型推理更加快速和便捷。项目的GitHub页面提供了详细的使用说明、基准测试结果、支持的模型列表、训练方法、提供的数据集、系统要求以及如何开始的指南。此外，项目还提供了一个Web UI，用于训练、评估和推理。</p>
<p>开源地址：<a href="https://github.com/hiyouga/LLaMA-Factory">https://github.com/hiyouga/LLaMA-Factory</a> </p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="中国法律快查手册"><a href="#中国法律快查手册" class="headerlink" title="中国法律快查手册"></a>中国法律快查手册</h2><p>在线速查法律条文。</p>
<ul>
<li><p>法律: 419 部 </p>
</li>
<li><p>司法解释: 392 部</p>
</li>
<li><p>行政法规: 628 部</p>
</li>
<li><p>地方性法规</p>
<ul>
<li>重庆: 103 部</li>
<li>浙江: 410 部</li>
<li>河南: 418 部</li>
<li>广东: 88 部</li>
<li>山东: 472 部</li>
<li>北京: 165 部</li>
<li>上海: 206 部</li>
</ul>
</li>
<li><p>部门规章</p>
<ul>
<li>市场监督管理总局: 17 部</li>
<li>国家安全部: 1 部</li>
<li>公安部: 9 部</li>
<li>人力资源社会保障部: 2 部</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403062343650.png"></p>
</li>
</ul>
<p>在线地址：<a href="https://lawrefbook.github.io/">https://lawrefbook.github.io/</a></p>
<br />

<h2 id="Z-Library桌面端下载"><a href="#Z-Library桌面端下载" class="headerlink" title="Z-Library桌面端下载"></a>Z-Library桌面端下载</h2><p>Z-Library桌面应用程序的alpha版本。忘记需要搜索可以访问网站的工作链接，因为我们的应用程序会为您做所有的事情。此外，该应用程序在TOR网络之上运行，提供对图书馆的稳定访问，并保证观看的匿名性和私密性。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403052314770.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403052321623.png"></p>
<p>下载地址：<a href="https://zh.zlibrary-access.se/">https://zh.zlibrary-access.se/</a></p>
<p><strong>有用的链接 Z-Library的官方链接</strong></p>
<p>Web <a href="https://singlelogin.se/">https://singlelogin.se</a></p>
<p>TOR <a href="http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion/">http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion
  </a></p>
<br />

<h2 id="基于-Kimi-Chat-的-AI-渐进式阅读法-少数派"><a href="#基于-Kimi-Chat-的-AI-渐进式阅读法-少数派" class="headerlink" title="基于 Kimi Chat 的 AI 渐进式阅读法 - 少数派 "></a><a href="https://sspai.com/post/87116">基于 Kimi Chat 的 AI 渐进式阅读法 - 少数派 </a></h2><p>以下内容由 AI 生成：</p>
<p><strong>文章内容概述：</strong></p>
<ul>
<li><strong>标题：</strong> 基于 Kimi Chat 的 AI 渐进式阅读法 - 少数派</li>
<li><strong>作者：</strong> 潦草学者</li>
<li><strong>标签：</strong> [阅读]</li>
</ul>
<p><strong>一句话总结：</strong> 文章介绍了一种利用Kimi Chat AI进行高效阅读的方法，称为“渐进式阅读法”，通过AI辅助提取文章信息、总结内容和深入理解，以提高处理大量阅读材料的效率。</p>
<p><strong>详细内容摘要：</strong></p>
<p>文章作者潦草学者分享了他如何使用Kimi Chat AI来处理每天大量的阅读材料。他提出了一种名为“渐进式阅读法”的方法，该方法分为三个步骤：</p>
<ol>
<li><strong>了解文章</strong>：使用Kimi Chat AI提取文章的元数据（标题、作者、标签），一句话总结文章，并详细列举文章大纲。</li>
<li><strong>详读内容</strong>：在第一步的基础上，让AI详细总结文章每一部分的内容，总结文章结论，并列举阅读文章可以学到的知识。</li>
<li><strong>个性化进阶阅读</strong>：根据个人需要，向AI发出指令进行更深入的阅读，如追问不懂的问题、解释专有名词、简化复杂概念等。</li>
</ol>
<p>作者还提到了AI阅读的缺点，包括AI可能会误判内容的重要性、存在幻觉问题，以及在处理非结构化信息时效果较差。尽管如此，作者认为随着技术的进步，这些问题有望得到解决。</p>
<p>最后，作者强调AI无法完全取代人的思考，AI只能辅助阅读，而真正的理解和思考还需要读者亲自进行。</p>
<p><strong>详细大纲：</strong></p>
<ol>
<li><p><strong>引言</strong></p>
<ul>
<li>作者面临的阅读材料过多的问题。</li>
<li>作者如何将待读文章视为一个“图书馆”。</li>
</ul>
</li>
<li><p><strong>文章阅读步骤</strong></p>
<ul>
<li>传统的阅读步骤。</li>
<li>AI如何提高阅读效率。</li>
</ul>
</li>
<li><p><strong>渐进式阅读法</strong></p>
<ul>
<li>选择Kimi Chat AI作为工具。</li>
<li>第一步：了解文章。</li>
<li>第二步：详读内容。</li>
<li>第三步：个性化进阶阅读。</li>
</ul>
</li>
<li><p><strong>搭配输入法快捷输入</strong></p>
<ul>
<li>如何使用输入法自定义短语来快速输入阅读指令。</li>
</ul>
</li>
<li><p><strong>AI阅读的缺点</strong></p>
<ul>
<li>AI在阅读过程中的局限性。</li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>回顾“渐进式阅读法”的步骤。</li>
<li>AI作为阅读辅助工具的定位。</li>
</ul>
</li>
<li><p><strong>结束语</strong></p>
<ul>
<li>AI无法取代个人思考的重要性。</li>
</ul>
</li>
</ol>
<p>原文地址：<a href="https://sspai.com/post/87116">https://sspai.com/post/87116</a></p>
<p><br /><br /></p>
<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://www.36kr.com/p/2698867645315207">黄仁勋对话 Transformer 八子：大模型的起源、现在和未来-36氪  </a>： 文章记录了英伟达创始人黄仁勋与Transformer模型提出者们的对话，探讨了大模型的发展历程、当前状态和未来趋势，以及这些模型对AI领域的深远影响。</p>
</li>
<li><p><a href="https://www.huxiu.com/article/2812548.html">腾讯一年净赚1557亿，马化腾依旧不满意-虎嗅网 </a>： 文章讨论了腾讯控股2023年的财务表现，尽管公司全年净利润大幅增长，但马化腾对公司的表现仍有所不满，特别是在游戏业务和AI技术发展方面。</p>
</li>
<li><p><a href="https://www.huxiu.com/article/2812557.html">中国睡眠研究报告2024</a>：《中国睡眠研究报告2024》指出，互联网数字工作者的睡眠时长普遍较短，手机成瘾深度影响睡眠质量，而提高睡眠质量需要降低手机成瘾程度。</p>
</li>
<li><p><a href="https://www.36kr.com/p/2695094513749890">2024年消费的40条新认知</a>：文章提供了对当前消费行业的深刻洞察，包括消费现象、大消费趋势、品牌建设、消费机遇等多个方面的新认知，旨在帮助读者发现消费领域的新机会。一些消费现象包括库迪难以打败瑞幸、茶饮市场的竞争、钟薛高的失败原因、农夫山泉事件的影响、拼多多的商业模式等。大消费趋势中提到消费进入质价比时代、消费分层背后的生意模式分层、消费投资人的投资态度等。</p>
</li>
<li><p><a href="https://aijishu.com/a/1060000000455705">马斯克实现承诺，开源Grok-1！3140亿参数迄今最大，远高于ChatGPT 3.5! - 极术社区 </a></p>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于    <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>4-基于多态的企业职工系统</title>
    <url>/posts/42855.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200529142602.jpg"></p>
<center><font size=1>from pexels </center>

<p>本教程主要利用C++来实现一个基于多态的职工管理系统，通过这个简单的例子来了解多态的思想。😁</p>
<p>本文来源于：<a href="http://yun.itheima.com/course/520.html?bili">黑马程序员</a></p>
<p>对应视频地址为：<a href="https://www.bilibili.com/video/av41559729/?p=1">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></p>
<span id="more"></span>



<h1 id="职工管理系统"><a href="#职工管理系统" class="headerlink" title="职工管理系统"></a>职工管理系统</h1><h2 id="1、管理系统需求"><a href="#1、管理系统需求" class="headerlink" title="1、管理系统需求"></a>1、管理系统需求</h2><p>职工管理系统可以用来管理公司内所有员工的信息</p>
<p>本教程主要利用C++来实现一个基于多态的职工管理系统</p>
<p>公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责</p>
<p>普通员工职责：完成经理交给的任务</p>
<p>经理职责：完成老板交给的任务，并下发任务给员工</p>
<p>老板职责：管理公司所有事务</p>
<p>管理系统中需要实现的功能如下：</p>
<ul>
<li>退出管理程序：退出当前管理系统</li>
</ul>
<ul>
<li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li>
<li>显示职工信息：显示公司内部所有职工的信息</li>
<li>删除离职职工：按照编号删除指定的职工</li>
<li>修改职工信息：按照编号修改职工个人信息</li>
<li>查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息</li>
<li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li>
<li>清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删）</li>
</ul>
<p>系统界面效果图如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546511409198.png" alt="1546511409198"></p>
<p>需根据用户不同的选择，完成不同的功能！</p>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>打开vs2017后，点击创建新项目，创建新的C++项目</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1544151201465.png" alt="1544151201465"></p>
<p>填写项目名称以及项目路径，点击确定</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546349209805.png" alt="1546349209805"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><p>右键源文件，进行添加文件操作</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546349360960.png" alt="1546349360960"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546349421496.png" alt="1546349421496"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546349488752.png" alt="1546349488752"></p>
<p>至此，项目已创建完毕</p>
<h2 id="3、创建管理类"><a href="#3、创建管理类" class="headerlink" title="3、创建管理类"></a>3、创建管理类</h2><p>​	管理类负责的内容如下：</p>
<ul>
<li>与用户的沟通菜单界面</li>
<li>对职工增删改查的操作</li>
<li>与文件的读写交互</li>
</ul>
<h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><p>在头文件和源文件的文件夹下分别创建workerManager.h 和 workerManager.cpp文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546349904944.png" alt="1546349904944"></p>
<h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在workerManager.h中设计管理类</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">WorkerManager</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">WorkerManager</span>();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在workerManager.cpp中将构造和析构函数空实现补全</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerManager::~<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>至此职工管理类以创建完毕</p>
<h2 id="4、菜单功能"><a href="#4、菜单功能" class="headerlink" title="4、菜单功能"></a>4、菜单功能</h2><p>功能描述：与用户的沟通界面</p>
<h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类workerManager.h中添加成员函数  <code>void Show_Menu();</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546351543942.png" alt="1546351543942"></p>
<h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><p>在管理类workerManager.cpp中实现  Show_Menu()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*********  欢迎使用职工管理系统！ **********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  0.退出管理程序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  1.增加职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  2.显示职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  3.删除离职职工  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  4.修改职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  5.查找职工信息  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  6.按照编号排序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*************  7.清空所有文档  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><p>在职工管理系统.cpp中测试菜单功能</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	WorkerManager wm;</span><br><span class="line"></span><br><span class="line">	wm.<span class="built_in">Show_Menu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546352771191.png" alt="1546352771191"></p>
<h2 id="5、退出功能"><a href="#5、退出功能" class="headerlink" title="5、退出功能"></a>5、退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><p>在main函数中提供分支选择，提供每个功能接口</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	WorkerManager wm;</span><br><span class="line">	<span class="type">int</span> choice = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//展示菜单</span></span><br><span class="line">		wm.<span class="built_in">Show_Menu</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入您的选择:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (choice)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//退出系统</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//添加职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//显示职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//删除职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//修改职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: <span class="comment">//查找职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//排序职工</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: <span class="comment">//清空文件</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在workerManager.h中提供退出系统的成员函数 <code>	void exitSystem();</code></p>
<p>在workerManager.cpp中提供具体的功能实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546353199424.png" alt="1546353199424"></p>
<p>运行测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520143459-2.png"></p>
<h2 id="6、创建职工类"><a href="#6、创建职工类" class="headerlink" title="6、创建职工类"></a>6、创建职工类</h2><h3 id="6-1-创建职工抽象类"><a href="#6-1-创建职工抽象类" class="headerlink" title="6.1 创建职工抽象类"></a>6.1 创建职工抽象类</h3><p>职工的分类为：普通员工、经理、老板</p>
<p>将三种职工抽象到一个类（worker）中,利用多态管理不同职工种类</p>
<p>职工的属性为：职工编号、职工姓名、职工所在部门编号</p>
<p>职工的行为为：岗位职责信息描述，获取岗位名称</p>
<p>头文件文件夹下  创建文件worker.h  文件并且添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职工抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Id; <span class="comment">//职工编号</span></span><br><span class="line">	string m_Name; <span class="comment">//职工姓名</span></span><br><span class="line">	<span class="type">int</span> m_DeptId; <span class="comment">//职工所在部门名称编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-2-创建普通员工类"><a href="#6-2-创建普通员工类" class="headerlink" title="6.2 创建普通员工类"></a>6.2 创建普通员工类</h3><p>普通员工类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数</p>
<p>在头文件和源文件的文件夹下分别创建employee.h 和 employee.cpp文件</p>
<p>employee.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> :<span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Employee</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>employee.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;employee.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Employee::<span class="built_in">Employee</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Employee::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：完成经理交给的任务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Employee::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="6-3-创建经理类"><a href="#6-3-创建经理类" class="headerlink" title="6.3 创建经理类"></a>6.3 创建经理类</h3><p>经理类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p>
<p>在头文件和源文件的文件夹下分别创建manager.h 和 manager.cpp文件</p>
<p>manager.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//经理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> :<span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Manager</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>manager.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Manager::<span class="built_in">Manager</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：完成老板交给的任务,并下发任务给员工&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Manager::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;经理&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-4-创建老板类"><a href="#6-4-创建老板类" class="headerlink" title="6.4 创建老板类"></a>6.4 创建老板类</h3><p>老板类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p>
<p>在头文件和源文件的文件夹下分别创建boss.h 和 boss.cpp文件</p>
<p>boss.h中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//老板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> :<span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Boss</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示个人信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取职工岗位名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>boss.cpp中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Boss::<span class="built_in">Boss</span>(<span class="type">int</span> id, string name, <span class="type">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Boss::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; \t岗位职责：管理公司所有事务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Boss::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;总裁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="6-5-测试多态"><a href="#6-5-测试多态" class="headerlink" title="6.5 测试多态"></a>6.5 测试多态</h3><p>在职工管理系统.cpp中添加测试函数，并且运行能够产生多态</p>
<p>测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;employee.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line">	</span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line"></span><br><span class="line">	worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">3</span>);</span><br><span class="line">	worker-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="keyword">delete</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546398236081.png" alt="1546398236081"></p>
<p>测试成功后，测试代码可以注释保留，或者选择删除</p>
<h2 id="7、添加职工"><a href="#7、添加职工" class="headerlink" title="7、添加职工"></a>7、添加职工</h2><p>功能描述：批量添加职工，并且保存到文件中</p>
<h3 id="7-1-功能分析"><a href="#7-1-功能分析" class="headerlink" title="7.1 功能分析"></a>7.1 功能分析</h3><p>分析：</p>
<p>用户在批量创建时，可能会创建不同种类的职工</p>
<p>如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里</p>
<p>如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **的指针维护</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546399491099.png" alt="1546399491099"></p>
<h3 id="7-2-功能实现"><a href="#7-2-功能实现" class="headerlink" title="7.2 功能实现"></a>7.2 功能实现</h3><p>在WokerManager.h头文件中添加成员属性 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录文件中的人数个数</span></span><br><span class="line"><span class="type">int</span> m_EmpNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工数组的指针</span></span><br><span class="line">Worker ** m_EmpArray;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager构造函数中初始化属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化人数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化数组指针</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在workerManager.h中添加成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p>workerManager.cpp中实现该函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Add_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入增加职工数量： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> addNum = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; addNum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addNum &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算新空间大小</span></span><br><span class="line">		<span class="type">int</span> newSize = <span class="keyword">this</span>-&gt;m_EmpNum + addNum;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//开辟新空间</span></span><br><span class="line">		Worker ** newSpace = <span class="keyword">new</span> Worker*[newSize];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将原空间下内容存放到新空间下</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				newSpace[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输入新数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> id;</span><br><span class="line">			string name;</span><br><span class="line">			<span class="type">int</span> dSelect;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请选择该职工的岗位：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">switch</span> (dSelect)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//普通员工</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//经理</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//老板</span></span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, <span class="number">3</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			newSpace[<span class="keyword">this</span>-&gt;m_EmpNum + i] = worker;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放原有空间</span></span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更改新空间的指向</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray = newSpace;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新新的个数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpNum = newSize;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//提示信息</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成功添加&quot;</span> &lt;&lt; addNum &lt;&lt; <span class="string">&quot;名新职工！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager.cpp的析构函数中，释放堆区数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::~<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="7-3-测试添加"><a href="#7-3-测试添加" class="headerlink" title="7.3 测试添加"></a>7.3 测试添加</h3><p>在main函数分支 1  选项中，调用添加职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546401705277.png" alt="1546401705277"></p>
<p>效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546401763461.png" alt="1546401763461"></p>
<p>至此，添加职工到程序中功能实现完毕</p>
<h2 id="8、文件交互-写文件"><a href="#8、文件交互-写文件" class="headerlink" title="8、文件交互 - 写文件"></a>8、文件交互 - 写文件</h2><p>功能描述：对文件进行读写</p>
<p>​	在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了</p>
<p>​	因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作</p>
<h3 id="8-1-设定文件路径"><a href="#8-1-设定文件路径" class="headerlink" title="8.1 设定文件路径"></a>8.1 设定文件路径</h3><p>首先我们将文件路径，在workerManager.h中添加宏常量,并且包含头文件 fstream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FILENAME <span class="string">&quot;empFile.txt&quot;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="8-2-成员函数声明"><a href="#8-2-成员函数声明" class="headerlink" title="8.2 成员函数声明"></a>8.2 成员函数声明</h3><p>在workerManager.h中类里添加成员函数 <code>void save()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="8-3-保存文件功能实现"><a href="#8-3-保存文件功能实现" class="headerlink" title="8.3 保存文件功能实现"></a>8.3 保存文件功能实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(FILENAME, ios::out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-4-保存文件功能测试"><a href="#8-4-保存文件功能测试" class="headerlink" title="8.4 保存文件功能测试"></a>8.4 保存文件功能测试</h3><p>在添加职工功能中添加成功后添加保存文件函数</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546432469465.png" alt="1546432469465"></p>
<p>再次运行代码，添加职工</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520143801-2.png"></p>
<p>同级目录下多出文件，并且保存了添加的信息</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546432343078.png" alt="1546432343078"></p>
<h2 id="9、文件交互-读文件"><a href="#9、文件交互-读文件" class="headerlink" title="9、文件交互 - 读文件"></a>9、文件交互 - 读文件</h2><p>功能描述：将文件中的内容读取到程序中</p>
<p>虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中</p>
<p>而我们的程序功能中还有清空文件的需求</p>
<p>因此构造函数初始化数据的情况分为三种</p>
<ol>
<li>第一次使用，文件未创建</li>
<li>文件存在，但是数据被用户清空</li>
<li>文件存在，并且保存职工的所有数据</li>
</ol>
<h3 id="9-1-文件未创建"><a href="#9-1-文件未创建" class="headerlink" title="9.1 文件未创建"></a>9.1 文件未创建</h3><p>在workerManager.h中添加新的成员属性 m_FileIsEmpty标志文件是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标志文件是否为空</span></span><br><span class="line"><span class="type">bool</span> m_FileIsEmpty;</span><br></pre></td></tr></table></figure>



<p>修改WorkerManager.cpp中构造函数代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WorkerManager::<span class="built_in">WorkerManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不存在情况</span></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; endl; <span class="comment">//测试输出</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;  <span class="comment">//初始化人数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>; <span class="comment">//初始化文件为空标志</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>; <span class="comment">//初始化数组</span></span><br><span class="line">		ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>删除文件后，测试文件不存在时初始化数据功能</p>
<h3 id="9-2-文件存在且数据为空"><a href="#9-2-文件存在且数据为空" class="headerlink" title="9.2 文件存在且数据为空"></a>9.2 文件存在且数据为空</h3><p>在workerManager.cpp中的构造函数追加代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件存在，并且没有记录</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ifs.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追加代码位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546435197575.png" alt="1546435197575"></p>
<p>将文件创建后清空文件内容，并测试该情况下初始化功能</p>
<p>我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？</p>
<p>成功添加职工后，应该更改文件不为空的标志</p>
<p>在<code>void WorkerManager::Add_Emp() </code>成员函数中添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新职工不为空标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546656256176.png" alt="1546656256176"></p>
<h3 id="9-3-文件存在且保存职工数据"><a href="#9-3-文件存在且保存职工数据" class="headerlink" title="9.3 文件存在且保存职工数据"></a>9.3 文件存在且保存职工数据</h3><h4 id="9-3-1-获取记录的职工人数"><a href="#9-3-1-获取记录的职工人数" class="headerlink" title="9.3.1 获取记录的职工人数"></a>9.3.1 获取记录的职工人数</h4><p>在workerManager.h中添加成员函数 <code> int get_EmpNum();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计人数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_EmpNum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>workerManager.cpp中实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WorkerManager::get_EmpNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> dId;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//记录人数</span></span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在workerManager.cpp构造函数中继续追加代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num =  <span class="keyword">this</span>-&gt;<span class="built_in">get_EmpNum</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;职工个数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;  <span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = num;  <span class="comment">//更新成员属性 </span></span><br></pre></td></tr></table></figure>



<p>手动添加一些职工数据，测试获取职工数量函数</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546436429055.png" alt="1546436429055"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546436385793.png" alt="1546436385793"></p>
<h4 id="9-3-2-初始化数组"><a href="#9-3-2-初始化数组" class="headerlink" title="9.3.2 初始化数组"></a>9.3.2 初始化数组</h4><p>根据职工的数据以及职工数据，初始化workerManager中的Worker ** m_EmpArray 指针</p>
<p>在WorkerManager.h中添加成员函数  <code>void init_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化员工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p>在WorkerManager.cpp中实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::init_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> dId;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//根据不同的部门Id创建不同对象</span></span><br><span class="line">		<span class="keyword">if</span> (dId == <span class="number">1</span>)  <span class="comment">// 1普通员工</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dId == <span class="number">2</span>) <span class="comment">//2经理</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//总裁</span></span><br><span class="line">		&#123;</span><br><span class="line">			worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, dId);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存放在数组中</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_EmpArray[index] = worker;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在workerManager.cpp构造函数中追加代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据职工数创建数组</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="keyword">new</span> Worker *[<span class="keyword">this</span>-&gt;m_EmpNum];</span><br><span class="line"><span class="comment">//初始化职工</span></span><br><span class="line"><span class="built_in">init_Emp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot; 职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot; 部门编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行程序，测试从文件中获取的数据</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546436938152.png" alt="1546436938152"></p>
<p>至此初始化数据功能完毕，测试代码可以注释或删除掉！</p>
<h2 id="10、显示职工"><a href="#10、显示职工" class="headerlink" title="10、显示职工"></a>10、显示职工</h2><p>功能描述：显示当前所有职工信息</p>
<h4 id="10-1-显示职工函数声明"><a href="#10-1-显示职工函数声明" class="headerlink" title="10.1 显示职工函数声明"></a>10.1 显示职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Show_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="10-2-显示职工函数实现"><a href="#10-2-显示职工函数实现" class="headerlink" title="10.2 显示职工函数实现"></a>10.2 显示职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>void Show_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Show_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//利用多态调用接口</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-3-测试显示职工"><a href="#10-3-测试显示职工" class="headerlink" title="10.3 测试显示职工"></a>10.3 测试显示职工</h4><p>在main函数分支 2  选项中，调用显示职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546497336465.png" alt="1546497336465"></p>
<p>测试时分别测试 文件为空和文件不为空两种情况</p>
<p>测试效果：</p>
<p>测试1-文件不存在或者为空情况</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546497082135.png" alt="1546497082135"></p>
<p>测试2 - 文件存在且有记录情况</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546496947671.png" alt="1546496947671"></p>
<p>测试完毕，至此，显示所有职工信息功能实现</p>
<h2 id="11、删除职工"><a href="#11、删除职工" class="headerlink" title="11、删除职工"></a>11、删除职工</h2><p>功能描述：按照职工的编号进行删除职工操作</p>
<h4 id="11-1-删除职工函数声明"><a href="#11-1-删除职工函数声明" class="headerlink" title="11.1 删除职工函数声明"></a>11.1 删除职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Del_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Del_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-2-职工是否存在函数声明"><a href="#11-2-职工是否存在函数声明" class="headerlink" title="11.2 职工是否存在函数声明"></a>11.2 职工是否存在函数声明</h4><p>很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工</p>
<p>因此添加该公告函数，以便后续调用</p>
<p>在workerManager.h中添加成员函数  <code>int IsExist(int id);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照职工编号判断职工是否存在,若存在返回职工在数组中位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsExist</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-职工是否存在函数实现"><a href="#11-3-职工是否存在函数实现" class="headerlink" title="11.3 职工是否存在函数实现"></a>11.3 职工是否存在函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>int IsExist(int id);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WorkerManager::IsExist</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id == id)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="11-4-删除职工函数实现"><a href="#11-4-删除职工函数实现" class="headerlink" title="11.4 删除职工函数实现"></a>11.4 删除职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Del_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Del_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//按职工编号删除</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入想要删除的职工号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> index = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist</span>(id);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (index != <span class="number">-1</span>)  <span class="comment">//说明index上位置数据需要删除</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum - <span class="number">1</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;m_EmpArray[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpNum--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">save</span>(); <span class="comment">//删除后数据同步到文件中</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;删除成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;删除失败，未找到该职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-5-测试删除职工"><a href="#11-5-测试删除职工" class="headerlink" title="11.5 测试删除职工"></a>11.5 测试删除职工</h4><p>在main函数分支 3  选项中，调用删除职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546502698622.png" alt="1546502698622"></p>
<p>测试1 - 删除不存在职工情况</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546500324196.png" alt="1546500324196"></p>
<p>测试2 - 删除存在的职工情况</p>
<p>删除成功提示图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546500350526.png" alt="1546500350526"></p>
<p>再次显示所有职工信息，确保已经删除</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546500361889.png" alt="1546500361889"></p>
<p>查看文件中信息，再次核实员工已被完全删除</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520144146.png"></p>
<p>至此，删除职工功能实现完毕！</p>
<h2 id="12、修改职工"><a href="#12、修改职工" class="headerlink" title="12、修改职工"></a>12、修改职工</h2><p>功能描述：能够按照职工的编号对职工信息进行修改并保存</p>
<h4 id="12-1-修改职工函数声明"><a href="#12-1-修改职工函数声明" class="headerlink" title="12.1 修改职工函数声明"></a>12.1 修改职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Mod_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mod_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-修改职工函数实现"><a href="#12-2-修改职工函数实现" class="headerlink" title="12.2 修改职工函数实现"></a>12.2 修改职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Mod_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Mod_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入修改职工的编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> id;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> ret = <span class="keyword">this</span>-&gt;<span class="built_in">IsExist</span>(id);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">//查找到编号的职工</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[ret];</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> newId = <span class="number">0</span>;</span><br><span class="line">			string newName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> dSelect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查到： &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;号职工，请输入新职工号： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; newId;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入新姓名： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; newName;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入岗位： &quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line">			Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">switch</span> (dSelect)</span><br><span class="line">			&#123;</span><br><span class="line">			case1:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Employee</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case2:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Manager</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				worker = <span class="keyword">new</span> <span class="built_in">Boss</span>(newId, newName, dSelect);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//更改数据 到数组中</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray[ret]= worker;</span><br><span class="line">			</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;修改成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//保存到文件中</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;修改失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按任意键 清屏</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="12-3-测试修改职工"><a href="#12-3-测试修改职工" class="headerlink" title="12.3 测试修改职工"></a>12.3 测试修改职工</h4><p>在main函数分支 4  选项中，调用修改职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546502651922.png" alt="1546502651922"></p>
<p>测试1 - 修改不存在职工情况</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520144244.png"></p>
<p>测试2 - 修改存在职工情况，例如将职工 “李四” 改为 “赵四”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520144304.png"></p>
<p>修改后再次查看所有职工信息，并确认修改成功</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546502865443.png" alt="1546502865443"></p>
<p>再次确认文件中信息也同步更新</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546502898653.png" alt="1546502898653"></p>
<p>至此，修改职工功能已实现！</p>
<h2 id="13、查找职工"><a href="#13、查找职工" class="headerlink" title="13、查找职工"></a>13、查找职工</h2><p>功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名</p>
<h4 id="13-1-查找职工函数声明"><a href="#13-1-查找职工函数声明" class="headerlink" title="13.1 查找职工函数声明"></a>13.1 查找职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Find_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="13-2-查找职工函数实现"><a href="#13-2-查找职工函数实现" class="headerlink" title="13.2 查找职工函数实现"></a>13.2 查找职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Find_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Find_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入查找的方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1、按职工编号查找&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2、按姓名查找&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//按职工号查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> id;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入查找的职工编号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">IsExist</span>(id);</span><br><span class="line">			<span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找成功！该职工信息如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">this</span>-&gt;m_EmpArray[ret]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(select == <span class="number">2</span>) <span class="comment">//按姓名查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			string name;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入查找的姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">			<span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//查找到的标志</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (m_EmpArray[i]-&gt;m_Name == name)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;查找成功,职工编号为：&quot;</span></span><br><span class="line">                           &lt;&lt; m_EmpArray[i]-&gt;m_Id</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; 号的信息如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">					</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//查无此人</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入选项有误&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="13-3-测试查找职工"><a href="#13-3-测试查找职工" class="headerlink" title="13.3 测试查找职工"></a>13.3 测试查找职工</h4><p>在main函数分支 5  选项中，调用查找职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546504714318.png" alt="1546504714318"></p>
<p>测试1 - 按照职工编号查找 - 查找不存在职工</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546504767229.png" alt="1546504767229"></p>
<p>测试2 - 按照职工编号查找 -  查找存在职工</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546505046521.png" alt="1546505046521"></p>
<p>测试3 - 按照职工姓名查找 - 查找不存在职工</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520144433.png"></p>
<p>测试4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工）</p>
<p>例如 添加两个王五的职工，然后按照姓名查找王五</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546507850441.png" alt="1546507850441"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546507760284.png" alt="1546507760284"></p>
<p>至此，查找职工功能实现完毕！</p>
<h2 id="14、排序"><a href="#14、排序" class="headerlink" title="14、排序"></a>14、排序</h2><p>功能描述：按照职工编号进行排序，排序的顺序由用户指定</p>
<h4 id="14-1-排序函数声明"><a href="#14-1-排序函数声明" class="headerlink" title="14.1 排序函数声明"></a>14.1 排序函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Sort_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="14-2-排序函数实现"><a href="#14-2-排序函数实现" class="headerlink" title="14.2 排序函数实现"></a>14.2 排序函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Sort_Emp();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Sort_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请选择排序方式： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1、按职工号进行升序&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2、按职工号进行降序&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> minOrMax = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; m_EmpNum; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//升序</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &gt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">					&#123;</span><br><span class="line">						minOrMax = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  <span class="comment">//降序</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &lt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">					&#123;</span><br><span class="line">						minOrMax = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i != minOrMax)</span><br><span class="line">			&#123;</span><br><span class="line">				Worker * temp = m_EmpArray[i];</span><br><span class="line">				m_EmpArray[i] = m_EmpArray[minOrMax];</span><br><span class="line">				m_EmpArray[minOrMax] = temp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;排序成功,排序后结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">save</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">Show_Emp</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="14-3-测试排序功能"><a href="#14-3-测试排序功能" class="headerlink" title="14.3 测试排序功能"></a>14.3 测试排序功能</h4><p>在main函数分支 6  选项中，调用排序职工接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546510145181.png" alt="1546510145181"></p>
<p>测试：</p>
<p>首先我们添加一些职工，序号是无序的，例如：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546658169987.png" alt="1546658169987"></p>
<p>测试 - 升序排序</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200520144530.png"></p>
<p>文件同步更新</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546658273581.png" alt="1546658273581"></p>
<p>测试 - 降序排序</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546658288936.png" alt="1546658288936"></p>
<p>文件同步更新</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546658313704.png" alt="1546658313704"></p>
<p>至此，职工按照编号排序的功能实现完毕！</p>
<h2 id="15、清空文件"><a href="#15、清空文件" class="headerlink" title="15、清空文件"></a>15、清空文件</h2><p>功能描述：将文件中记录数据清空</p>
<h4 id="15-1-清空函数声明"><a href="#15-1-清空函数声明" class="headerlink" title="15.1 清空函数声明"></a>15.1 清空函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Clean_File();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clean_File</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>





<h4 id="15-2-清空函数实现"><a href="#15-2-清空函数实现" class="headerlink" title="15.2 清空函数实现"></a>15.2 清空函数实现</h4><p>在workerManager.cpp中实现员函数 <code> void Clean_File();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerManager::Clean_File</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line">		<span class="function">ofstream <span class="title">ofs</span><span class="params">(FILENAME, ios::trunc)</span></span>;</span><br><span class="line">		ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i] != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="15-3-测试清空文件"><a href="#15-3-测试清空文件" class="headerlink" title="15.3 测试清空文件"></a>15.3 测试清空文件</h4><p>在main函数分支 7  选项中，调用清空文件接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546511085541.png" alt="1546511085541"></p>
<p>测试：确认清空文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546510976745.png" alt="1546510976745"></p>
<p>再次查看文件中数据，记录已为空</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546510994196.png" alt="1546510994196"></p>
<p>打开文件，里面数据已确保清空，该功能需要慎用！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1546511018517.png" alt="1546511018517"></p>
<p>随着清空文件功能实现，本案例制作完毕  ^ _ ^  </p>
<br />



<blockquote class="blockquote-center">
<p>人生乃是一面镜子，</p>
<p>从镜子里认识自己，</p>
<p>我要称之为头等大事，</p>
<p>也只是我们追求的目的！</p>

</blockquote>




]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>6-C++基于STL泛化编程的演讲比赛流程管理系统</title>
    <url>/posts/2237.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gf9ln4hm7fj22rw22x1ec.jpg"></p>
<span id="more"></span>



<p>换行</p>
<br />

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="1、-演讲比赛程序需求"><a href="#1、-演讲比赛程序需求" class="headerlink" title="1、 演讲比赛程序需求"></a>1、 演讲比赛程序需求</h2><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204052.png"></p>
<h3 id="1-1-比赛规则"><a href="#1-1-比赛规则" class="headerlink" title="1.1 比赛规则"></a>1.1 比赛规则</h3><ul>
<li>学校举行一场演讲比赛，共有<strong>12个人</strong>参加。<strong>比赛共两轮</strong>，第一轮为淘汰赛，第二轮为决赛。</li>
<li>比赛方式：<strong>分组比赛，每组6个人</strong>；选手每次要随机分组，进行比赛</li>
<li>每名选手都有对应的<strong>编号</strong>，如 10001 ~ 10012 </li>
<li>第一轮分为两个小组，每组6个人。 整体按照选手编号进行<strong>抽签</strong>后顺序演讲。</li>
<li>当小组演讲完后，淘汰组内排名最后的三个选手，<strong>前三名晋级</strong>，进入下一轮的比赛。</li>
<li>第二轮为决赛，<strong>前三名胜出</strong></li>
<li>每轮比赛过后需要<strong>显示晋级选手的信息</strong></li>
</ul>
<h3 id="1-2-程序功能"><a href="#1-2-程序功能" class="headerlink" title="1.2 程序功能"></a>1.2 程序功能</h3><ul>
<li>开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段</li>
<li>查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存</li>
<li>清空比赛记录：将文件中数据清空</li>
<li>退出比赛程序：可以退出当前程序</li>
</ul>
<h3 id="1-3-程序效果图："><a href="#1-3-程序效果图：" class="headerlink" title="1.3 程序效果图："></a>1.3 程序效果图：</h3><p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gf9ltmn6vxj20r70e8q2y.jpg" alt="1548155966702"></p>
<h2 id="2、-项目创建"><a href="#2、-项目创建" class="headerlink" title="2、 项目创建"></a>2、 项目创建</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul>
<li>打开vs2017后，点击创建新项目，创建新的C++项目</li>
</ul>
<p>如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204328.png"></p>
<ul>
<li>填写项目名称以及选取项目路径，点击确定生成项目</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204413.png"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul>
<li>右键源文件，进行添加文件操作</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204429.png"></p>
<ul>
<li>填写文件名称，点击添加</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529210045.png"></p>
<ul>
<li>生成文件成功，效果如下图</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204455.png"></p>
<ul>
<li>至此，项目已创建完毕</li>
</ul>
<h2 id="3、-创建管理类"><a href="#3、-创建管理类" class="headerlink" title="3、 创建管理类"></a>3、 创建管理类</h2><p><strong>功能描述：</strong></p>
<ul>
<li>提供菜单界面与用户交互</li>
<li>对演讲比赛流程进行控制</li>
<li>与文件的读写交互</li>
</ul>
<h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><ul>
<li>在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204509.png"></p>
<h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在speechManager.h中设计管理类</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演讲管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpeechManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">SpeechManager</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">SpeechManager</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在speechManager.cpp中将构造和析构函数空实现补全</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpeechManager::~<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>至此演讲管理类以创建完毕</li>
</ul>
<h2 id="4、-菜单功能"><a href="#4、-菜单功能" class="headerlink" title="4、 菜单功能"></a>4、 菜单功能</h2><p>功能描述：与用户的沟通界面</p>
<h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类speechManager.h中添加成员函数  <code>void show_Menu();</code></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204535.png"></p>
<h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><ul>
<li>在管理类speechManager.cpp中实现 show_Menu()函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************  欢迎参加演讲比赛 ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************  1.开始演讲比赛  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************  2.查看往届记录  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************  3.清空比赛记录  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*************  0.退出比赛程序  *************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><ul>
<li>在演讲比赛流程管理系统.cpp中测试菜单功能</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SpeechManager sm;</span><br><span class="line"></span><br><span class="line">    sm.<span class="built_in">show_Menu</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行效果如图：</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204607.png"></p>
<ul>
<li>菜单界面搭建完毕</li>
</ul>
<h2 id="5、-退出功能"><a href="#5、-退出功能" class="headerlink" title="5、 退出功能"></a>5、 退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><ul>
<li>在main函数中提供分支选择，提供每个功能接口</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SpeechManager sm;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choice = <span class="number">0</span>; <span class="comment">//用来存储用户的选项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sm.<span class="built_in">show_Menu</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入您的选择： &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; choice; <span class="comment">// 接受用户的选项</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//开始比赛</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//查看记录</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//清空记录</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>); <span class="comment">//清屏</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在speechManager.h中提供退出系统的成员函数 <code>void exitSystem();</code></p>
<p>在speechManager.cpp中提供具体的功能实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204631.png"></p>
<p>运行测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204710.png"></p>
<h2 id="6、演讲比赛功能"><a href="#6、演讲比赛功能" class="headerlink" title="6、演讲比赛功能"></a>6、演讲比赛功能</h2><h3 id="6-1-功能分析"><a href="#6-1-功能分析" class="headerlink" title="6.1 功能分析"></a>6.1 功能分析</h3><p>比赛流程分析：</p>
<p>抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → </p>
<p>抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数</p>
<h3 id="6-2-创建选手类"><a href="#6-2-创建选手类" class="headerlink" title="6.2 创建选手类"></a>6.2 创建选手类</h3><ul>
<li>选手类中的属性包含：选手姓名、分数</li>
<li>头文件中创建 speaker.h文件，并添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">double</span> m_Score[<span class="number">2</span>]; <span class="comment">//分数  最多有两轮得分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-比赛"><a href="#6-3-比赛" class="headerlink" title="6.3 比赛"></a>6.3 比赛</h3><h4 id="6-3-1-成员属性添加"><a href="#6-3-1-成员属性添加" class="headerlink" title="6.3.1 成员属性添加"></a>6.3.1 成员属性添加</h4><ul>
<li>在speechManager.h中添加属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比赛选手 容器  12人</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一轮晋级容器  6人</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//胜利前三名容器  3人</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vVictory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放编号 以及对应的 具体选手 容器</span></span><br><span class="line">map&lt;<span class="type">int</span>, Speaker&gt; m_Speaker;</span><br></pre></td></tr></table></figure>





<h4 id="6-3-2-初始化属性"><a href="#6-3-2-初始化属性" class="headerlink" title="6.3.2 初始化属性"></a>6.3.2 初始化属性</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void initSpeech();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化属性</span><br><span class="line">void initSpeech();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现<code>void initSpeech();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::initSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//容器保证为空</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;v1.<span class="built_in">clear</span>();  </span><br><span class="line">	<span class="keyword">this</span>-&gt;v2.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;vVictory.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Speaker.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="comment">//初始化比赛轮数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpeechManager构造函数中调用<code>void initSpeech();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-3-3-创建选手"><a href="#6-3-3-创建选手" class="headerlink" title="6.3.3 创建选手"></a>6.3.3 创建选手</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化创建12名选手</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSpeaker</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现<code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::createSpeaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJKL&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nameSeed.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		Speaker sp;</span><br><span class="line">		sp.m_Name = name;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sp.m_Score[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//12名选手编号</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;v1.<span class="built_in">push_back</span>(i + <span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选手编号 以及对应的选手 存放到map容器中</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Speaker.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(i + <span class="number">10001</span>, sp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpeechManager类的 构造函数中调用<code>void createSpeaker();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpeechManager::<span class="built_in">SpeechManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建选手</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">createSpeaker</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, Speaker&gt;::iterator it = sm.m_Speaker.<span class="built_in">begin</span>(); it != sm.m_Speaker.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">	cout  &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; it-&gt;first </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; it-&gt;second.m_Name </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; it-&gt;second.m_Score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204802.png"></p>
<ul>
<li>测试效果如图：</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529204822.png"></p>
<ul>
<li>测试完毕后，可以将测试代码删除或注释。</li>
</ul>
<h4 id="6-3-4-开始比赛成员函数添加"><a href="#6-3-4-开始比赛成员函数添加" class="headerlink" title="6.3.4 开始比赛成员函数添加"></a>6.3.4 开始比赛成员函数添加</h4><ul>
<li>在speechManager.h中提供开始比赛的的成员函数 <code>void startSpeech();</code></li>
<li>该函数功能是主要控制比赛的流程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开始比赛 - 比赛流程控制</span><br><span class="line">void startSpeech();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中将startSpeech的空实现先写入</li>
<li>我们可以先将整个比赛的流程 写到函数中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始比赛</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::startSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一轮比赛</span></span><br><span class="line">	<span class="comment">//1、抽签</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示晋级结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二轮比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最终结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、保存分数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-5-抽签"><a href="#6-3-5-抽签" class="headerlink" title="6.3.5 抽签"></a>6.3.5 抽签</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器  打乱次序即可</p>
</li>
<li><p>在speechManager.h中提供抽签的的成员函数 <code>void speechDraw();</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//抽签</span><br><span class="line">void speechDraw();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void speechDraw();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::speechDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第 &lt;&lt; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot; &gt;&gt; 轮比赛选手正在抽签&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;抽签后演讲顺序如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，调用抽签函数</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205033.png"></p>
<ul>
<li>在main函数中，分支1选项中，调用开始比赛的接口</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205049.png"></p>
<ul>
<li>测试</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205059.png"></p>
<h4 id="6-3-6-开始比赛"><a href="#6-3-6-开始比赛" class="headerlink" title="6.3.6 开始比赛"></a>6.3.6 开始比赛</h4><ul>
<li>在speechManager.h中提供比赛的的成员函数 <code>void speechContest();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//比赛</span><br><span class="line">void speechContest();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void speechContest();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::speechContest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------- 第&quot;</span>&lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮正式比赛开始：------------- &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">double</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; groupScore; <span class="comment">//临时容器，保存key分数 value 选手编号</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//记录人员数，6个为1组</span></span><br><span class="line"></span><br><span class="line">	vector &lt;<span class="type">int</span>&gt;v_Src;   <span class="comment">//比赛的人员容器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v_Src = v1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		v_Src = v2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历所有参赛选手</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v_Src.<span class="built_in">begin</span>(); it != v_Src.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//评委打分</span></span><br><span class="line">		deque&lt;<span class="type">double</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">double</span> score = (<span class="built_in">rand</span>() % <span class="number">401</span> + <span class="number">600</span>) / <span class="number">10.f</span>;  <span class="comment">// 600 ~ 1000</span></span><br><span class="line">			<span class="comment">//cout &lt;&lt; score &lt;&lt; &quot; &quot;;</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">double</span>&gt;());				<span class="comment">//排序</span></span><br><span class="line">		d.<span class="built_in">pop_front</span>();												<span class="comment">//去掉最高分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();												<span class="comment">//去掉最低分</span></span><br><span class="line"></span><br><span class="line">		<span class="type">double</span> sum = <span class="built_in">accumulate</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0.0f</span>);				<span class="comment">//获取总分</span></span><br><span class="line">		<span class="type">double</span> avg = sum / (<span class="type">double</span>)d.<span class="built_in">size</span>();									<span class="comment">//获取平均分</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//每个人平均分</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it  &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl;  //打印分数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] = avg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//6个人一组，用临时容器保存</span></span><br><span class="line">		groupScore.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(avg, *it));</span><br><span class="line">		<span class="keyword">if</span> (num % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; num / <span class="number">6</span> &lt;&lt; <span class="string">&quot;小组比赛名次：&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span> (multimap&lt;<span class="type">double</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt;::iterator it = groupScore.<span class="built_in">begin</span>(); it != groupScore.<span class="built_in">end</span>(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//取前三名</span></span><br><span class="line">			<span class="keyword">for</span> (multimap&lt;<span class="type">double</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt;::iterator it = groupScore.<span class="built_in">begin</span>(); it != groupScore.<span class="built_in">end</span>() &amp;&amp; count &lt; <span class="number">3</span>; it++, count++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					v2.<span class="built_in">push_back</span>((*it).second);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					vVictory.<span class="built_in">push_back</span>((*it).second);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			groupScore.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------- 第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮比赛完毕  ------------- &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，调用比赛函数</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205120.png"></p>
<ul>
<li>再次运行代码，测试比赛</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205130.png"></p>
<h4 id="6-3-7-显示比赛分数"><a href="#6-3-7-显示比赛分数" class="headerlink" title="6.3.7 显示比赛分数"></a>6.3.7 显示比赛分数</h4><ul>
<li>在speechManager.h中提供比赛的的成员函数 <code>void showScore();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//显示比赛结果</span><br><span class="line">void showScore();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void  showScore();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::showScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮晋级选手信息如下：-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v = v2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		v = vVictory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">show_Menu</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在startSpeech比赛流程控制的函数中，调用显示比赛分数函数</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205153.png"></p>
<ul>
<li>运行代码，测试效果</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205206.png"></p>
<h4 id="6-3-8-第二轮比赛"><a href="#6-3-8-第二轮比赛" class="headerlink" title="6.3.8 第二轮比赛"></a>6.3.8 第二轮比赛</h4><p>第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变</p>
<ul>
<li>在startSpeech比赛流程控制的函数中，加入第二轮的流程</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205220.png"></p>
<p>测试，将整个比赛流程都跑通</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205230.png"></p>
<h3 id="6-4-保存分数"><a href="#6-4-保存分数" class="headerlink" title="6.4 保存分数"></a>6.4 保存分数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将每次演讲比赛的得分记录到文件中</li>
</ul>
<p><strong>功能实现：</strong></p>
<ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void saveRecord();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//保存记录</span><br><span class="line">void saveRecord();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void saveRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::saveRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;speech.csv&quot;</span>, ios::out | ios::app); <span class="comment">// 用输出的方式打开文件  -- 写文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将每个人数据写入到文件中</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = vVictory.<span class="built_in">begin</span>(); it != vVictory.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; *it &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">			&lt;&lt; m_Speaker[*it].m_Score[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ofs &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;记录已经保存&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205246.png"></p>
<ul>
<li>测试，整个比赛完毕后记录保存情况</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205257.png"></p>
<p>利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205308.png"></p>
<p>至此，整个演讲比赛功能制作完毕！</p>
<h2 id="7、-查看记录"><a href="#7、-查看记录" class="headerlink" title="7、 查看记录"></a>7、 查看记录</h2><h3 id="7-1-读取记录分数"><a href="#7-1-读取记录分数" class="headerlink" title="7.1 读取记录分数"></a>7.1 读取记录分数</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void loadRecord();</code></li>
<li>添加判断文件是否为空的标志  <code>bool fileIsEmpty;</code></li>
<li>添加往届记录的容器<code>map&lt;int, vector&lt;string&gt;&gt; m_Record;</code></li>
</ul>
<p>其中m_Record 中的key代表第几届，value记录具体的信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取记录</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadRecord</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件为空的标志</span></span><br><span class="line"><span class="type">bool</span> fileIsEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往届记录</span></span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;string&gt;&gt; m_Record;</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void loadRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::loadRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::in)</span></span>; <span class="comment">//输入流对象 读取文件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	ifs &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ifs.<span class="built_in">eof</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不为空</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">putback</span>(ch); <span class="comment">//读取的单个字符放回去</span></span><br><span class="line"></span><br><span class="line">	string data;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; data &lt;&lt; endl;</span></span><br><span class="line">		vector&lt;string&gt;v;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pos = data.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>, start); <span class="comment">//从0开始查找 &#x27;,&#x27;</span></span><br><span class="line">			<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">//找不到break返回</span></span><br><span class="line">			&#125;</span><br><span class="line">			string tmp = data.<span class="built_in">substr</span>(start, pos - start); <span class="comment">//找到了,进行分割 参数1 起始位置，参数2 截取长度</span></span><br><span class="line">			v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			start = pos + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Record.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(index, v));</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在SpeechManager构造函数中调用获取往届记录函数</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205334.png"></p>
<h3 id="7-2-查看记录功能"><a href="#7-2-查看记录功能" class="headerlink" title="7.2 查看记录功能"></a>7.2 查看记录功能</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void showRecord();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//显示往届得分</span><br><span class="line">void showRecord();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void showRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::showRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Record.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;届 &quot;</span> &lt;&lt;</span><br><span class="line">			<span class="string">&quot;冠军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">			<span class="string">&quot;亚军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">			<span class="string">&quot;季军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">4</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-测试功能"><a href="#7-3-测试功能" class="headerlink" title="7.3 测试功能"></a>7.3 测试功能</h3><p>在main函数分支 2  选项中，调用查看记录的接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205350.png"></p>
<p>显示效果如图：（本次测试添加了4条记录）</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205401.png"></p>
<h3 id="7-4-bug解决"><a href="#7-4-bug解决" class="headerlink" title="7.4 bug解决"></a>7.4 bug解决</h3><p>目前程序中有几处bug未解决：</p>
<ol>
<li>查看往届记录，若文件不存在或为空，并未提示</li>
</ol>
<p>解决方式：在showRecord函数中，开始判断文件状态并加以判断</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205412.png"></p>
<ol>
<li>若记录为空或不存在，比完赛后依然提示记录为空</li>
</ol>
<p>解决方式：saveRecord中更新文件为空的标志</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205423.png"></p>
<ol>
<li>比完赛后查不到本届比赛的记录，没有实时更新</li>
</ol>
<p>解决方式：比赛完毕后，所有数据重置</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205434.png"></p>
<ol>
<li>在初始化时，没有初始化记录容器</li>
</ol>
<p>解决方式：initSpeech中添加 初始化记录容器</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205450.png"></p>
<ol>
<li>每次记录都是一样的</li>
</ol>
<p>解决方式：在main函数一开始 添加随机数种子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srand((unsigned int)time(NULL));</span><br></pre></td></tr></table></figure>



<p>所有bug解决后 测试：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205503.png"></p>
<h2 id="8、-清空记录"><a href="#8、-清空记录" class="headerlink" title="8、 清空记录"></a>8、 清空记录</h2><h3 id="8-1-清空记录功能实现"><a href="#8-1-清空记录功能实现" class="headerlink" title="8.1 清空记录功能实现"></a>8.1 清空记录功能实现</h3><ul>
<li>在speechManager.h中添加保存记录的成员函数 <code>void clearRecord();</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//清空记录</span><br><span class="line">void clearRecord();</span><br></pre></td></tr></table></figure>



<ul>
<li>在speechManager.cpp中实现成员函数 <code>void clearRecord();</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpeechManager::clearRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line">		<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::trunc)</span></span>;</span><br><span class="line">		ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化属性</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">initSpeech</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建选手</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">createSpeaker</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取往届记录</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">loadRecord</span>();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-测试清空"><a href="#8-2-测试清空" class="headerlink" title="8.2 测试清空"></a>8.2 测试清空</h3><p>在main函数分支 3  选项中，调用清空比赛记录的接口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205607.png"></p>
<p>运行程序，测试清空记录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205617.png"></p>
<p>speech.csv中记录也为空</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529205628.png"></p>
<ul>
<li>至此本案例结束！ <code>^_^</code></li>
</ul>
<br />

<br />









<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><blockquote class="blockquote-center">
<p>《读山海经·其一》陶渊明</p>
<p>孟夏草木长，绕屋树扶疏。<br>众鸟欣有托，吾亦爱吾庐。<br>既耕亦已种，时还读我书。<br>穷巷隔深辙，颇回故人车。<br>欢言酌春酒，摘我园中蔬。<br>微雨从东来，好风与之俱。<br>泛览《周王传》，流观《山海》图。<br>俯仰终宇宙，不乐复何如？</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>5-C++泛型编程和STL技术</title>
    <url>/posts/2687.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gf9lffvv4fj22io1w01jg.jpg"></p>
<center><font size=1>from pexels </center>

<p>本阶段主要针对C++<strong>泛型编程</strong>和<strong>STL</strong>技术做详细讲解，探讨C++更深层的使用</p>
<span id="more"></span>











<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1547105026929.png" alt="1547105026929"></p>
<p>PPT模板：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1547103297864.png" alt="1547103297864"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1547103359158.png" alt="1547103359158"></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li><p>C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板</p>
</li>
<li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p>
</li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​	<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​	<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>          				&#x2F;&#x2F;创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code>	        &#x2F;&#x2F;使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           &#x2F;&#x2F;使用n个字符c初始化</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          &#x2F;&#x2F;字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              &#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  &#x2F;&#x2F;用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​	string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; append(const char *s); </code>                               &#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       &#x2F;&#x2F;查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      &#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      &#x2F;&#x2F;查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>&#x3D; 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  &#x2F;&#x2F;与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      &#x2F;&#x2F;与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     &#x2F;&#x2F;通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    &#x2F;&#x2F;通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                &#x2F;&#x2F;在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    &#x2F;&#x2F;删除从Pos开始的n个字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>               		     &#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         &#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>vector&amp; operator=(const vector &amp;vec);</code>&#x2F;&#x2F;重载等号操作符</p>
</li>
<li><p><code>assign(beg, end);</code>       &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li><p><code>assign(n, elem);</code>        &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                            &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                      &#x2F;&#x2F;容器的容量</p>
</li>
<li><p><code>size();</code>                              &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>             &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					      &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​				              &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         &#x2F;&#x2F;尾部插入元素ele</li>
<li><code>pop_back();</code>                                                &#x2F;&#x2F;删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     &#x2F;&#x2F;删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        &#x2F;&#x2F;删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	v1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear</li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>       &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  &#x2F;&#x2F; 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      &#x2F;&#x2F;默认构造形式</li>
<li><code>deque(beg, end);</code>                  &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         &#x2F;&#x2F;重载等号操作符</p>
</li>
<li><p><code>assign(beg, end);</code>                                           &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li><p><code>assign(n, elem);</code>                                             &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                       &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                         &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>                &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​			                             &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          &#x2F;&#x2F;在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        &#x2F;&#x2F;在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   &#x2F;&#x2F;删除容器最后一个数据</li>
<li><code>pop_front();</code>                 &#x2F;&#x2F;删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>    &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                           &#x2F;&#x2F;清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>             &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>      &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  &#x2F;&#x2F;对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002.png" alt="img"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547605111510.jpg" alt="img"></p>
<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      &#x2F;&#x2F;向栈顶添加元素</li>
<li><code>pop();</code>                &#x2F;&#x2F;从栈顶移除第一个元素</li>
<li><code>top(); </code>                &#x2F;&#x2F;返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1547606785041.png" alt="1547606785041"></p>
<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             &#x2F;&#x2F;往队尾添加元素</li>
<li><code>pop();</code>                                      &#x2F;&#x2F;从队头移除第一个元素</li>
<li><code>back();</code>                                    &#x2F;&#x2F;返回最后一个元素</li>
<li><code>front(); </code>                                  &#x2F;&#x2F;返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            &#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         &#x2F;&#x2F;重载等号操作符</li>
<li><code>swap(lst);</code>                         &#x2F;&#x2F;将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                             &#x2F;&#x2F;返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                           &#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>                   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					    &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>       &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>                              //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        &#x2F;&#x2F;返回第一个元素。</li>
<li><code>back();</code>         &#x2F;&#x2F;返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   &#x2F;&#x2F;反转链表</li>
<li><code>sort();</code>        &#x2F;&#x2F;链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p>
</li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set&#x2F; multiset 容器"></a>3.8 set&#x2F; multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        &#x2F;&#x2F;默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            &#x2F;&#x2F;删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map&#x2F; multimap容器"></a>3.9 map&#x2F; multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map&#x2F;multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     &#x2F;&#x2F;map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             &#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    &#x2F;&#x2F;重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            &#x2F;&#x2F;删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                &#x2F;&#x2F;加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              &#x2F;&#x2F;减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    &#x2F;&#x2F;乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         &#x2F;&#x2F;除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         &#x2F;&#x2F;取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           &#x2F;&#x2F;取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    &#x2F;&#x2F;等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            &#x2F;&#x2F;不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      &#x2F;&#x2F;大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          &#x2F;&#x2F;大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           &#x2F;&#x2F;小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               &#x2F;&#x2F;小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              &#x2F;&#x2F;逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                &#x2F;&#x2F;逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              &#x2F;&#x2F;逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p>
</li>
<li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
</li>
<li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p>
</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     &#x2F;&#x2F;遍历容器</li>
<li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>&#x2F;&#x2F; 遍历算法 遍历容器元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>&#x2F;&#x2F;beg1 源容器开始迭代器</p>
<p>&#x2F;&#x2F;end1 源容器结束迭代器</p>
<p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p>
<p>&#x2F;&#x2F;_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     &#x2F;&#x2F;查找元素</li>
<li><code>find_if</code>               &#x2F;&#x2F;按条件查找元素</li>
<li><code>adjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li>
<li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li>
<li><code>count</code>                   &#x2F;&#x2F;统计元素个数</li>
<li><code>count_if</code>             &#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false</p>
<p>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong></p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 统计元素出现次数</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按条件统计元素出现次数</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             &#x2F;&#x2F;对容器内元素进行排序</li>
<li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       &#x2F;&#x2F; 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F;  beg    开始迭代器</p>
<p>&#x2F;&#x2F;  end    结束迭代器</p>
<p>&#x2F;&#x2F; _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 指定范围内的元素随机调整次序</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p>
<p>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong></p>
<p>&#x2F;&#x2F; beg1   容器1开始迭代器<br>&#x2F;&#x2F; end1   容器1结束迭代器<br>&#x2F;&#x2F; beg2   容器2开始迭代器<br>&#x2F;&#x2F; end2   容器2结束迭代器<br>&#x2F;&#x2F; dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>&#x2F;&#x2F; 反转指定范围的元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     &#x2F;&#x2F; 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>&#x2F;&#x2F; beg  开始迭代器</p>
<p>&#x2F;&#x2F; end  结束迭代器</p>
<p>&#x2F;&#x2F; dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; oldvalue 旧元素</p>
<p>&#x2F;&#x2F; newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; _pred 谓词</p>
<p>&#x2F;&#x2F; newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>&#x2F;&#x2F; 互换两个容器的元素</p>
<p>&#x2F;&#x2F; c1容器1</p>
<p>&#x2F;&#x2F; c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      &#x2F;&#x2F; 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 &#x2F;&#x2F; 向容器中添加元素</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 计算容器元素累计总和</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>&#x2F;&#x2F; 向容器中填充元素</p>
<p>&#x2F;&#x2F; beg 开始迭代器</p>
<p>&#x2F;&#x2F; end 结束迭代器</p>
<p>&#x2F;&#x2F; value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>          &#x2F;&#x2F; 求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                       &#x2F;&#x2F; 求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>              &#x2F;&#x2F; 求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的交集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的并集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>&#x2F;&#x2F; 求两个集合的差集</p>
<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>
<p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
<br />

<br />

<br />











<blockquote class="blockquote-center">
<p>《夏意》 [苏舜钦</p>
<p>别院深深夏席清，石榴开遍透帘明。<br>树阴满地日当午，梦觉流莺时一声。</p>

</blockquote>





<br />

<br />

<br />



]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title> C++ stringstream 简介</title>
    <url>/posts/23490.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/imgpexels-valiphotos-589802yas2.jpg"></p>
<p>C++ stringstream 能够实现字符串流的输入输出操作，将字符串对象与流关联起来，允许像读取流一样读取字符串(如 cin)。能够很方便的从字符串中提取出以空格分割的子串、计算单词的频率，并且能够很方便地实现内置类型数据数据之间的转换(如 string 转 int)。🍦</p>
<span id="more"></span>



 <br />

<h2 id="🥗-iostream-和-stringstream-的继承关系"><a href="#🥗-iostream-和-stringstream-的继承关系" class="headerlink" title="🥗 iostream 和 stringstream 的继承关系"></a>🥗 iostream 和 stringstream 的继承关系</h2><p>C++引入了ostringstream、istringstream、stringstream这三个类，要使用他们创建对象就必须包含  sstream 头文件。</p>
<ul>
<li>istringstream类用于执行C++风格的字符串流的输入操作。 </li>
<li>ostringstream类用于执行C++风格的字符串流的输出操作。 </li>
<li>strstream类同时可以支持C++风格的字符串流的<strong>输入输出</strong>操作。</li>
</ul>
<p>istringstream类是从istream和stringstreambase派生而来，ostringstream是从ostream和 stringstreambase派生而来， stringstream则是从iostream类和stringstreambase派生而来。</p>
<p>　　</p>
<p>他们的继承关系如下图所示， 箭头代表继承的关系</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img%E5%9B%BE%E7%89%87_80379125.png" alt="c++标准输入输出流关系"></p>
<p>c++标准输入输出流关系 ,可以看这篇文章  <a href="https://mp.weixin.qq.com/s/ATNbchUgcwU9ZLhCNsmzDg">c++标准输入输出流关系梳理  </a></p>
 <br />



<h2 id="🍦-istringstream"><a href="#🍦-istringstream" class="headerlink" title="🍦 istringstream"></a>🍦 istringstream</h2><p>istringstream是由一个string对象构造而来，istringstream类从一个string对象读取字符。<br>istringstream的构造函数原形如下：<br>istringstream::istringstream(string str);</p>
<p>一些常用的方法有：</p>
<blockquote>
<p>clear（）—清除流</p>
<p>str（）—获取并设置其内容存在于流中的字符串对象。</p>
<p>运算符&lt;&lt; —将字符串添加到stringstream对象。</p>
<p>运算符&gt;&gt; —从stringstream对象中读取内容，</p>
</blockquote>
<p>看一个使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    istringstream istr;</span><br><span class="line">    istr.<span class="built_in">str</span>(<span class="string">&quot;1 56.7&quot;</span>);</span><br><span class="line">    <span class="comment">//上述两个过程可以简单写成 istringstream istr(&quot;1 56.7&quot;);</span></span><br><span class="line">    cout &lt;&lt; istr.<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// 让istringstream对象返回一个string字符串</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    istr &gt;&gt; a;          <span class="comment">// 给a赋值的同时自动转换位 int </span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    istr &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 56.7</span><br><span class="line">1</span><br><span class="line">56.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，构造字符串流的时候，空格会成为字符串参数的内部分界，例子中对a,b对象的输入”赋值”操作证明了这一点，字符串的空格成为了整型数据与浮点型数据的分界点，利用分界获取的方法我们事实上完成了字符串到整型对象与浮点型对象的拆分转换过程。</p>
<blockquote>
<p>str()成员函数的使用可以让istringstream对象返回一个string字符串（例如本例中的输出操作(cout&lt;&lt;istr.str();）。</p>
</blockquote>
 <br />

 



<h2 id="🧃-ostringstream"><a href="#🧃-ostringstream" class="headerlink" title="🧃 ostringstream"></a>🧃 ostringstream</h2><p>ostringstream同样是由一个string对象构造而来，ostringstream类向一个string插入字符。<br>ostringstream的构造函数原形如下： ostringstream::ostringstream(string str);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::ostringstream ostr(&quot;abc&quot;);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//如果构造的时候设置了字符串参数,那么增长操作的时候不会从结尾开始增加,而是修改原有数据,超出的部分增长</span></span><br><span class="line"></span><br><span class="line">    std::ostringstream ostr;</span><br><span class="line">    ostr.<span class="built_in">put</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    ostr.<span class="built_in">put</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    ostr&lt;&lt;<span class="string">&quot;fg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;ostr.<span class="built_in">str</span>()&lt;&lt;   std::endl;</span><br><span class="line">    std::string mystr=ostr.<span class="built_in">str</span>();</span><br><span class="line">    std::cout&lt;&lt;mystr&lt;&lt;   std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defg</span><br><span class="line">defg</span><br></pre></td></tr></table></figure>



<p>在上例代码中，我们通过put()或者左移操作符可以不断向ostr插入单个字符或者是字符串，通过str()函数返回增长过后的完整字符串数据，但值 得注意的一点是，当构造的时候对象内已经存在字符串数据的时候，那么增长操作的时候不会从结尾开始增加,而是修改原有数据,超出的部分增长。</p>
 <br />

<h2 id="🥛-stringstream"><a href="#🥛-stringstream" class="headerlink" title="🥛 stringstream"></a>🥛 stringstream</h2><p>stringstream 用于C++风格的字符串的输入输出的。<br>stringstream的构造函数原形如下：</p>
<p>stringstream::stringstream(string str);</p>
<p>示例代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">iostr</span><span class="params">(<span class="string">&quot;xxx&quot;</span>)</span></span>;</span><br><span class="line">    iostr.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    iostr.<span class="built_in">put</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    iostr&lt;&lt;<span class="string">&quot;cde&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string mystr=iostr.<span class="built_in">str</span>();   <span class="comment">// 转换为字符串</span></span><br><span class="line">    cout&lt;&lt;mystr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> &amp;a:iostr.<span class="built_in">str</span>())    <span class="comment">// 遍历打印字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="keyword">while</span>(iostr&gt;&gt;b)     <span class="comment">// 输出至 b 并打印</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abcde</span><br><span class="line">a b c d e </span><br><span class="line">a b c d e </span><br></pre></td></tr></table></figure>

 <br />

<h2 id="🍹-内置类型数据之间的转换"><a href="#🍹-内置类型数据之间的转换" class="headerlink" title="🍹 内置类型数据之间的转换"></a>🍹 内置类型数据之间的转换</h2><p>除此而外，stringstream 类的对象我们还常用它进行string与各种内置类型数据之间的转换。 </p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>**argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    stringstream sstr;</span><br><span class="line">    <span class="comment">//--------int转string-----------</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    string str;</span><br><span class="line">    sstr&lt;&lt;a;</span><br><span class="line">    sstr&gt;&gt;str;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------string转int-----------</span></span><br><span class="line">    sstr.<span class="built_in">clear</span>();</span><br><span class="line">    sstr&lt;&lt;<span class="string">&quot;10 20&quot;</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(sstr&gt;&gt;temp)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------string转char[]--------</span></span><br><span class="line">    sstr.<span class="built_in">clear</span>();  <span class="comment">//如果你想通过使用同一stringstream对象实现多种类型的转换，请注意在每一次转换之后都必须调用clear()成员函数。</span></span><br><span class="line">    string blog=<span class="string">&quot;www.lifeee.top&quot;</span>;</span><br><span class="line">    <span class="type">char</span> cblog[<span class="number">200</span>];</span><br><span class="line">    sstr&lt;&lt;blog;</span><br><span class="line">    sstr&gt;&gt;cblog;</span><br><span class="line">    cout&lt;&lt;cblog&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">10 20 </span><br><span class="line">www.lifeee.top</span><br></pre></td></tr></table></figure>



<blockquote>
<p>实现任意类型的转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　　<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> out_type, <span class="keyword">typename</span> in_value&gt;</span></span><br><span class="line"><span class="function">　　　　out_type <span class="title">convert</span><span class="params">(<span class="type">const</span> in_value &amp; t)</span></span>&#123;</span><br><span class="line">　　　　　　stringstream stream;</span><br><span class="line">　　　　　　stream&lt;&lt;t;<span class="comment">//向流中传值</span></span><br><span class="line">　　　　　　out_type result;<span class="comment">//这里存储转换结果</span></span><br><span class="line">　　　　　　stream&gt;&gt;result;<span class="comment">//向result中写入值</span></span><br><span class="line">　　　　　　<span class="keyword">return</span> result;</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
 <br />

<h2 id="🥤-计算单词的频率"><a href="#🥤-计算单词的频率" class="headerlink" title="🥤 计算单词的频率"></a>🥤 计算单词的频率</h2><p>利用 stringstream 根据空格拆分字串的特性，可以很方便的对单词进行计数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算单词频率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFrequency</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"></span><br><span class="line">    string substr;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; substr)   <span class="comment">// 遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        mp[substr]++;      <span class="comment">// 计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">             &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string s=<span class="string">&quot;lifeee for lifeee learning&quot;</span>;</span><br><span class="line">    <span class="built_in">printFrequency</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> -&gt; 1</span><br><span class="line">learning -&gt; 1</span><br><span class="line">lifeee -&gt; 2</span><br></pre></td></tr></table></figure>



<p>当然既然能计数，肯定也是可以去除字符串中的空格的，参见 <a href="https://www.geeksforgeeks.org/removing-spaces-string-using-stringstream/">Removing spaces from a string using Stringstream - GeeksforGeeks</a></p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Program <span class="number">1</span>: Using EOF.</span><br><span class="line"></span><br><span class="line">程序<span class="number">1</span>: 使用 EOF。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ program to remove spaces using stringstream</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Function to remove spaces</span></span><br><span class="line"><span class="function">string <span class="title">removeSpaces</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    string temp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Storing the whole string</span></span><br><span class="line">    <span class="comment">// into string stream</span></span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Making the string empty</span></span><br><span class="line">    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Running loop till end of stream</span></span><br><span class="line">    <span class="keyword">while</span> (!ss.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Extracting word by word from stream</span></span><br><span class="line">        ss &gt;&gt; temp;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Concatenating in the string to be</span></span><br><span class="line">        <span class="comment">// returned</span></span><br><span class="line">        str = str + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Sample Inputs</span></span><br><span class="line">    string s = <span class="string">&quot;This is a test&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;geeks for geeks&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;geeks quiz is awsome!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;I love     to     code&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Output: 输出:</span><br><span class="line">Thisisatest</span><br><span class="line">geeksforgeeks</span><br><span class="line">geeksquizisawsome!</span><br><span class="line">Ilovetocode</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Program <span class="number">2</span>: <span class="function">Using <span class="title">getline</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">程序2: 使用 getline ()。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// C++ program to remove spaces using stringstream</span></span><br><span class="line"><span class="function">// and getline()</span></span><br><span class="line"><span class="function">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="function">using namespace std;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Function to remove spaces</span></span><br><span class="line"><span class="function">string <span class="title">removeSpaces</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Storing the whole string</span></span><br><span class="line">    <span class="comment">// into string stream</span></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string temp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Making the string empty</span></span><br><span class="line">    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Running loop till end of stream</span></span><br><span class="line">    <span class="comment">// and getting every word</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, temp, <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Concatenating in the string</span></span><br><span class="line">        <span class="comment">// to be returned</span></span><br><span class="line">        str = str + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Driver function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Sample Inputs</span></span><br><span class="line">    string s = <span class="string">&quot;This is a test&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;geeks for geeks&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;geeks quiz is awsome!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    s = <span class="string">&quot;I   love     to     code&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">removeSpaces</span>(s) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Code contributed by saychakr13</span></span><br><span class="line">Output: 输出:</span><br><span class="line">Thisisatest</span><br><span class="line">geeksforgeeks</span><br><span class="line">geeksquizisawsome!</span><br><span class="line">Ilovetocode</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


</blockquote>
 <br />

<h2 id="🍗-参考文献"><a href="#🍗-参考文献" class="headerlink" title="🍗 参考文献"></a>🍗 参考文献</h2><p><a href="https://www.cplusplus.com/reference/sstream/stringstream/stringstream/">stringstream::stringstream - C++ Reference (cplusplus.com)</a></p>
<p><a href="http://www.usidcbbs.com/read-htm-tid-1898.html">http://www.usidcbbs.com/read-htm-tid-1898.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/ATNbchUgcwU9ZLhCNsmzDg">c++标准输入输出流关系梳理  </a></p>
<p><a href="https://blog.csdn.net/freeking101/article/details/61198218">C++ stringstream_freeking101的博客</a></p>
<p><a href="https://www.geeksforgeeks.org/stringstream-c-applications/">stringstream in C++ and its applications - GeeksforGeeks</a></p>
<p><a href="https://www.pexels.com/zh-cn/photo/589802/">高大的树木 · 免费素材图片 (pexels.com)</a></p>
 <br />

<br />

 <br />





<blockquote class="blockquote-center">
<p>漠漠水田飞白鹭，阴阴夏木啭黄鹂。</p>
<p>– 王维 《<a href="https://so.gushiwen.cn/shiwenv_61ac7e419655.aspx">积雨辋川庄作 &#x2F; 秋归辋川庄作</a>》</p>

</blockquote>

  <br />

<br />

 <br />
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>7-C++实战项目-机房预约系统</title>
    <url>/posts/30779.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529220150.jpg"></p>
<p>C++ 机房预约系统实例。</p>
<span id="more"></span>





<h2 id="1、机房预约系统需求"><a href="#1、机房预约系统需求" class="headerlink" title="1、机房预约系统需求"></a>1、机房预约系统需求</h2><h3 id="1-1-系统简介"><a href="#1-1-系统简介" class="headerlink" title="1.1 系统简介"></a>1.1 系统简介</h3><ul>
<li>学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套机房预约系统，解决这一问题。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212248.png"></p>
<h3 id="1-2-身份简介"><a href="#1-2-身份简介" class="headerlink" title="1.2 身份简介"></a>1.2 身份简介</h3><p>分别有三种身份使用该程序</p>
<ul>
<li><strong>学生代表</strong>：申请使用机房</li>
<li><strong>教师</strong>：审核学生的预约申请</li>
<li><strong>管理员</strong>：给学生、教师创建账号</li>
</ul>
<h3 id="1-3-机房简介"><a href="#1-3-机房简介" class="headerlink" title="1.3 机房简介"></a>1.3 机房简介</h3><p>机房总共有3间</p>
<ul>
<li>1号机房   — 最大容量20人</li>
<li>2号机房   — 最多容量50人</li>
<li>3号机房   — 最多容量100人</li>
</ul>
<h3 id="1-4-申请简介"><a href="#1-4-申请简介" class="headerlink" title="1.4 申请简介"></a>1.4 申请简介</h3><ul>
<li>申请的订单每周由管理员负责清空。</li>
<li>学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）</li>
<li>教师来审核预约，依据实际情况审核预约通过或者不通过</li>
</ul>
<h3 id="1-5-系统具体需求"><a href="#1-5-系统具体需求" class="headerlink" title="1.5 系统具体需求"></a>1.5 系统具体需求</h3><ul>
<li>首先进入登录界面，可选登录身份有：<ul>
<li>学生代表</li>
<li>老师</li>
<li>管理员</li>
<li>退出</li>
</ul>
</li>
<li>每个身份都需要进行验证后，进入子菜单<ul>
<li>学生需要输入 ：学号、姓名、登录密码</li>
<li>老师需要输入：职工号、姓名、登录密码</li>
<li>管理员需要输入：管理员姓名、登录密码</li>
</ul>
</li>
<li>学生具体功能<ul>
<li>申请预约    —   预约机房</li>
<li>查看自身的预约    —  查看自己的预约状态</li>
<li>查看所有预约   —   查看全部预约信息以及预约状态</li>
<li>取消预约    —   取消自身的预约，预约成功或审核中的预约均可取消</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
<li>教师具体功能<ul>
<li>查看所有预约   —   查看全部预约信息以及预约状态</li>
<li>审核预约    —   对学生的预约进行审核</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
<li>管理员具体功能<ul>
<li>添加账号    —   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复</li>
<li>查看账号    —   可以选择查看学生或教师的全部信息</li>
<li>查看机房    —   查看所有机房的信息</li>
<li>清空预约    —   清空所有预约记录</li>
<li>注销登录    —   退出登录</li>
</ul>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212313.png"></p>
<h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p>
<ul>
<li>创建新项目</li>
<li>添加文件</li>
</ul>
<h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul>
<li>打开vs2017后，点击创建新项目，创建新的C++项目</li>
</ul>
<p>如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212342.png"></p>
<ul>
<li>填写项目名称以及选取项目路径，点击确定生成项目</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548682522544.png" alt="1548682522544"></p>
<h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul>
<li>右键源文件，进行添加文件操作</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212419.png"></p>
<ul>
<li>填写文件名称，点击添加</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548682679989.png" alt="1548682679989"></p>
<ul>
<li>生成文件成功，效果如下图</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212438.png"></p>
<h2 id="3、创建主菜单"><a href="#3、创建主菜单" class="headerlink" title="3、创建主菜单"></a>3、创建主菜单</h2><p><strong>功能描述：</strong></p>
<ul>
<li>设计主菜单，与用户进行交互</li>
</ul>
<h3 id="3-1-菜单实现"><a href="#3-1-菜单实现" class="headerlink" title="3.1 菜单实现"></a>3.1 菜单实现</h3><ul>
<li>在主函数main中添加菜单提示，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客机房预约系统  =====================&quot;</span> </span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212659.png"></p>
<h3 id="3-2-搭建接口"><a href="#3-2-搭建接口" class="headerlink" title="3.2 搭建接口"></a>3.2 搭建接口</h3><ul>
<li>接受用户的选择，搭建接口</li>
<li>在main中添加代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客机房预约系统  =====================&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//学生身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//老师身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;输入有误，请重新选择！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择</p>
<p>效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212718.png"></p>
<p>至此，界面搭建完毕</p>
<h2 id="4、-退出功能实现"><a href="#4、-退出功能实现" class="headerlink" title="4、 退出功能实现"></a>4、 退出功能实现</h2><h3 id="4-1-退出功能实现"><a href="#4-1-退出功能实现" class="headerlink" title="4.1 退出功能实现"></a>4.1 退出功能实现</h3><p>在main函数分支 0 选项中，添加退出程序的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;欢迎下一次使用&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548558992754.png" alt="1548558992754"></p>
<h3 id="4-2-测试退出功能"><a href="#4-2-测试退出功能" class="headerlink" title="4.2 测试退出功能"></a>4.2 测试退出功能</h3><p>运行程序，效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212736.png"></p>
<p>至此，退出程序功能实现</p>
<h2 id="5、-创建身份类"><a href="#5、-创建身份类" class="headerlink" title="5、 创建身份类"></a>5、 创建身份类</h2><h3 id="5-1-身份的基类"><a href="#5-1-身份的基类" class="headerlink" title="5.1 身份的基类"></a>5.1 身份的基类</h3><ul>
<li>在整个系统中，有三种身份，分别为：学生代表、老师以及管理员</li>
<li>三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类<strong>identity</strong></li>
<li>在头文件下创建Identity.h文件</li>
</ul>
<p>Identity.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Identity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//操作菜单</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//用户名</span></span><br><span class="line">	string m_Pwd;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212812.png"></p>
<h3 id="5-2-学生类"><a href="#5-2-学生类" class="headerlink" title="5.2 学生类"></a>5.2 学生类</h3><h4 id="5-2-1-功能分析"><a href="#5-2-1-功能分析" class="headerlink" title="5.2.1 功能分析"></a>5.2.1 功能分析</h4><ul>
<li><p>学生类主要功能是可以通过类中成员函数，实现预约实验室操作</p>
</li>
<li><p>学生类中主要功能有：</p>
<ul>
<li>显示学生操作的菜单界面</li>
<li>申请预约</li>
<li>查看自身预约</li>
<li>查看所有预约</li>
<li>取消预约</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-类的创建"><a href="#5-2-2-类的创建" class="headerlink" title="5.2.2 类的创建"></a>5.2.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 student.h 和 student.cpp文件</li>
</ul>
<p>student.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> :<span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">int</span> id, string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//菜单界面</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operMenu</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看我的预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看所有预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//取消预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//学生学号</span></span><br><span class="line">	<span class="type">int</span> m_Id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>student.cpp中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> id, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="5-3-老师类"><a href="#5-3-老师类" class="headerlink" title="5.3 老师类"></a>5.3 老师类</h3><h4 id="5-3-1-功能分析"><a href="#5-3-1-功能分析" class="headerlink" title="5.3.1 功能分析"></a>5.3.1 功能分析</h4><ul>
<li><p>教师类主要功能是查看学生的预约，并进行审核</p>
</li>
<li><p>教师类中主要功能有：</p>
<ul>
<li><p>显示教师操作的菜单界面</p>
</li>
<li><p>查看所有预约</p>
</li>
<li><p>审核预约</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-2-类的创建"><a href="#5-3-2-类的创建" class="headerlink" title="5.3.2 类的创建"></a>5.3.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件</li>
</ul>
<p>teacher.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> :<span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Teacher</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="type">int</span> empId, string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//菜单界面</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看所有预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//审核预约</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">validOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_EmpId; <span class="comment">//教师编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>teacher.cpp中添加如下代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;teacher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="type">int</span> empId, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="5-4-管理员类"><a href="#5-4-管理员类" class="headerlink" title="5.4 管理员类"></a>5.4 管理员类</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><ul>
<li><p>管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录</p>
</li>
<li><p>管理员类中主要功能有：</p>
<ul>
<li><p>显示管理员操作的菜单界面</p>
</li>
<li><p>添加账号</p>
</li>
<li><p>查看账号</p>
</li>
<li><p>查看机房信息</p>
</li>
<li><p>清空预约记录</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-2-类的创建"><a href="#5-4-2-类的创建" class="headerlink" title="5.4.2 类的创建"></a>5.4.2 类的创建</h4><ul>
<li>在头文件以及源文件下创建 manager.h 和 manager.cpp文件</li>
</ul>
<p>manager.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> :<span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="built_in">Manager</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造  管理员姓名，密码</span></span><br><span class="line">	<span class="built_in">Manager</span>(string name, string pwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择菜单</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加账号  </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看账号</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看机房信息</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空预约记录</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>manager.cpp中添加如下代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，所有身份类创建完毕，效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212847.png"></p>
<h2 id="6、-登录模块"><a href="#6、-登录模块" class="headerlink" title="6、  登录模块"></a>6、  登录模块</h2><h3 id="6-1-全局文件添加"><a href="#6-1-全局文件添加" class="headerlink" title="6.1 全局文件添加"></a>6.1 全局文件添加</h3><p>功能描述：</p>
<ul>
<li>不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中</li>
<li>在头文件中添加 <strong>globalFile.h</strong> 文件</li>
<li>并添加如下代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADMIN_FILE     <span class="string">&quot;admin.txt&quot;</span></span></span><br><span class="line"><span class="comment">//学生文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENT_FILE   <span class="string">&quot;student.txt&quot;</span></span></span><br><span class="line"><span class="comment">//教师文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEACHER_FILE   <span class="string">&quot;teacher.txt&quot;</span></span></span><br><span class="line"><span class="comment">//机房信息文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMPUTER_FILE  <span class="string">&quot;computerRoom.txt&quot;</span></span></span><br><span class="line"><span class="comment">//订单文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORDER_FILE     <span class="string">&quot;order.txt&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>并且在同级目录下，创建这几个文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212902.png"></p>
<h3 id="6-2-登录函数封装"><a href="#6-2-登录函数封装" class="headerlink" title="6.2  登录函数封装"></a>6.2  登录函数封装</h3><p>功能描述：</p>
<ul>
<li>根据用户的选择，进入不同的身份登录</li>
</ul>
<p>在预约系统的.cpp文件中添加全局函数 <code>void LoginIn(string fileName, int type)</code></p>
<p>参数：</p>
<ul>
<li>fileName  — 操作的文件名</li>
<li>type      —  登录的身份  （1代表学生、2代表老师、3代表管理员）</li>
</ul>
<p>LoginIn中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;identity.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginIn</span><span class="params">(string fileName, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(fileName, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件不存在情况</span></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">	string name;</span><br><span class="line">	string pwd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)	<span class="comment">//学生登录</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入你的学号&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">//教师登录</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入你的职工号&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入用户名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//学生登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//教师登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//管理员登录验证</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;验证登录失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在main函数的不同分支中，填入不同的登录接口</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529212914.png"></p>
<h3 id="6-3-学生登录实现"><a href="#6-3-学生登录实现" class="headerlink" title="6.3 学生登录实现"></a>6.3 学生登录实现</h3><p>在student.txt文件中添加两条学生信息，用于测试</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>第一列  代表  <strong>学号</strong></li>
<li>第二列  代表  <strong>学生姓名</strong></li>
<li>第三列  代表  <strong>密码</strong></li>
</ul>
<p>效果图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548583693555.png" alt="1548583693555"></p>
<p>在Login函数的学生分支中加入如下代码，验证学生身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line"><span class="type">int</span> fId;</span><br><span class="line">string fName;</span><br><span class="line">string fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;学生验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		person = <span class="keyword">new</span> <span class="built_in">Student</span>(id, name, pwd);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加代码效果图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548583915819.png" alt="1548583915819"></p>
<p>测试：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213010.png"></p>
<h3 id="6-4-教师登录实现"><a href="#6-4-教师登录实现" class="headerlink" title="6.4 教师登录实现"></a>6.4 教师登录实现</h3><p>在teacher.txt文件中添加一条老师信息，用于测试</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 老王 <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>第一列  代表  <strong>教师职工编号</strong></li>
<li>第二列  代表  <strong>教师姓名</strong></li>
<li>第三列  代表  <strong>密码</strong></li>
</ul>
<p>效果图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213110.png"></p>
<p>在Login函数的教师分支中加入如下代码，验证教师身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line"><span class="type">int</span> fId;</span><br><span class="line">string fName;</span><br><span class="line">string fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;教师验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		person = <span class="keyword">new</span> <span class="built_in">Teacher</span>(id, name, pwd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加代码效果图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213131.png"></p>
<p>测试：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213204.png"></p>
<h3 id="6-5-管理员登录实现"><a href="#6-5-管理员登录实现" class="headerlink" title="6.5 管理员登录实现"></a>6.5 管理员登录实现</h3><p>在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能</p>
<p>添加信息:   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">admin <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>其中：<code>admin</code>代表管理员用户名，<code>123</code>代表管理员密码</p>
<p>效果图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213310.png"></p>
<p>在Login函数的管理员分支中加入如下代码，验证管理员身份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line">		string fName;</span><br><span class="line">		string fPwd;</span><br><span class="line">		<span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;验证登录成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="comment">//登录成功后，按任意键进入管理员界面</span></span><br><span class="line">				<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">				<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">				<span class="comment">//创建管理员对象</span></span><br><span class="line">				person = <span class="keyword">new</span> <span class="built_in">Manager</span>(name,pwd);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548588322712.png" alt="1548588322712"></p>
<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213344.png"></p>
<p>至此，所有身份的登录功能全部实现！</p>
<h2 id="7、-管理员模块"><a href="#7、-管理员模块" class="headerlink" title="7、 管理员模块"></a>7、 管理员模块</h2><h3 id="7-1-管理员登录和注销"><a href="#7-1-管理员登录和注销" class="headerlink" title="7.1  管理员登录和注销"></a>7.1  管理员登录和注销</h3><h4 id="7-1-1-构造函数"><a href="#7-1-1-构造函数" class="headerlink" title="7.1.1 构造函数"></a>7.1.1 构造函数</h4><ul>
<li>在Manager类的构造函数中，初始化管理员信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="7-1-2-管理员子菜单"><a href="#7-1-2-管理员子菜单" class="headerlink" title="7.1.2  管理员子菜单"></a>7.1.2  管理员子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>添加账号</li>
<li>查看账号</li>
<li>查看机房</li>
<li>清空预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void managerMenu(Identity * &amp;manager)</code>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//管理员菜单</span></span><br><span class="line">		manager-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Manager* man = (Manager*)manager;</span><br><span class="line">		<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>)  <span class="comment">//添加账号</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;添加账号&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">addPerson</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查看账号&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">showPerson</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;查看机房&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">showComputer</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;清空预约&quot;</span> &lt;&lt; endl;</span><br><span class="line">			man-&gt;<span class="built_in">cleanFile</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> manager;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-1-3-菜单功能实现"><a href="#7-1-3-菜单功能实现" class="headerlink" title="7.1.3 菜单功能实现"></a>7.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Manager::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎管理员：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.添加账号            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.查看账号            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.查看机房            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          4.清空预约            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录            |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-1-4-接口对接"><a href="#7-1-4-接口对接" class="headerlink" title="7.1.4 接口对接"></a>7.1.4 接口对接</h4><ul>
<li>管理员成功登录后，调用管理员子菜单界面</li>
<li>在管理员登录验证分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入管理员子菜单</span></span><br><span class="line"><span class="built_in">managerMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213428.png"></p>
<p>测试对接，效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213449.png"></p>
<p>登录成功</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548589328710.png" alt="1548589328710"></p>
<p>注销登录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548589416576.png" alt="1548589416576"></p>
<p>至此，管理员身份可以成功登录以及注销</p>
<h3 id="7-2-添加账号"><a href="#7-2-添加账号" class="headerlink" title="7.2 添加账号"></a>7.2 添加账号</h3><p>功能描述：</p>
<ul>
<li>给学生或教师添加新的账号</li>
</ul>
<p>功能要求：</p>
<ul>
<li>添加时学生学号不能重复、教师职工号不能重复</li>
</ul>
<h4 id="7-2-1-添加功能实现"><a href="#7-2-1-添加功能实现" class="headerlink" title="7.2.1 添加功能实现"></a>7.2.1 添加功能实现</h4><p>在Manager的<strong>addPerson</strong>成员函数中，实现添加新账号功能，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入添加账号的类型&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、添加学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、添加老师&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string fileName;</span><br><span class="line">	string tip;</span><br><span class="line">	ofstream ofs;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fileName = STUDENT_FILE;</span><br><span class="line">		tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		fileName = TEACHER_FILE;</span><br><span class="line">		tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">open</span>(fileName, ios::out | ios::app);</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	string pwd;</span><br><span class="line">	cout &lt;&lt;tip &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入姓名： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pwd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试添加学生：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213529.png"></p>
<p>成功在学生文件中添加了一条信息</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548641141027.png" alt="1548641141027"></p>
<p>测试添加教师：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213547.png"></p>
<p>成功在教师文件中添加了一条信息</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213621.png"></p>
<h4 id="7-2-2-去重操作"><a href="#7-2-2-去重操作" class="headerlink" title="7.2.2 去重操作"></a>7.2.2 去重操作</h4><p>功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误</p>
<h5 id="7-2-2-1-读取信息"><a href="#7-2-2-1-读取信息" class="headerlink" title="7.2.2.1 读取信息"></a>7.2.2.1 读取信息</h5><ul>
<li>要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测</li>
<li>在manager.h中，添加两个容器，用于存放学生和教师的信息</li>
<li>添加一个新的成员函数  <code>void initVector()</code> 初始化容器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line">vector&lt;Student&gt; vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line">vector&lt;Teacher&gt; vTea;</span><br></pre></td></tr></table></figure>

<p>添加位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548644354561.png" alt="1548644354561"></p>
<p>在Manager的有参构造函数中，获取目前的学生和教师信息</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//读取学生文件中信息</span></span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(STUDENT_FILE, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	vStu.<span class="built_in">clear</span>();</span><br><span class="line">     vTea.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">	Student s;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">	&#123;</span><br><span class="line">		vStu.<span class="built_in">push_back</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;当前学生数量为： &quot;</span> &lt;&lt; vStu.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>(); <span class="comment">//学生初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取老师文件信息</span></span><br><span class="line">	ifs.<span class="built_in">open</span>(TEACHER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">	Teacher t;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)</span><br><span class="line">	&#123;</span><br><span class="line">		vTea.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;当前教师数量为： &quot;</span> &lt;&lt; vTea.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在有参构造函数中，调用初始化容器函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//初始化容器</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">initVector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>测试，运行代码可以看到测试代码获取当前学生和教师数量</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213646.png"></p>
<h5 id="7-2-2-2-去重函数封装"><a href="#7-2-2-2-去重函数封装" class="headerlink" title="7.2.2.2 去重函数封装"></a>7.2.2.2 去重函数封装</h5><p>在manager.h文件中添加成员函数<code> bool checkRepeat(int id, int type);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在manager.cpp文件中实现成员函数  <code> bool checkRepeat(int id, int type);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;Student&gt;::iterator it = vStu.<span class="built_in">begin</span>(); it != vStu.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;Teacher&gt;::iterator it = vTea.<span class="built_in">begin</span>(); it != vTea.<span class="built_in">end</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-2-2-3-添加去重操作"><a href="#7-2-2-3-添加去重操作" class="headerlink" title="7.2.2.3 添加去重操作"></a>7.2.2.3 添加去重操作</h5><p>在添加学生编号或者教师职工号时，检测是否有重复，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	fileName = STUDENT_FILE;</span><br><span class="line">	tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">	errorTip = <span class="string">&quot;学号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	fileName = TEACHER_FILE;</span><br><span class="line">	tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">	errorTip = <span class="string">&quot;职工号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs.<span class="built_in">open</span>(fileName, ios::out | ios::app);</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">string name;</span><br><span class="line">string pwd;</span><br><span class="line">cout &lt;&lt;tip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> ret = <span class="keyword">this</span>-&gt;<span class="built_in">checkRepeat</span>(id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; errorTip &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213701.png"></p>
<p>检测效果：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213714.png"></p>
<h5 id="7-2-2-4-bug解决"><a href="#7-2-2-4-bug解决" class="headerlink" title="7.2.2.4 bug解决"></a>7.2.2.4 bug解决</h5><p>bug描述：</p>
<ul>
<li>虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测</li>
<li>导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复</li>
</ul>
<p>解决方案：</p>
<ul>
<li>在每次添加新账号时，重新初始化容器</li>
</ul>
<p>在添加完毕后，加入代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">initVector</span>();</span><br></pre></td></tr></table></figure>

<p>位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548644779578.png" alt="1548644779578"></p>
<p>再次测试，刚加入的账号不会重复添加了！</p>
<h3 id="7-3-显示账号"><a href="#7-3-显示账号" class="headerlink" title="7.3  显示账号"></a>7.3  显示账号</h3><p>功能描述：显示学生信息或教师信息</p>
<h4 id="7-3-1-显示功能实现"><a href="#7-3-1-显示功能实现" class="headerlink" title="7.3.1 显示功能实现"></a>7.3.1 显示功能实现</h4><p>在Manager的<strong>showPerson</strong>成员函数中，实现显示账号功能，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; s.m_Pwd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; t.m_EmpId &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; t.m_Pwd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择查看内容：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、查看所有学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、查看所有老师&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; select;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;所有学生信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		for_each(vStu.<span class="built_in">begin</span>(), vStu.<span class="built_in">end</span>(), printStudent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;所有老师信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">		for_each(vTea.<span class="built_in">begin</span>(), vTea.<span class="built_in">end</span>(), printTeacher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-2-测试"><a href="#7-3-2-测试" class="headerlink" title="7.3.2 测试"></a>7.3.2 测试</h4><p>测试查看学生效果</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213801.png"></p>
<p>测试查看教师效果</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/1548646833665.png" alt="1548646833665"></p>
<p>至此，显示账号功能实现完毕</p>
<h3 id="7-4-查看机房"><a href="#7-4-查看机房" class="headerlink" title="7.4 查看机房"></a>7.4 查看机房</h3><h4 id="7-4-1-添加机房信息"><a href="#7-4-1-添加机房信息" class="headerlink" title="7.4.1 添加机房信息"></a>7.4.1 添加机房信息</h4><p>案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台</p>
<p>我们可以将信息录入到computerRoom.txt中</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529213820.png"></p>
<h4 id="7-4-2-机房类创建"><a href="#7-4-2-机房类创建" class="headerlink" title="7.4.2 机房类创建"></a>7.4.2 机房类创建</h4><p>在头文件下，创建新的文件 computerRoom.h</p>
<p>并添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerRoom</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_ComId; <span class="comment">//机房id号</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="7-4-3-初始化机房信息"><a href="#7-4-3-初始化机房信息" class="headerlink" title="7.4.3 初始化机房信息"></a>7.4.3 初始化机房信息</h4><p>在Manager管理员类下，添加机房的容器,用于保存机房信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line">vector&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure>

<p>在Manager有参构造函数中，追加如下代码，初始化机房信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">	vCom.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前机房数量为： &quot;</span> &lt;&lt; vCom.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214247.png"></p>
<p>因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护</p>
<h4 id="7-4-4-显示机房信息"><a href="#7-4-4-显示机房信息" class="headerlink" title="7.4.4 显示机房信息"></a>7.4.4 显示机房信息</h4><p>在Manager类的showComputer成员函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;机房信息如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;ComputerRoom&gt;::iterator it = vCom.<span class="built_in">begin</span>(); it != vCom.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;机房编号： &quot;</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">&quot; 机房最大容量： &quot;</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试显示机房信息功能：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214304.png"></p>
<h3 id="7-5-清空预约"><a href="#7-5-清空预约" class="headerlink" title="7.5 清空预约"></a>7.5 清空预约</h3><p>功能描述：</p>
<p>清空生成的<code>order.txt</code>预约文件</p>
<h4 id="7-5-1-清空功能实现"><a href="#7-5-1-清空功能实现" class="headerlink" title="7.5.1 清空功能实现"></a>7.5.1 清空功能实现</h4><p>在Manager的cleanFile成员函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净</p>
<h2 id="8、-学生模块"><a href="#8、-学生模块" class="headerlink" title="8、 学生模块"></a>8、 学生模块</h2><h3 id="8-1-学生登录和注销"><a href="#8-1-学生登录和注销" class="headerlink" title="8.1 学生登录和注销"></a>8.1 学生登录和注销</h3><h4 id="8-1-1-构造函数"><a href="#8-1-1-构造函数" class="headerlink" title="8.1.1 构造函数"></a>8.1.1 构造函数</h4><ul>
<li>在Student类的构造函数中，初始化学生信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> id, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-2-管理员子菜单"><a href="#8-1-2-管理员子菜单" class="headerlink" title="8.1.2  管理员子菜单"></a>8.1.2  管理员子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>申请预约</li>
<li>查看我的预约</li>
<li>查看所有预约</li>
<li>取消预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void studentMenu(Identity * &amp;manager)</code> 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">studentMenu</span><span class="params">(Identity * &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//学生菜单</span></span><br><span class="line">		student-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Student* stu = (Student*)student;</span><br><span class="line">		<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">applyOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">showMyOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">showAllOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">		&#123;</span><br><span class="line">			stu-&gt;<span class="built_in">cancelOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> student;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-3-菜单功能实现"><a href="#8-1-3-菜单功能实现" class="headerlink" title="8.1.3 菜单功能实现"></a>8.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Student::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎学生代表：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.申请预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.查看我的预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          3.查看所有预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          4.取消预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-1-4-接口对接"><a href="#8-1-4-接口对接" class="headerlink" title="8.1.4 接口对接"></a>8.1.4 接口对接</h4><ul>
<li>学生成功登录后，调用学生的子菜单界面</li>
<li>在学生登录分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入学生子菜单</span></span><br><span class="line"><span class="built_in">studentMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214353.png"></p>
<p>测试对接，效果如图：</p>
<p>登录验证通过：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214407.png"></p>
<p>学生子菜单：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214420.png"></p>
<p>注销登录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214542.png"></p>
<h3 id="8-2-申请预约"><a href="#8-2-申请预约" class="headerlink" title="8.2 申请预约"></a>8.2 申请预约</h3><h4 id="8-2-1-获取机房信息"><a href="#8-2-1-获取机房信息" class="headerlink" title="8.2.1 获取机房信息"></a>8.2.1 获取机房信息</h4><ul>
<li>在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息</li>
</ul>
<p>在student.h中添加新的成员函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line">vector&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure>

<p>在学生的有参构造函数中追加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">	vCom.<span class="built_in">push_back</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>追加位置如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214557.png"></p>
<p>至此，vCom容器中保存了所有机房的信息</p>
<h4 id="8-2-2-预约功能实现"><a href="#8-2-2-预约功能实现" class="headerlink" title="8.2.2 预约功能实现"></a>8.2.2 预约功能实现</h4><p>在student.cpp中实现成员函数 <code>void Student::applyOrder()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;机房开放时间为周一至周五！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入申请预约的时间：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、周一&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、周二&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、周三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4、周四&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5、周五&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> date = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> interval = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> room = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; date;</span><br><span class="line">		<span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入申请预约的时间段：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、上午&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、下午&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; interval;</span><br><span class="line">		<span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择机房：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">0</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">1</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">2</span>].m_MaxNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; room;</span><br><span class="line">		<span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;预约成功！审核中&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::app)</span></span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; interval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; room &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行程序，测试代码:</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214739.png"></p>
<p>在order.txt文件中生成如下内容：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529214823.png"></p>
<h3 id="8-3-显示预约"><a href="#8-3-显示预约" class="headerlink" title="8.3 显示预约"></a>8.3 显示预约</h3><h4 id="8-3-1-创建预约类"><a href="#8-3-1-创建预约类" class="headerlink" title="8.3.1 创建预约类"></a>8.3.1 创建预约类</h4><p>功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新</p>
<p>在头文件以及源文件下分别创建<strong>orderFile.h</strong> 和 <strong>orderFile.cpp</strong>文件</p>
<p>orderFile.h中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">OrderFile</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新预约记录</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息</span></span><br><span class="line">	map&lt;<span class="type">int</span>, map&lt;string, string&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预约记录条数</span></span><br><span class="line">	<span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>构造函数</strong>中获取所有信息，并存放在容器中，添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">OrderFile::<span class="built_in">OrderFile</span>()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">	string date;      <span class="comment">//日期</span></span><br><span class="line">	string interval;  <span class="comment">//时间段</span></span><br><span class="line">	string stuId;     <span class="comment">//学生编号</span></span><br><span class="line">	string stuName;   <span class="comment">//学生姓名</span></span><br><span class="line">	string roomId;    <span class="comment">//机房编号</span></span><br><span class="line">	string status;    <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//预约记录个数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//测试代码</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		string key;</span><br><span class="line">		string value;</span><br><span class="line">		map&lt;string, string&gt; m;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> pos = date.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = date.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = date.<span class="built_in">substr</span>(pos + <span class="number">1</span>, date.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = interval.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = interval.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = interval.<span class="built_in">substr</span>(pos + <span class="number">1</span>, interval.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = stuId.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = stuId.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = stuId.<span class="built_in">substr</span>(pos + <span class="number">1</span>, stuId.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = stuName.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = stuName.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = stuName.<span class="built_in">substr</span>(pos + <span class="number">1</span>, stuName.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = roomId.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = roomId.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = roomId.<span class="built_in">substr</span>(pos + <span class="number">1</span>, roomId.<span class="built_in">size</span>() - pos <span class="number">-1</span> );</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos = status.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key = status.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">			value = status.<span class="built_in">substr</span>(pos + <span class="number">1</span>, status.<span class="built_in">size</span>() - pos <span class="number">-1</span>);</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_orderData.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试代码</span></span><br><span class="line">	<span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//	for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>更新预约记录的成员函数updateOrder代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_Size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;date&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;interval&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuName&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;roomId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;status&quot;</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-显示自身预约"><a href="#8-3-2-显示自身预约" class="headerlink" title="8.3.2 显示自身预约"></a>8.3.2 显示自身预约</h4><p>首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件</p>
<p>order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215044.png"></p>
<p>在Student类的<code>void Student::showMyOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">atoi</span>(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].<span class="built_in">c_str</span>()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">			string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215102.png"></p>
<h4 id="8-3-3-显示所有预约"><a href="#8-3-3-显示所有预约" class="headerlink" title="8.3.3 显示所有预约"></a>8.3.3 显示所有预约</h4><p>在Student类的<code>void Student::showAllOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">		string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215126.png"></p>
<h3 id="8-4-取消预约"><a href="#8-4-取消预约" class="headerlink" title="8.4 取消预约"></a>8.4 取消预约</h3><p>在Student类的<code>void Student::cancelOrder()</code>成员函数中，添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">atoi</span>(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].<span class="built_in">c_str</span>()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span> || of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				v.<span class="built_in">push_back</span>(i);</span><br><span class="line">				cout &lt;&lt;  index ++  &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">				string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line">				<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入取消的记录,0代表返回&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		<span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//	cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;</span></span><br><span class="line">				of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">				of.<span class="built_in">updateOrder</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;已取消预约&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试取消预约：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215155.png"></p>
<p>再次查看个人预约记录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215223.png"></p>
<p>查看所有预约</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215307.png"></p>
<p>查看order.txt预约文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215324.png"></p>
<p>至此，学生模块功能全部实现</p>
<h2 id="9、-教师模块"><a href="#9、-教师模块" class="headerlink" title="9、 教师模块"></a>9、 教师模块</h2><h3 id="9-1-教师登录和注销"><a href="#9-1-教师登录和注销" class="headerlink" title="9.1 教师登录和注销"></a>9.1 教师登录和注销</h3><h4 id="9-1-1-构造函数"><a href="#9-1-1-构造函数" class="headerlink" title="9.1.1 构造函数"></a>9.1.1 构造函数</h4><ul>
<li>在Teacher类的构造函数中，初始化教师信息，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::<span class="built_in">Teacher</span>(<span class="type">int</span> empId, string name, string pwd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化属性</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-1-2-教师子菜单"><a href="#9-1-2-教师子菜单" class="headerlink" title="9.1.2  教师子菜单"></a>9.1.2  教师子菜单</h4><ul>
<li>在机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口</li>
<li>将不同的分支提供出来<ul>
<li>查看所有预约</li>
<li>审核预约</li>
<li>注销登录</li>
</ul>
</li>
<li>实现注销功能</li>
</ul>
<p>添加全局函数 <code>void TeacherMenu(Person * &amp;manager)</code> 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TeacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//教师菜单</span></span><br><span class="line">		teacher-&gt;<span class="built_in">operMenu</span>();</span><br><span class="line"></span><br><span class="line">		Teacher* tea = (Teacher*)teacher;</span><br><span class="line">		<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//查看所有预约</span></span><br><span class="line">			tea-&gt;<span class="built_in">showAllOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//审核预约</span></span><br><span class="line">			tea-&gt;<span class="built_in">validOrder</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> teacher;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-1-3-菜单功能实现"><a href="#9-1-3-菜单功能实现" class="headerlink" title="9.1.3 菜单功能实现"></a>9.1.3 菜单功能实现</h4><ul>
<li>在实现成员函数<code>void Teacher::operMenu()</code> 代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//教师菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;欢迎教师：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          1.查看所有预约          |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          2.审核预约              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-1-4-接口对接"><a href="#9-1-4-接口对接" class="headerlink" title="9.1.4 接口对接"></a>9.1.4 接口对接</h4><ul>
<li>教师成功登录后，调用教师的子菜单界面</li>
<li>在教师登录分支中，添加代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line"><span class="built_in">TeacherMenu</span>(person);</span><br></pre></td></tr></table></figure>

<p>添加效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215347.png"></p>
<p>测试对接，效果如图：</p>
<p>登录验证通过：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215400.png"></p>
<p>教师子菜单：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215412.png"></p>
<p>注销登录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215428.png"></p>
<h3 id="9-2-查看所有预约"><a href="#9-2-查看所有预约" class="headerlink" title="9.2 查看所有预约"></a>9.2 查看所有预约</h3><h4 id="9-2-1-所有预约功能实现"><a href="#9-2-1-所有预约功能实现" class="headerlink" title="9.2.1 所有预约功能实现"></a>9.2.1 所有预约功能实现</h4><p>该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录</p>
<p>在Teacher.cpp中实现成员函数 <code>void Teacher::showAllOrder()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">		string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-2-测试功能"><a href="#9-2-2-测试功能" class="headerlink" title="9.2.2 测试功能"></a>9.2.2 测试功能</h4><p>运行测试教师身份的查看所有预约功能</p>
<p>测试效果如图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215445.png"></p>
<h3 id="9-3-审核预约"><a href="#9-3-审核预约" class="headerlink" title="9.3 审核预约"></a>9.3 审核预约</h3><h4 id="9-3-1-审核功能实现"><a href="#9-3-1-审核功能实现" class="headerlink" title="9.3.1 审核功能实现"></a>9.3.1 审核功能实现</h4><p>功能描述：教师审核学生的预约，依据实际情况审核预约</p>
<p>在Teacher.cpp中实现成员函数 <code>void Teacher::validOrder()</code></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	OrderFile of;</span><br><span class="line">	<span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;待审核的预约记录如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			v.<span class="built_in">push_back</span>(i);</span><br><span class="line">			cout &lt;&lt; ++index &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line">			string status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line">			<span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入审核的预约记录,0代表返回&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line">		<span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;请输入审核结果&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;1、通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;2、不通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">				cin &gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				of.<span class="built_in">updateOrder</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;审核完毕！&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-测试审核预约"><a href="#9-3-2-测试审核预约" class="headerlink" title="9.3.2 测试审核预约"></a>9.3.2 测试审核预约</h4><p>测试 - 审核通过</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215459.png"></p>
<p>审核通过情况</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215512.png"></p>
<p>测试-审核未通过</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215525.png"></p>
<p>审核未通过情况：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215536.png"></p>
<p>学生身份下查看记录：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200529215547.png"></p>
<p>审核预约成功！</p>
<p>至此本案例制作完毕！  <code>^_^</code></p>
<br />

<br />













<blockquote class="blockquote-center">
<p>《芳树》</p>
<p>芳树千株发，摇荡三阳时。<br>气软来风易，枝繁度鸟迟。<br>春至花如锦，夏近叶成帷。<br>欲寄边城客，路远谁能持。</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion的安装、激活、汉化及编译器配置</title>
    <url>/posts/59155.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424220252.png"></p>
<p>CLion 是 JetBrains 推出的全新的C&#x2F;C++ 跨平台集成开发环境。本文记录关于 CLion 的安装、激活、汉化、编译器配置等操作。</p>
<span id="more"></span>





<h2 id="下载-Clion"><a href="#下载-Clion" class="headerlink" title="下载 Clion"></a>下载 Clion</h2><p>下载地址</p>
<p><a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424225612.png"></p>
<br />

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击安装包，选好安装路径，然后下一步，若你的计算机是 64 位，在这里可以勾选以下这一个选项。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424221950.png"></p>
<p>一路 next 即可，接着启动 CLion 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424222428.png"></p>
<p>主题选择，看个人喜好，然后下一步。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424222648.png"></p>
<br />

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>第一次打开是没有编译器的，如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424223833.png"></p>
<p>因此需要去安装并配置能够进行代码编译的工具，点击下面的 MinGW。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424223940.png"></p>
<p>点击 Download ，跳转到 Mingw-builds 的页面，接着再点击  <a href="http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download">Sourceforge</a> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424224010.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424224059.png"></p>
<p>然后在  <a href="http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download">Sourceforge </a> 中的下载链接，建议下载解压版，<code>.7z</code>那个 ，若你下载不便，可在<a href="https://www.lanzous.com/ibwiafg"><strong>蓝奏云</strong></a>中下载我上传的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424225003.png"></p>
<p>然后解压下载的文件，放到一个你喜欢的路径下面（英文路径）。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200425092323.png"></p>
<p>接着为 CLion 配置编译器，选择刚刚解压的路径即可，其他那些都会自动检测出的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424230641.png"></p>
<p>若你的没有检测出，请根据上图的手动配置相应的 gcc 、g++ 等编译器的路径。</p>
<p>另外，若看到出现对话框中有一个黄色感叹号 ，关于 cmake 错误，请参<a href="https://zhuanlan.zhihu.com/p/43680621">https://zhuanlan.zhihu.com/p/43680621</a>。</p>
<p>配置好后我们可以打开 CLion 试试了。</p>
<p>创建一个新项目：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424231024.png"></p>
<p>然后 Run 一下 ，熟悉的 HelloWorld ，你好世界！</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424231211.png"></p>
<p>调试</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424233324.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424233406.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424233459.png"></p>
<br />

<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>激活请参看：</p>
<p><a href="https://zhile.io/">Jetbrains系列产品2020.1最新激活方法[持续更新]</a></p>
<p><a href="https://masuit.com/1793">通过edu教育邮箱免费获取 JetBrains 全系产品正版 License</a></p>
<p>比如我的是这样激活的：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424223716.png"></p>
<p>若你没有教育邮箱，那可以尝试使用破解的方式，在<a href="https://www.lanzous.com/ibwad9a">蓝奏云</a>下载这个破解文件。根据里面的说明破解即可，如果你有能力推荐支持正版。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用方法:</span><br><span class="line">0. 先下载压缩包解压后得到jetbrains-agent.jar。</span><br><span class="line">   下载页面：https://zhile.io/2018/08/17/jetbrains-license-server-crack.html</span><br><span class="line">1. 启动你的IDE，如果上来就需要注册，选择：试用（Evaluate <span class="keyword">for</span> free）进入IDE。</span><br><span class="line">2. 将 jetbrains-agent.jar 拖进IDE窗口，点 <span class="string">&quot;Restart&quot;</span> 按钮重启IDE。</span><br><span class="line">   （事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题）</span><br><span class="line">3. 在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。</span><br><span class="line">   如果你是无外网环境，在对话框中勾选：我无法访问外网 选项（如银行、公安内网）。</span><br><span class="line">4. 重启IDE，搞定。</span><br><span class="line">x. 支持两种注册方式：License server 和 Activation code:</span><br><span class="line">   1). 选择License server方式，地址填入：http://fls.jetbrains-agent.com （网络不佳的用第2种方式）</span><br><span class="line">   2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活</span><br><span class="line">       如果激活窗口一直弹出（error 1653219），请去hosts文件里“移除”jetbrains相关的项目</span><br><span class="line">       License key is <span class="keyword">in</span> legacy format == Key invalid，表示agent配置未生效。</span><br><span class="line">       如果你需要自定义License name，请访问：https://zhile.io/custom-license.html</span><br><span class="line">   3). 现在你可以使用jetbrains-agent + license server激活jetbrains平台的付费插件了！</span><br><span class="line">       除了：<span class="string">&quot;IEDIS 2&quot;</span> 和 <span class="string">&quot;MINBATIS&quot;</span>，这两个请使用 IEDIS_MINBATIS_CODE.txt 来激活。</span><br><span class="line">       现在有这些付费插件：https://plugins.jetbrains.com/search?isPaid=<span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br />

<h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>安装后打开 CLion ，找到 Setting 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424220726.png"></p>
<center><font size=1.5><center><font size=2.5>找到setting</center> </center>



<p>接在在左侧找到 Plugins , 然后搜索 Chinese ，安装第一个即可，最后点击 OK ，重启 IDE就是中文了。当然有些地方汉化不完整，如果想换回英文只需去禁用刚刚安装那个插件即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424220853.png"></p>
<center><font size=1.5><center><font size=2.5>安装汉化插件</center> </center>





<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424221305.png"></p>
<center><font size=1.5><center><font size=2.5>汉化后</center> </center>





<br />

<h2 id="解决-CLion-中-For-MinGW-make-to-work-correctly-sh-exe-must-NOT-be-in-your-path-的错误"><a href="#解决-CLion-中-For-MinGW-make-to-work-correctly-sh-exe-must-NOT-be-in-your-path-的错误" class="headerlink" title="解决 CLion 中 For MinGW make to work correctly sh.exe must NOT be in your path. 的错误"></a>解决 CLion 中 <code>For MinGW make to work correctly sh.exe must NOT be in your path.</code> 的错误</h2><p>CLion 中报错 For MinGW make to work correctly sh.exe must NOT be in your path. 在 <a href="https://stackoverflow.com/questions/41333215/mingw-sh-exe-must-not-be-in-your-path">stackoverflow</a> 查到了解决方法：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200425092543.png"></p>
<ul>
<li><p>原因：MinGW 与 GIT 中的 sh.exe 冲突，所以在环境变量中不应该有sh.exe（装了git的命令行工具就会有）</p>
</li>
<li><p>解决：在File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; CMake 中为cmake设置参数<code> -DCMAKE_SH=&quot;CMAKE_SH-NOTFOUND&quot;</code></p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424214716.png"></p>
<center><font size=2.5>错误图示 </center>





<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200424215554.png"></p>
<center><font size=1.5><center><font size=2.5>cmake设置参数 -DCMAKE_SH="CMAKE_SH-NOTFOUND"</center> </center>

<p>接着重启即可。</p>
<p>参考：</p>
<blockquote>
<p> <a href="https://stackoverflow.com/questions/41333215/mingw-sh-exe-must-not-be-in-your-path">stackoverflow：MinGW sh.exe must NOT be in your path</a></p>
<p><a href="https://www.jianshu.com/p/3bfcb78af171">Clion 搭建C++环境常见问题</a></p>
</blockquote>
<br />



<blockquote class="blockquote-center">
<p>旅途中的夜晚，景色越是优美，越是会让人感到一种莫名的忧伤。我仰望着夜空，确认将要消失在黑暗里的自己的所在，在表示夏天的星座底下缓缓地走着。<br>    –吉本芭娜娜 《哀愁的预感》</p>

</blockquote>



<p><br /><br /><br /><br /></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitalk重定向错误</title>
    <url>/posts/26908.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200509110429.jpg"></p>
<p>Gitalk重定向错误 ：error&#x3D;redirect_uri_mismatch 。</p>
<span id="more"></span>



<p>在博文下面点击登录 github 进行评论的时候，出现重定向错误 error&#x3D;redirect_uri_mismatch 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200509_101806_1137_331_firefox.png"></p>
<p>比如我的就重定向至</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.lifeee.top/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200509101944.png"></p>
<br/>



<p>解决方法有：</p>
<ul>
<li>确保 OAuth App 里填的 Homepage URL 和 Callback URL 正确</li>
<li>Homepage URL 和 Callback URL 后有 <code>/</code></li>
<li>文章的链接不要带中文和空格</li>
</ul>
<br/>

<p>突然想到在修改博客域名后，未修改Homepage URL和Authorization callback URL 。因此我需要这样做，在</p>
<p><a href="https://github.com/settings/developers">https://github.com/settings/developers</a> 中找到对应的 OAuth Apps ，然后去更改里面的 Homepage URL和Authorization callback URL 即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200509102201.png" alt="找到对应的 Apps"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200509102400.png" alt="原来的 URL"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200509102503.png" alt="更改后"></p>
<p>然后就恢复正常啦</p>
<br/>





<p>更多错误参见 Gitalk 的 issue   <a href="https://github.com/gitalk/gitalk/issues/162">登录报错&#x2F;?error&#x3D;redirect_uri_mismatch&amp; #162</a></p>
<br />

<br/>





<blockquote class="blockquote-center">
<p>浅水是喧哗的，深水是沉默的。</p>
<p>—雪莱</p>

</blockquote>





<br />

<br/>

<br />

]]></content>
      <categories>
        <category>问题</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取 Google 安全码？</title>
    <url>/posts/13004.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200508190508.jpg"></p>
<center><font size=1.5>2020-05-01 云南·瑞丽 </center>

<p>有些时候在一些新设备或者存在安全隐患的场景下登录 Google 账号，会让你确认您的身份。有时候就需要使用安全码来验证，那么如何获取安全码呢 ?</p>
<span id="more"></span>







<p>有些时候在一些新设备或者存在安全隐患的场景下登录 Google 账号，会让你确认您的身份。有时候就需要使用安全码来验证，那么如何获取安全码呢 ?</p>
<p>官方给出的方法是这样的，但是可能对我们国内的手机有些差异。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200508154332.png"></p>
<p>我的手机是 小米 的，使用如下方法 获取 Google 安全码。</p>
<ol>
<li>在 Google Pay 中下载名为 Google 的应用</li>
</ol>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200508172438.png" style="zoom: 33%;" />







<p>2.进入应用后，点击更多。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210521211928.png" style="zoom:33%;" />

 

<p>3.点击邮箱旁边的下三角 🔻，会出现<strong>账号管理</strong>，然后再点击<strong>账号管理</strong>。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210521212358.png" style="zoom:33%;" />

 

<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210521212444.png" style="zoom:33%;" />

 

<p>4.点击安全性，再点击下方的安全码，然后安全码就会出现。出现的安全码十五分钟更新一次。若有多个账号根据自己登录的账号切换即可。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20210521212524.png" style="zoom:33%;" />

<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200508174340.png" style="zoom: 33%;" />

<p>5.将安全码填写到需要登录的应用中。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200508181211.png" style="zoom:33%;" />

<br/>

<div class="note info"><p>题外话 现在 Android 端的邮箱应用 网易的邮箱大师比 QQ 邮箱好用</p>
</div>

<br/>

<br/>

<br/>

<blockquote class="blockquote-center">
<p>世界微尘里，吾宁爱与憎。</p>
<p>——李商隐《北青萝》</p>

</blockquote>



<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>问题</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>离线维基百科Kiwix😎</title>
    <url>/posts/93e477bd.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/wikipedia_mini_globe_handheld.jpg"></h1><p><strong>Kiwix</strong>让您能够随身携带完整的维基百科！无论您搭乘船只，还是身处偏僻的地区，抑或身陷囹圄，Kiwix都使您能够接触到全人类的知识。您不需要连接因特网，因为所有的资料都储存在您的电脑硬盘、U盘或者手机中！</p>
<span id="more"></span>

<h2 id="什么是Kiwix"><a href="#什么是Kiwix" class="headerlink" title="什么是Kiwix"></a>什么是Kiwix</h2><p><strong>Kiwix</strong>是一款离线网页浏览器。它是为维基百科离线化而设计的，但是也潜在地适合所有HTML类型的内容。Kiwix支持<a href="https://www.openzim.org/">ZIM 格式</a>，它是一种高度压缩、附加元数据的开放文档格式。</p>
<p>Kiwix是一款<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由软件</a>，这意味着您可以不受限制地<a href="https://wiki.kiwix.org/wiki/Special:MyLanguage/development">复制、修改和分发它</a>。</p>
<p>Kiwix大多数安装在没有能力使用宽带上网的（中、小）学校、大学以及图书馆。它要比使用因特网快很多，同时也可以为很多机构节省网络的带宽和阅读者的时间。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/kiwix_logo_transparent.png" style="zoom: 25%;" />





<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Kiwix非常容易使用。它有很多便于使用的特性：</p>
<ul>
<li>全文搜索引擎</li>
<li>书签和笔记</li>
<li>HTTP服务器</li>
<li>导出PDF和HTML文档</li>
<li>100多种语言的界面</li>
<li>标签页导航</li>
<li>集成的内容管理与下载</li>
<li><a href="https://wiki.kiwix.org/wiki/Special:MyLanguage/Features">更多特性…</a></li>
</ul>
<h2 id="下载及使用"><a href="#下载及使用" class="headerlink" title="下载及使用"></a>下载及使用</h2><p>要想在本地成功使用上Kiwix  ，需要下载适合您本地平台的阅读软件以及离线的维基百科离线数据包。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/Wikipedia_wordmark.png" style="zoom:25%;" />

<h3 id="下载阅读软件"><a href="#下载阅读软件" class="headerlink" title="下载阅读软件"></a>下载阅读软件</h3><p>关于阅读软件，Windows、mac OS 、Linux 、Android、iOS、Windows phone、Firefox扩展、Chrome扩展等各平台都有，均可在Kiwix的 <strong><a href="http://www.kiwix.org/wiki/Main_Page/zh-cn">网站</a></strong> 中下载，</p>
<p>并且这些软件也是开放源代码的，源代码地址为 <a href="https://github.com/kiwix">https://github.com/kiwix</a> 。</p>
<p>以Windows平台为例，在 <a href="http://www.kiwix.org/downloads/">http://www.kiwix.org/downloads/</a> 下载后，得到一个名称为 <code>kiwix-desktop_windows_x64_2.0-rc4.zip</code>的压缩包， 解压后运行<code>kiwix-desktop.exe</code>即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/image-20200112220809990.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/image-20200112214626606.png"></p>
<p>阅读软件界面如下图，由于没有打开任何离线数据包，因此还什么 也看不到。接下来需要下载离线数据包然后导入其中。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/image-20200112214752257.png"></p>
<h3 id="下载离线维基百科数据包"><a href="#下载离线维基百科数据包" class="headerlink" title="下载离线维基百科数据包"></a>下载离线维基百科数据包</h3><p>在 <a href="https://wiki.kiwix.org/wiki/Content_in_all_languages/zh-cn">https://wiki.kiwix.org/wiki/Content_in_all_languages&#x2F;zh-cn</a> 中，您可以下载各种语言的离线维基百科数据，包含各种类型的数据：历史、数学、计算机等等。您可以根据自己的需求下载不同语言、类别的离线数据包。在下载链接一栏中，一份数据包含两个链接，上方的链接您可以复制到通用的下载器中下载，推荐使用IDM、FDM等多线程下载工具。下方的链接为磁力链接，您可以在迅雷、Xdown等支持BitTorrent协议的下载器中进行下载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/image-20200112215521088.png"></p>
<p>下载完成后您可以得到一个后缀为<code>zim</code>的文件，<a href="https://www.openzim.org/">ZIM 格式</a>是一种高度压缩、附加元数据的开放文档格式。然后将该文件移动至英文路径下，在Kiwix的阅读软件中打开即可开始您的阅读之旅。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/image-20200112221349642.png"></p>
<p><img data-src="https://i.loli.net/2020/01/14/dwNiYqX9eBroRsg.gif" alt="APPUsing20200114.gif"></p>
<p><strong>Kiwix</strong> 允许你在没有互联网连接的条件下，去享受很多种不同的离线文档，这是一个桌面应用程序。另外也有 <a href="https://wiki.kiwix.org/wiki/Special:MyLanguage/kiwix-serve">一个叫做  <em>kiwix-serve</em> 的 HTTP 版本</a>。若您感兴趣，可以去<a href="https://www.kiwix.org/en/downloads/kiwix-serve/">Kiwix的网站</a>中了解。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/picgo/kiwix_visual_512x512.png" style="zoom:25%;" />



<center> End💻 </center>
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>克罗内克积 🍉</title>
    <url>/posts/c267974a.html</url>
    <content><![CDATA[<p>![](<a href="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/2019-10-01">https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/2019-10-01</a> 09.35.09 1112345.jpg) </p>
<center><font size=1.5>20190928-陕西咸阳旬邑 </center>

<p>数学上，<strong>克罗内克积</strong>（Kronecker product）是两个任意大小的矩阵间的运算，表示为⊗ 。克罗内克积是<a href="https://www.wikiwand.com/zh-cn/%E5%A4%96%E7%A7%AF">外积</a>从向量到矩阵的推广，也是<a href="https://www.wikiwand.com/zh-cn/%E5%BC%A0%E9%87%8F%E7%A7%AF">张量积</a>在标准基下的矩阵表示。 本文来自<a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF">维基百科</a>（需科学上网）。</p>
<span id="more"></span>

<blockquote>
<p><a href="https://www.wikiwand.com/zh-cn/%E5%A4%96%E7%A7%AF">外积</a></p>
<p>外积（英语：Outer product），在线性代数中一般指两个向量的张量积，其结果为一矩阵；与外积相对，两向量的内积结果为标量。 外积也可视作是矩阵的克罗内克积的一种特例。</p>
<p><a href="https://www.wikiwand.com/zh-cn/%E5%BC%A0%E9%87%8F%E7%A7%AF">张量积</a></p>
<p>在数学中，张量积，记为  ⊗ ，可以应用于不同的上下文中,如向量、矩阵、张量、向量空间、代数、拓扑向量空间和模。在各种情况下这个符号的意义是同样的:最一般的双线性运算。</p>
</blockquote>
<p>尽管没有明显证据证明德国数学家<a href="https://www.wikiwand.com/zh-cn/%E5%88%A9%E5%A5%A5%E6%B3%A2%E5%BE%B7%C2%B7%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B">利奥波德·克罗内克</a>是第一个定义并使用这一运算的人，<strong>克罗内克积</strong>还是以其名字命名。确实，在历史上，<strong>克罗内克积</strong>曾以Johann Georg Zehfuss名字命名为Zehfuss矩阵。 </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果<em>A</em>是一个 <em>m</em> × <em>n</em> 的矩阵，而<em>B</em>是一个 <em>p</em> × <em>q</em> 的矩阵，<strong>克罗内克积</strong>$A \otimes B$ 则是一个 <em>mp</em> × <em>nq</em> 的<a href="https://www.wikiwand.com/zh-cn/%E5%88%86%E5%A1%8A%E7%9F%A9%E9%99%A3">分块矩阵</a><br>$$<br>A \otimes B&#x3D;\left[\begin{array}{ccc}{a_{11} B} &amp; {\cdots} &amp; {a_{1 n} B} \ {\vdots} &amp; {\ddots} &amp; {\vdots} \ {a_{m 1} B} &amp; {\cdots} &amp; {a_{m n} B}\end{array}\right]<br>$$</p>
<blockquote>
<p><a href="https://www.wikiwand.com/zh-cn/%E5%88%86%E5%A1%8A%E7%9F%A9%E9%99%A3">分块矩阵</a> </p>
<p>在数学的矩阵理论中，一个分块矩阵或是分段矩阵就是将矩阵分割出较小的矩形矩阵，这些较小的矩阵就称为区块。换个方式来说，就是以较小的矩阵组合成一个矩阵。</p>
</blockquote>
<p>更具体地可表示为 </p>
<p><img data-src="https://cdn.mathpix.com/snip/images/4PnYMkK1lPNJG3p4SwsEjfLPID2s_R0uNEmWts2Y1Bc.original.fullsize.png"></p>
<p>我们可以更紧凑地写为 <img data-src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5740426c7e1381c12587ec57d22da1c52e0f4968" alt="{\displaystyle (A\otimes B)_{p(r-1)+v,q(s-1)+w}=a_{rs}b_{vw))"> </p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>$$<br>\left[\begin{array}{ll}{1} &amp; {2} \ {3} &amp; {1}\end{array}\right] \otimes\left[\begin{array}{cc}{0} &amp; {3} \ {2} &amp; {1}\end{array}\right]&#x3D;\left[\begin{array}{llll}{1 \cdot 0} &amp; {1 \cdot 3} &amp; {2 \cdot 0} &amp; {2 \cdot 3} \ {1 \cdot 2} &amp; {1 \cdot 1} &amp; {2 \cdot 2} &amp; {2 \cdot 1} \ {3 \cdot 0} &amp; {3 \cdot 3} &amp; {1 \cdot 0} &amp; {1 \cdot 3} \ {3 \cdot 2} &amp; {3 \cdot 1} &amp; {1 \cdot 2} &amp; {1 \cdot 1}\end{array}\right]&#x3D;\left[\begin{array}{llll}{0} &amp; {3} &amp; {0} &amp; {6} \ {2} &amp; {1} &amp; {4} &amp; {2} \ {0} &amp; {9} &amp; {0} &amp; {3} \ {6} &amp; {3} &amp; {2} &amp; {1}\end{array}\right]<br>$$</p>
<p>$$<br>\left[\begin{array}{ll}{1} &amp; {2} \ {3} &amp; {4}\end{array}\right] \otimes\left[\begin{array}{ll}{0} &amp; {5} \ {6} &amp; {7}\end{array}\right]&#x3D;\left[\begin{array}{lll}{1} &amp; {0} &amp; {5} \ {6} &amp; {7} &amp; {2} \ {3} &amp; {\left[\begin{array}{ll}{0} &amp; {5} \ {6} &amp; {7}\end{array}\right]} &amp; {4\left[\begin{array}{ll}{0} &amp; {5} \ {6} &amp; {7}\end{array}\right]}\end{array}\right]&#x3D;\left[\begin{array}{lllll}{1 \times 0} &amp; {1 \times 5} &amp; {2 \times 0} &amp; {2 \times 5} \ {1 \times 6} &amp; {1 \times 7} &amp; {2 \times 6} &amp; {2 \times 7} \ {3 \times 0} &amp; {3 \times 5} &amp; {4 \times 0} &amp; {4 \times 5} \ {3 \times 6} &amp; {3 \times 7} &amp; {4 \times 6} &amp; {4 \times 7}\end{array}\right]&#x3D;\left[\begin{array}{cccc}{0} &amp; {5} &amp; {0} &amp; {10} \ {6} &amp; {7} &amp; {12} &amp; {14} \ {0} &amp; {15} &amp; {0} &amp; {20} \ {18} &amp; {21} &amp; {24} &amp; {28}\end{array}\right]<br>$$</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="双线性和结合律"><a href="#双线性和结合律" class="headerlink" title="双线性和结合律"></a>双线性和结合律</h3><p><strong>克罗内克积</strong>是<a href="https://www.wikiwand.com/zh-cn/%E5%BC%A0%E9%87%8F%E7%A7%AF">张量积</a>的特殊形式，因此满足<a href="https://www.wikiwand.com/zh-cn/%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84">双线性</a>与<a href="https://www.wikiwand.com/zh-cn/%E7%BB%93%E5%90%88%E5%BE%8B">结合律</a>：<br>$$<br>\begin{array}{l}{A \otimes(B+C)&#x3D;A \otimes B+A \otimes C \quad \text { (if } B \text { and } C \text { have the same size) }} \ {(A+B) \otimes C&#x3D;A \otimes C+B \otimes C \quad \text { (if } A \text { and } B \text { have the same size) }} \ {(k A) \otimes B&#x3D;A \otimes(k B)&#x3D;k(A \otimes B)} \ {(A \otimes B) \otimes C&#x3D;A \otimes(B \otimes C)}\end{array}<br>$$<br>其中，<em>A</em>, <em>B</em> 和 <em>C</em> 是矩阵，而 <em>k</em> 是常量。 </p>
<p><strong>克罗内克积</strong>不符合<a href="https://www.wikiwand.com/zh-cn/%E4%BA%A4%E6%8D%A2%E5%BE%8B">交换律</a>：通常，$A \otimes B$ 不同于 $B \otimes A$ 。  </p>
<p>$A \otimes B$ 和是$B \otimes A$排列等价的，也就是说，存在<a href="https://www.wikiwand.com/zh-cn/%E6%8E%92%E5%88%97%E7%9F%A9%E9%99%A3">排列矩阵</a><em>P</em>和<em>Q</em>，使得<br>$$<br>A \otimes B&#x3D;P(B \otimes A) Q<br>$$<br>如果<em>A</em>和<em>B</em>是方块矩阵，则$A \otimes B$ 和$B \otimes A$甚至是排列<a href="https://www.wikiwand.com/zh-cn/%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%99%A3">相似</a>的，也就是说，我们可以取<em>P</em> &#x3D; <em>Q</em>T。 </p>
<h3 id="混合乘积性质"><a href="#混合乘积性质" class="headerlink" title="混合乘积性质"></a>混合乘积性质</h3><p>如果<strong>A</strong>、<strong>B</strong>、<strong>C</strong>和<strong>D</strong>是四个矩阵，且矩阵乘积<strong>AC</strong>和<strong>BD</strong>存在，那么：<br>$$<br>(\mathbf{A} \otimes \mathbf{B})(\mathbf{C} \otimes \mathbf{D})&#x3D;\mathbf{A} \mathbf{C} \otimes \mathbf{B D}<br>$$<br>这个性质称为“混合乘积性质”，因为它混合了通常的矩阵乘积和克罗内克积。于是可以推出，$A \otimes B$ 是<a href="https://www.wikiwand.com/zh-cn/%E5%8F%AF%E9%80%86%E7%9F%A9%E9%98%B5">可逆</a>的<a href="https://www.wikiwand.com/zh-cn/%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93">当且仅当</a><strong>A</strong>和<strong>B</strong>是可逆的，其逆矩阵为：<br>$$<br>(\mathbf{A} \otimes \mathbf{B})^{-1}&#x3D;\mathbf{A}^{-1} \otimes \mathbf{B}^{-1}<br>$$</p>
<h3 id="克罗内克和"><a href="#克罗内克和" class="headerlink" title="克罗内克和"></a>克罗内克和</h3><p>如果<strong>A</strong>是<em>n</em> × <em>n</em>矩阵，<strong>B</strong>是<em>m</em> × <em>m</em>矩阵，$\mathbf{I}<em>{k}$表示<em>k</em> × <em>k</em>单位矩阵，那么我们可以定义克罗内克和$\otimes $为：<br>$$<br>\mathbf{A} \oplus \mathbf{B}&#x3D;\mathbf{A} \otimes \mathbf{I}</em>{m}+\mathbf{I}_{n} \otimes \mathbf{B}<br>$$</p>
<h3 id="谱"><a href="#谱" class="headerlink" title="谱"></a>谱</h3><p>假设<strong>A</strong>和<strong>B</strong>分别是大小为<em>n</em>和<em>q</em>的方块矩阵。设λ1，……，λ<em>n</em>为<strong>A</strong>的<a href="https://www.wikiwand.com/zh-cn/%E7%89%B9%E5%BE%81%E5%80%BC">特征值</a>，μ1，……，μ<em>q</em>为<strong>B</strong>的特征值。那么$A \otimes B$的特征值为：<br>$$<br>\lambda_{i} \mu_{j}, \quad i&#x3D;1, \ldots, n, j&#x3D;1, \ldots, q<br>$$<br>于是可以推出，两个矩阵的克罗内克积的<a href="https://www.wikiwand.com/zh-cn/%E8%BF%B9">迹</a>和<a href="https://www.wikiwand.com/zh-cn/%E8%A1%8C%E5%88%97%E5%BC%8F">行列式</a>为：<br>$$<br>\operatorname{tr}(\mathbf{A} \otimes \mathbf{B})&#x3D;\operatorname{tr} \mathbf{A} \operatorname{tr} \mathbf{B} \quad \text { and } \quad \operatorname{det}(\mathbf{A} \otimes \mathbf{B})&#x3D;(\operatorname{det} \mathbf{A})^{q}(\operatorname{det} \mathbf{B})^{n}<br>$$</p>
<h3 id="奇异值"><a href="#奇异值" class="headerlink" title="奇异值"></a>奇异值</h3><p>如果<strong>A</strong>和<strong>B</strong>是长方矩阵，那么我们可以考虑它们的<a href="https://www.wikiwand.com/zh-cn/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">奇异值</a>。假设<strong>A</strong>有<em>r</em><strong>A</strong>个非零的奇异值，它们是：<br>$$<br>\sigma_{\mathbf{A}, i}, \quad i&#x3D;1, \dots, r_{\mathbf{A}}<br>$$<br>类似地，设<strong>B</strong>的非零奇异值为：<br>$$<br>\sigma_{\mathbf{B}, i}, \quad i&#x3D;1, \dots, r_{\mathbf{B}}<br>$$<br>那么克罗内克积$A \otimes B$有个$r_{\mathbf{A}} r_{\mathbf{B}}$非零奇异值，它们是：<br>$$<br>\sigma_{\mathbf{A}, i} \sigma_{\mathbf{B}, j}, \quad i&#x3D;1, \ldots, r_{\mathbf{A}}, j&#x3D;1, \ldots, r_{\mathbf{B}}<br>$$<br>由于一个<a href="https://www.wikiwand.com/zh-cn/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9">矩阵的秩</a>等于非零奇异值的数目，因此我们有：<br>$$<br>\operatorname{rank}(\mathbf{A} \otimes \mathbf{B})&#x3D;\operatorname{rank} \mathbf{A} \operatorname{rank} \mathbf{B}<br>$$</p>
<h3 id="与抽象张量积的关系"><a href="#与抽象张量积的关系" class="headerlink" title="与抽象张量积的关系"></a>与抽象张量积的关系</h3><p>矩阵的克罗内克积对应于线性映射的抽象张量积。特别地，如果向量空间<em>V</em>、<em>W</em>、<em>X</em>和<em>Y</em>分别具有基{v1, … , vm}、 {w1, … , wn}、{x1, … , xd}和{y1, … , ye}，且矩阵<em>A</em>和<em>B</em>分别在恰当的基中表示线性变换<em>S</em> : <em>V</em> → <em>X</em>和<em>T</em> : <em>W</em> → <em>Y</em>，那么矩阵<em>A</em> ⊗ <em>B</em>表示两个映射的张量积<em>S</em> ⊗ <em>T</em> : <em>V</em> ⊗ <em>W</em> → <em>X</em> ⊗ <em>Y</em>，关于<em>V</em> ⊗ <em>W</em>的基{v1 ⊗ w1, v1 ⊗ w2, … , v2 ⊗ w1, … , vm ⊗ wn}和<em>X</em> ⊗ <em>Y</em>的类似基。[<a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF#citenote1">1]</a> </p>
<h3 id="与图的乘积的关系"><a href="#与图的乘积的关系" class="headerlink" title="与图的乘积的关系"></a>与图的乘积的关系</h3><p>两个<a href="https://www.wikiwand.com/zh-cn/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">图</a>的<a href="https://www.wikiwand.com/zh-cn/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接矩阵</a>的克罗内克积是它们的张量积图的邻接矩阵。两个图的邻接矩阵的克罗内克和，则是它们的笛卡儿积图的邻接矩阵。参见[<a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF#citenoteTAOCP0a2">2]</a>第96个练习的答案。 </p>
<h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p><strong>克罗内克积</strong>转置运算符合分配律：<br>$$<br>(A \otimes B)^{T}&#x3D;A^{T} \otimes B^{T}<br>$$</p>
<h2 id="矩阵方程"><a href="#矩阵方程" class="headerlink" title="矩阵方程"></a>矩阵方程</h2><p>克罗内克积可以用来为一些矩阵方程得出方便的表示法。例如，考虑方程<em>AXB</em> &#x3D; <em>C</em>，其中<em>A</em>、<em>B</em>和<em>C</em>是给定的矩阵，<em>X</em>是未知的矩阵。我们可以把这个方程重写为 </p>
<p>$$<br>\left(B^{T} \otimes A\right) \operatorname{vec}(X)&#x3D;\operatorname{vec}(A X B)&#x3D;\operatorname{vec}(C)<br>$$<br>这样，从克罗内克积的性质可以推出，方程<em>AXB</em> &#x3D; <em>C</em>具有唯一的解，当且仅当<em>A</em>和<em>B</em>是非奇异矩阵。（<a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF#CITEREFHornJohnson1991">Horn &amp; Johnson 1991</a>，Lemma 4.3.1）. </p>
<p>在这里，vec(<em>X</em>)表示矩阵<em>X</em>的向量化，它是把<em>X</em>的所有列堆起来所形成的<a href="https://www.wikiwand.com/zh-cn/%E5%88%97%E5%90%91%E9%87%8F">列向量</a>。 </p>
<p>如果把<em>X</em>的行堆起来，形成列向量<em>x</em>，则$A X B$也可以写为$\left(A \otimes B^{T}\right) x$（<a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF#CITEREFJain1989">Jain 1989</a>，2.8 block Matrices and Kronecker Products)。 </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><strong>^</strong> Pages 401–402 of Dummit, David S.; Foote, Richard M., Abstract Algebra 2, New York: John Wiley and Sons, Inc., 1999, <a href="https://www.wikiwand.com/zh-cn/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/0-471-36857-1">ISBN 0-471-36857-1</a> </li>
<li><strong>^</strong> D. E. Knuth:  <a href="http://www-cs-faculty.stanford.edu/~knuth/fasc0a.ps.gz">“Pre-Fascicle 0a: Introduction to Combinatorial Algorithms”</a>, zeroth printing (revision 2), to appear as part of D.E. Knuth: <em>The Art of Computer Programming Vol. 4A</em></li>
</ol>
<ul>
<li>Horn, Roger A.; Johnson, Charles R., Topics in Matrix Analysis, Cambridge University Press, 1991, <a href="https://www.wikiwand.com/zh-cn/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/0-521-46713-6">ISBN 0-521-46713-6</a>.</li>
<li>Jain, Anil K., Fundamentals of Digital Image Processing, Prentice Hall, 1989, <a href="https://www.wikiwand.com/zh-cn/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/0-13-336165-9">ISBN 0-13-336165-9</a>.</li>
<li><a href="https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF">https://www.wikiwand.com/zh-cn/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF</a></li>
<li><a href="https://www.wikiwand.com/en/Kronecker_product">https://www.wikiwand.com/en/Kronecker_product</a></li>
<li><a href="https://www.wikiwand.com/en/Roger_Horn">Horn, Roger A.</a>; <a href="https://www.wikiwand.com/en/Charles_R._Johnson">Johnson, Charles R.</a> (1991), [*Topics in Matrix Analysis*](<a href="https://books.google.com/?id=LeuNXB2bl5EC&printsec=frontcover&dq=isbn:9780521467131#v=onepage&q=%22Kronecker">https://books.google.com/?id=LeuNXB2bl5EC&amp;printsec=frontcover&amp;dq=isbn:9780521467131#v=onepage&amp;q=&quot;Kronecker</a> product”&amp;f&#x3D;false), Cambridge University Press, <a href="https://www.wikiwand.com/en/International_Standard_Book_Number">ISBN</a> <a href="https://www.wikiwand.com/en/Special:BookSources/978-0-521-46713-1">978-0-521-46713-1</a>.</li>
<li>Jain, Anil K. (1989), <a href="https://books.google.com/?id=GANSAAAAMAAJ&dq=isbn:9780133361650&q=%22Kronecker+product%22"><em>Fundamentals of Digital Image Processing</em></a>, Prentice Hall, <a href="https://www.wikiwand.com/en/International_Standard_Book_Number">ISBN</a> <a href="https://www.wikiwand.com/en/Special:BookSources/978-0-13-336165-0">978-0-13-336165-0</a>.</li>
<li>Steeb, Willi-Hans (1997), <em>Matrix Calculus and Kronecker Product with Applications and C++ Programs</em>, World Scientific Publishing, <a href="https://www.wikiwand.com/en/International_Standard_Book_Number">ISBN</a> <a href="https://www.wikiwand.com/en/Special:BookSources/978-981-02-3241-2">978-981-02-3241-2</a></li>
<li>Steeb, Willi-Hans (2006), [*Problems and Solutions in Introductory and Advanced Matrix Calculus*](<a href="https://books.google.com/?id=CSDbVU1Eg3UC&printsec=frontcover&dq=isbn:9789812569165#v=onepage&q=%22Kronecker">https://books.google.com/?id=CSDbVU1Eg3UC&amp;printsec=frontcover&amp;dq=isbn:9789812569165#v=onepage&amp;q=&quot;Kronecker</a> product”&amp;f&#x3D;false), World Scientific Publishing, <a href="https://www.wikiwand.com/en/International_Standard_Book_Number">ISBN</a> <a href="https://www.wikiwand.com/en/Special:BookSources/978-981-256-916-5">978-981-256-916-5</a></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Netlify设置重定向实现域名跳转</title>
    <url>/posts/61927.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200507182237.jpg"></p>
<center><font size=1>Thank you Pixabay for sharing this awesome photo on @pexels for free! 🎁 https://www.pexels.com/zh-cn/photo/163452/ </center>

<p>将 Netlify 设置重定向实现域名跳转，将Netlify 给的 <a href="https://summerblog.netlify.app/">默认域名</a> 跳转到自己 <a href="https://www.lifeee.top/">现在的域名</a> 。</p>
<span id="more"></span>



<p><a href="https://app.netlify.com/">Netlify</a> 提供重定向充能，因此可以将 Netlify 给的<a href="https://summerblog.netlify.app/">默认域名</a>跳转到自己<a href="https://www.lifeee.top/">现在的域名</a>，若一些博文的链接结构发生了变化也可以实现重定向。操作方法如下：</p>
<p> 在博客根目录中的 <code>souce</code> 文件件下新建 <code>netlify.toml</code> 文件</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200507_180009_949_511_Clover.png"></p>
<p>在文件里面填写以下内容可实现域名跳转</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[redirects]]</span><br><span class="line">  from = <span class="string">&quot;https://summerblog.netlify.app/*&quot;</span></span><br><span class="line">  to = <span class="string">&quot;https://www.lifeee.top/:splat&quot;</span></span><br><span class="line">  force = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<br />

<br />

<p><strong>Netlify 重定向配置文件的语法</strong></p>
<p>如果在Netlify 配置文件中指定重定向规则，则可以使用具有附加功能 如签名代理重定向的更结构化的配置格式。在文件中，我们使用<a href="https://github.com/toml-lang/toml#user-content-array-of-tables">TOML 的表数组</a>来指定每个单独的重定向规则。提供以下关键字：<code>netlify.toml</code></p>
<ul>
<li><code>from</code>：要重定向的路径。</li>
<li><code>to</code>：要重定向到的 URL 或路径。</li>
<li><code>status</code>：要在重定向中使用<a href="https://docs.netlify.com/routing/redirects/redirect-options/#http-status-codes">HTTP 状态代码</a>; 默认情况下。<code>301</code></li>
<li><code>force</code>：是否覆盖路径中的任何现有内容; 默认情况下。<code>false</code></li>
<li><code>query</code>：查询字符串参数需要匹配重定向。有关详细信息，请访问<a href="https://docs.netlify.com/routing/redirects/redirect-options/#query-parameters">查询参数</a>说明。</li>
<li><code>conditions</code>：匹配重定向的条件，如<a href="https://docs.netlify.com/routing/redirects/redirect-options/#redirect-by-country-or-language">国家&#x2F;地区</a>和<a href="https://docs.netlify.com/routing/redirects/redirect-options/#redirect-by-role">角色</a>条件。</li>
<li><code>headers</code>：其他请求标头以代理<a href="https://docs.netlify.com/routing/redirects/rewrites-proxies/#custom-headers-in-proxy-redirects">重定向</a>发送。</li>
<li><code>signed</code>：<a href="https://docs.netlify.com/routing/redirects/rewrites-proxies/#signed-proxy-redirects">签名代理重定向</a>的环境变量的名称。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200507_180912_1001_663_msedge.png"></p>
<p>更多用法可以在 Netlify 的<a href="https://docs.netlify.com/routing/redirects/#syntax-for-the-redirects-file">用户文档</a>中查看。</p>
<br />



<center> 😄 <center/>

<br />

<br />



<blockquote class="blockquote-center">
<p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p>
<p>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。</p>
<p>—— 苏轼《定风波》</p>

</blockquote>

<br />

<br />

<br />

<br />

]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF-XChange Editor配置适合阅读的背景色</title>
    <url>/posts/24242.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513161628.jpg"></p>
<center><font size=1>from pixabay </center>

<p>配置 PDF Xchange Editor 的阅读背景以及窗体颜色。文末附破解版 PDF Xchange Editor 的下载。</p>
<span id="more"></span>

<h2 id="PDF-Xchange-Editor"><a href="#PDF-Xchange-Editor" class="headerlink" title="PDF Xchange Editor"></a>PDF Xchange Editor</h2><p>PDF-XChange Editor 是一款能够比拟 Adobe Acrobat DC 的 PDF 编辑器。与其它的 PDF 阅读器、查看器和编辑器相比，其体积更小但功能更加丰富。<a href="https://www.tracker-software.com/product/pdf-xchange-editor">PDF-XChange Editor</a> 的免费版是 <a href="https://www.tracker-software.com/product/pdf-xchange-viewer">PDF-XChange Viewer</a> 。</p>
<p><strong>版本区别</strong></p>
<p>pdf xchange viewer：主要用来进行PDF电子文档的阅读。具有多标签页显示、强大的图像导出功能、批量搜索、高级搜索、放大与导航功能，还有<strong>批注</strong>功能让人眼前一亮。支持谷歌金山词霸和灵格斯词霸的取词。</p>
<p>pdf xchange editor：相当于 pdf xchange viewer 的加强版。专注于PDF电子文档的编辑功能，小编试用后发现它体积小巧，速度飞快，界面友好，具备丰富的配置和功能选项，而且非常简单易用！可帮助你快速地制作和编写PDF电子文档。</p>
<p>平时使用 PDF-XChange Editor  的主要原因是我有<strong>注释</strong>的需求，有时候需要在 PDF 上面写写画画。经过这个假期的体验，使用<strong>数位板</strong>进行注释时选择 PDF-XChange Editor 的体验是最佳的。其它的  Adobe Acrobat DC 、福昕等等使用起来都并不是很方便。另外 PDF-XChange Editor 可以自定义很多东西，根据自己的习惯去配置以方便阅读及注释。</p>
<br />

<h2 id="配置背景色-展示"><a href="#配置背景色-展示" class="headerlink" title="配置背景色-展示"></a>配置背景色-展示</h2><p>配置前，窗体以及阅读区都是大块白色。长时间阅读容易引起眼睛不适。让我来稍微调节一下吧。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25gy1geqnlpflh9j21he0t0wv1.jpg" alt="配置前"></p>
<p>我的配置中阅读区是偏纸张的颜色，窗口的上方的颜色偏灰白，左侧的目录区偏水色。</p>
<p>效果展示如下：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513112408.png" alt="配置后"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513113521.png" alt="配置后"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513113623.png" alt="全屏单页"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25gy1geqo5y2tixj21i00uo7wh.jpg" alt="全屏双页"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513141806.png" alt="局部示例"></p>
<br />

<p>颜色主要是参考 <a href="https://color.uisdc.com/">中国传统色</a> ，建议选取 花白、老银、水色、苍色等颜色来搭配，这样的颜色饱和度低看起来很舒适，适合长时间阅读。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25gy1geqo03sxe6j20m70o2gmz.jpg" alt="值得推荐的配色"></p>
<blockquote>
<p>配色网站：</p>
<p><a href="https://color.uisdc.com/">https://color.uisdc.com/</a></p>
<p><a href="http://zhongguose.com/">http://zhongguose.com/</a></p>
<p><a href="https://colors.ichuantong.cn/">https://colors.ichuantong.cn/</a></p>
<p><a href="https://coolfishstudio.github.io/cfs-color/">https://coolfishstudio.github.io/cfs-color/</a></p>
</blockquote>
<br />

<h2 id="配置背景色-配置"><a href="#配置背景色-配置" class="headerlink" title="配置背景色-配置"></a>配置背景色-配置</h2><p>在 PDF-XChange Editor ： 帮助 -&gt; 自定义主题 -&gt; 自定义UI ，可以调整窗口的颜色。我的前景色的 RGB 为 <code>117, 135, 138</code> ，窗口的 RGB 为 <code>187, 205, 197</code> ，可以当作参考。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513110447.png"></p>
<p>然后切换至 <code>访问</code> ，勾选忽略文档颜色，调整页面背景色的 RGB 为 <code>210, 198, 178</code> 。这样就和纸张的颜色差不多了，若你喜欢浅绿色护眼，可以尝试更改 RGB 为 <code>200, 237, 204</code>  。喜欢灰色的话可以尝试更改为<code>192, 192, 192</code> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513141533.png"></p>
<p>PDF Xchange Editor 与 PDF Xchange viewer 稍有不同，但是大同小异。若你使用的是  PDF Xchange viewer 配置与之类似。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200513123621.png" alt="PDF Xchange viewer 配置步骤"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200525084007.png"></p>
<br />

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载链接： <a href="https://www.tracker-software.com/product/downloads/enduser/pdf-xchange-editor">https://www.tracker-software.com/product/downloads/enduser/pdf-xchange-editor</a></p>
<p>可以在以下云盘下载我使用的破解版 :</p>
<p>天翼云：<a href="https://cloud.189.cn/t/RFzMv2ziuiUf">https://cloud.189.cn/t/RFzMv2ziuiUf</a> (访问码:8u5n)</p>
<p><a href="https://pmjs-my.sharepoint.com/:f:/g/personal/world_my365_tw/ElQyl66hPlhEm6PRmJkpOXwBAnMC9yaBuOSoJqg7fcKeGg?e=Ws3eX2">OneDrive</a></p>
<p><a href="https://quqi.gblhgk.com/s/3339409/WxjwD6ivvsOhI5JU">曲奇云盘</a></p>
<p><a href="https://drive.google.com/drive/folders/1iJuKTqJcRR8NpkZvrFeghn1Eu7eaFfah?usp=sharing">Google Drive</a></p>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>腹有诗书气自华，读书万卷始通神。</p>
<p>——苏轼</p>

</blockquote>

<br />

<br />

<br />

]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;span style=&quot;color:#5bdaed; &quot;&gt;使用SciHub下载论文&lt;/span&gt;</title>
    <url>/posts/30773.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/book-chapter-six-58341.jpg"></p>
<center><font size=1.5>  From Pexels</center>



<p><font  color=green size=7>若</font>你烦恼于论文下载繁琐的操作，那么你应该了解一下这篇文章。一般我们下载论文都是打开学校图书馆网页，访问第三方数据库，机构号登录，然后下载。尤其是你不处于校园网环境下那就更麻烦啦，还得使用代理接入校园网。而Sci-Hub 就是来拯救你的，原来下载论文这么轻松。</p>
<blockquote>
<p>To remove all barriers in the way of science – Sci-Hub</p>
</blockquote>
<span id="more"></span>





<h2 id="What-is-SciHub"><a href="#What-is-SciHub" class="headerlink" title="What is SciHub?"></a>What is SciHub?</h2><blockquote>
<p>Sci.Hub is a site to download reference papers and journal articles for free. Just paste the DOI of the journal article you want, and ScienceHub will fetch the PDF for you for free.<br>The site provices free access to journal articles and academic journals. If your goal is to access knowledge, these sci-hub mirrors are for you.</p>
</blockquote>
<h2 id="Sci-Hub-访问地址"><a href="#Sci-Hub-访问地址" class="headerlink" title="Sci Hub 访问地址"></a>Sci Hub 访问地址</h2><p>目前可在以下网站访问 Sci Hub</p>
<table>
<thead>
<tr>
<th align="left">网址</th>
<th align="left">是否可用</th>
<th align="left">测试时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://sci-hub.tw/">http://sci-hub.tw</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left"><a href="http://sci-hub.se/">http://sci-hub.se</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left"><a href="http://sci-hub.im/">http://sci-hub.im</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left"><a href="http://sci-hub.mu/">http://sci-hub.mu/</a></td>
<td align="left">×</td>
<td align="left">20200504</td>
</tr>
<tr>
<td align="left"><a href="https://sci-hub.ren/">https://sci-hub.ren/</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left"><a href="https://sci-hub.shop/">https://sci-hub.shop/</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left"><a href="https://sci-hub.st/">https://sci-hub.st/</a></td>
<td align="left">√</td>
<td align="left">20200611</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>复制论文的 URL 或者 DOI 粘贴进去 ，然后 Open 即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_101716_1853_905_firefox.jpg"></p>
<p>也有人开发了 Sci-Hub 桌面版 ，请在 <a href="https://www.appinn.com/sci-hub/">小众软件</a> 或 <a href="https://zhuanlan.zhihu.com/p/31809890">知乎</a> 查看</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25gy1geg6hskesnj20it0cbgmh.jpg"></p>
<p>Book download:</p>
<p><a href="http://gen.lib.rus.ec/">http://gen.lib.rus.ec/</a></p>
<blockquote>
<p>Library Genesis是一个包含超过200万(是的，百万)免费论文、文章、完整期刊和非小说类书籍的数据库。 他们也有漫画、小说和许多非英语语言的书籍。</p>
</blockquote>
<p>以后有空我再整理一份好用的电子书下载网站，敬请期待 😁</p>
<h2 id="浏览器脚本–更快捷的下载方式"><a href="#浏览器脚本–更快捷的下载方式" class="headerlink" title="浏览器脚本–更快捷的下载方式"></a>浏览器脚本–更快捷的下载方式</h2><p>推荐在浏览器中安装 <a href="https://violentmonkey.github.io/">暴力猴</a> ，常用的 Firefox 、Chrome 、Edge 等都支持。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_092250_1172_649_msedge.png"></p>
<p>下载好暴力猴后，在 <a href="https://greasyfork.org/zh-CN/scripts/370246-sci-hub-button">greasyfork</a> 中安装 <a href="https://greasyfork.org/zh-CN/scripts/370246-sci-hub-button">Sci-hub button</a> 脚本即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_092559_1354_846_chrome.png"></p>
<p>然后当你搜索论文时，就会在论文名字或者 DOI 码旁边多一个下载按钮，点击后就跳转到了 SciHub 的网站中了，保存你需要的论文即可。一切就是这么轻松、便捷，丝滑顺畅。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_093155_1340_684_chrome.png"></p>
<center><font size=2.5> Google Scholar 示意</center>



<br />



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_093617_1920_915_chrome.png"></p>
<center><font size=2.5> ieeexplore 示意</center>

<br />



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_093939_1920_915_chrome.png" alt="ShareX_20200504_093939_1920_915_chrome.png"></p>
<center><font size=2.5> 下载 示意</center>

<h2 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h2><p>若在使用脚本 <code>Sci-hub button</code>时，出现一些错误。请按如下方法去更新脚本中的下载站点：</p>
<p>首先在本文第一节 [Sci Hub 访问地址](#Sci Hub 访问地址) 中随便选一个网址，确保能够正常访问。</p>
<br />

<p>然后在浏览器中中找到暴力猴脚本，点击小齿轮，打开控制台。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200604163526.png"></p>
<p>找到  <code>Sci-hub button</code> 脚本，点击编辑。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200604163631.png"></p>
<p>然后更改 <code>sciHubBaseUrl </code> 那里的网址即可，比如将原来不能访问的 <code>https://sci-hub.tw</code> ，更改为 <code>https://sci-hub.se</code> 即可。</p>
<p>然后保存并关闭。去下载论文的页面刷新一下，尽情去下载吧。 😉 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200604163817.png" alt="更改网址"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200604164126.png" alt="保存并关闭"></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>更多关于 Sci-Hub 的咨询可以访问 Sci-Hub 的 <a href="https://twitter.com/sci_hub">Twitter</a> 了解</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200504_090643_799_913_msedge.png"></p>
<br />

<br />

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=530995517&auto=0&height=66"></iframe>



<p>🎵</p>
<br />

<br />

<br />

<br />









<blockquote class="blockquote-center">
<p>山高自有客行路，水深自有渡船人。</p>
<p>——《西游记》</p>

</blockquote>



<br />

<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 2019配置qt开发环境</title>
    <url>/posts/20536.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317231926.jpg"></p>
<p>宇宙第一IDE Visual Studio 配置 Qt 开发环境 😉</p>
<span id="more"></span>

<h2 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h2><p>下载安装包路径：<a href="http://download.qt.io/archive/qt/">http://download.qt.io/archive/qt/</a></p>
<p>更建议在清华大学开源软件镜像站 Tuna 中下载 ，国内更快哦 。<a href="https://mirrors.tuna.tsinghua.edu.cn/#">https://mirrors.tuna.tsinghua.edu.cn/#</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317222730.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317222901.png"></p>
<p>安装时安装到英文路径下即可。选择编译组件的时候我是选择了 mingw_32 、mingw_64 以及 msvc2017_64 。MinGW 是 Manimalist GNU for windows 的缩写，MinGW 是 Windows 平台上使用的 GNU 工具集导入库的集合，可以把它理解为编译器。MSVC 则是用于Windows平台上的编译器模块。</p>
<h2 id="下载-qt-插件"><a href="#下载-qt-插件" class="headerlink" title="下载 qt 插件"></a>下载 qt 插件</h2><p>打开 Visual Studio ，在拓展-&gt;管理拓展-&gt;联机-&gt;搜索 qt ，然后下载.下载完毕后关闭 VS ，此时弹出安装界面，选择安装即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317223131.png"></p>
<p>若出现下图的情况，点击 <code>End Tasks</code> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317222106.png"></p>
<p>安装完毕后点击 <code>Close</code> ，打开 VS即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317223225.png"></p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装完成后，打开 VS。在拓展-&gt;Qt VS Tools-&gt;Qt Options，点击 ADD ，选择相应的路径，然后就会出现版本的名称，名称也可自行修改。但名称应该起的有意义，比如 msvc2017_64 。配置过程见下方图示：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317223518.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317223938.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317224048.png"></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 VS 中创建项目 ，搜索 qt ，然后创建 Qt GUI Application 项目。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230218.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230420.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230458.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230526.png"></p>
<p>创建成功后可以看见下图</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230625.png"></p>
<p>点击 <code>QtGui_HelloWorld.ui</code> 会打开 Qt 设计师。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230714.png"></p>
<p>在里面放一个 Label ，然后保存。在 VS 里面运行试试看。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317230944.png" style="zoom: 50%;" />



<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317231135.png" style="zoom:67%;" />



<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200317231214.png" style="zoom:67%;" />



<p>Have Fun ！ 😎</p>
<hr>
<p>20200729：</p>
<h2 id="解决无法【转到定义】"><a href="#解决无法【转到定义】" class="headerlink" title="解决无法【转到定义】"></a>解决无法【转到定义】</h2><p>当在 VS 中想看 Qt 中的一些东西的时候，在VS中右键–&gt;转到定 义，直接提示“未定义的符号”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/image-20200729151039243.png" alt="image-20200729151039243"></p>
<p>解决方法很简单。</p>
<p>1.右键点击项目选择属性</p>
<p>2.VC++目录-&gt;包含目录</p>
<p>3.添加QT的include目录</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh7v8ty0ykj21bf1ckwnw.jpg"></p>
<p>然后在 VS 中右击，速览定义、转到定义等等都可用了，鼠标直到变量或类上面也会有提示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/c55aab25ly1gh7va752u2j21610lk792.jpg"></p>
<br/>

<br/>

<br/>

<blockquote class="blockquote-center">
<p>人类从历史学到的唯一的教训，就是人类没有从历史中吸取任何教训。</p>
<p>​    –黑格尔</p>

</blockquote>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Vivado2018安装教程</title>
    <url>/posts/a0d208fb.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_14.png"></p>
<p>本文介绍了如何安装Vivado2018💻</p>
<span id="more"></span>

<h2 id="软件下载："><a href="#软件下载：" class="headerlink" title="软件下载："></a>软件下载：</h2><p>登录其<a href="%5B*https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools.html">官方网站</a>,找到需要下载的文件；</p>
<p>官网链接如下：</p>
<p><a href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools.html"><em>https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools.html</em></a></p>
<p>或者直接百度找网盘里面的资源；（也可以只用来下载License）;</p>
<p>下载下来就选择安装;</p>
<p> </p>
<p> 常见的百度网盘资源搜索网站如下，自己动手丰衣足食</p>
<table>
<thead>
<tr>
<th><a href="https://www.yunpanjingling.com/">云盘精灵</a></th>
<th><a href="https://www.quzhuanpan.com/">去转盘</a></th>
<th><a href="https://www.h2ero.com/">咕咕云搜索</a></th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.pansoso.com/">盘搜搜</a></td>
<td><a href="http://www.rufengso.net/">闪电云</a></td>
<td><a href="http://www.panduoduo.top/">盘多多</a></td>
</tr>
<tr>
<td><a href="https://www.xiaobaipan.com/">小白盘</a></td>
<td><a href="https://www.xiaoso.net/">小不点搜索</a></td>
<td><a href="http://www.slimego.cn/">史莱姆</a></td>
</tr>
</tbody></table>
<p> <strong><a href="https://greasyfork.org/zh-CN/scripts/375337-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E8%81%9A%E5%90%88">百度网盘资源搜索引擎聚合</a></strong></p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>点击“xsetup”进行安装；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_1.png"></p>
<p>开始界面；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_2.png"></p>
<p>不更新，点击“Continue”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_3.png"></p>
<p>点击“Next”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_4.png"></p>
<p>勾选“I Agree”,点击“Next”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_5.png"></p>
<p>勾选“Vivado HL System Edition ”,点击“Next”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_6.png"></p>
<p>Vivado HL Design Edition与 Vivado HL System Edition 对比：</p>
<p><strong>Vivado HL Design Edition</strong> includes the full complement of Vivado Design Suite tools for design, including C-based design with Vivado High-Level Synthesis, implementation, verification and device programming. Complete device support, cable drivers and Documentation Navigator are included. Users can optionally add Model Composer to this installation.</p>
<p>译文：Vivado HL Design Edition包括用于设计的Vivado Design Suite工具的完整补充，包括具有Vivado高级综合，实现，验证和设备编程的基于C的设计。 包括完整的设备支持，电缆驱动程序和Documentation Navigator。 用户可以选择将Model Composer添加到此安装中。</p>
<p> </p>
<p><strong>Vivado HL System Edition</strong> is a superset of Vivado HL Design Edition with the addition of System Generator for DSP. Complete device support, cable drivers and Documentation Navigator are included. Users can optionally add Model Composer to this installation.</p>
<p>译文：<strong>Vivado HL System Edition是Vivado HL Design Edition的超集</strong>，其中增加了System Generator for DSP。 包括完整的设备支持，电缆驱动程序和Documentation Navigator。 用户可以选择将Model Composer添加到此安装中。</p>
<p> </p>
<p>选择默认设置；分别为安装工具，支持的芯片系列，安装选项；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_7.png"></p>
<p>选择安装路径；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_8.png"></p>
<p>创建安装目录；点击“Yes”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_9.png"></p>
<p>查看安装信息；点击“Install”</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_10.png"></p>
<p>开始安装；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_11.png"></p>
<p>安装过程；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_12.png"></p>
<p> </p>
<p>加载License，继续安装：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_13.png"></p>
<p> </p>
<p>文件安装完成；这一步之后会弹出其他的窗口</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_14.png"></p>
<p> </p>
<p> </p>
<p>安装成功；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_15.png"></p>
<p> </p>
<h2 id="中间安装过程中弹出其他窗口："><a href="#中间安装过程中弹出其他窗口：" class="headerlink" title="中间安装过程中弹出其他窗口："></a>中间安装过程中弹出其他窗口：</h2><h3 id="一、安装WinPcap"><a href="#一、安装WinPcap" class="headerlink" title="一、安装WinPcap"></a>一、安装WinPcap</h3><p>弹出安装WinPcap的窗口：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_16.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_17.png"></p>
<p> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_18.png"></p>
<p> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_19.png"></p>
<p>如果之前已经安装过WinPcap，会出现已经安装过的提示；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_20.png"></p>
<h3 id="二、加载Licence"><a href="#二、加载Licence" class="headerlink" title="二、加载Licence"></a>二、加载Licence</h3><p>点击“Load Licence”,文件名为“vivado.lic”；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_21.png"></p>
<p>Licence安装成功；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_22.png"></p>
<p> </p>
<p>二、为系统选择匹配的Matlab版本安装，点击OK；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_23.png"></p>
<p> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202001/20200107_24.png"></p>
<p> </p>
<p>此时整个安装过程结束；</p>
<p>可以寻找一些Demo来实践啦！</p>
<p> </p>
<blockquote>
<p>本文来自实验室同学 <a href="https://weibo.com/u/5733142591">@WanTwoWan</a> ，在此表示感谢👏</p>
</blockquote>
<p> </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows右键菜单添加以VS Code打开🍻</title>
    <url>/posts/84152447.html</url>
    <content><![CDATA[<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/87ba7e99b2b1a4aea40278f8338822c7.jpg"  />

<p>目的：</p>
<p>右键单击文件夹，可以使用以vscode打开</p>
<p>右键单文件或者空白处，可以使用vscode打开</p>
<span id="more"></span>

<p>更改右键菜单的本质都是去更改注册表，网络上可以搜索到很多更改注册表的方法，当然也有拥有图形化界面的小工具能够实现其功能。比如 软媒魔方中的软媒设置大师👇</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/%E8%BD%AF%E5%AA%92%E8%AE%BE%E7%BD%AE.jpg" style="zoom:80%;" />

<p>或者右键菜单管理工具<a href="http://www.carrotchou.blog/13535.html"> Right Click Enhancer Professional v4.5.5 </a>👇</p>
 <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/RightClickEnhancerProfessional2019-09-14_21-33-44.jpg" style="zoom:80%;" />



<p>还有RightMenuMgr 一款强大的右键菜单管理工具 👇</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/RightMenuMgr_2019-09-14_21-40.jpg"></p>
<p>其提供“文件”、“文件夹”、“磁盘”等几乎所有地方的右键菜单管理， <strong>RightMenuMgr</strong> 附加提供了 IE 右键菜单管理。并且 <strong>RightMenuMgr</strong> 还允许你自己添加自定义右键菜单，十分之方便！感觉它的条目比较清晰，文件、文件夹等都分类了，所以今天我选择使用它来更改我的右键菜单。下载地址在：<a href="https://d.appinn.com/rightmenumgr/"><strong>小众软件</strong></a></p>
<p>​	首先，选择左边的文件夹，然后右边就出现了很多已有的快捷菜单条目了，此时在右边的空白出右击，选择增加扩展项，然后在其中菜单名称与执行的命令即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/20190915211805.png"></p>
<p>在VS Code打开文件夹时显示的名称，执行的命令为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;D:\20190113\AboutStudy\\Microsoft VS Code\\Code.exe&quot;</span> <span class="string">&quot;%V&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中第一个参数是我软件的安装路径，选择你自己的替换即可，第二个参数<code>&quot;%V&quot;</code>实现的效果其实就是把此文件夹的路径传入VS Code中，不用改。</p>
<p>然后，在任意一个文件夹上右击就会出现在VS Code中打开的快捷菜单了</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/15684706701800.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/openwithvscode3.gif"></p>
<hr>
<p>同理，要打开文件的话就在软件的左边选择所以文件，然后同样增加一个扩展项就行了，只不过将命令行改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;D:\20190113\AboutStudy\Microsoft VS Code\Code.exe&quot;</span> <span class="string">&quot;%1&quot;</span></span><br></pre></td></tr></table></figure>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/1568470870224.png"></p>
<p>这样就能将选中的文件在VS Code中打开了</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/OpenFIle.gif"></p>
<p>如果你需要将其他软件的快捷方式添加到右键菜单中，使用上述方法，更改软件路径即可 😁</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Filename too long in Git for Windows</title>
    <url>/posts/18897.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/board-boardwalk-bridge-close-up-421759s.jpg"></p>
<p>解决 <code>Filename too long</code> 错误。</p>
<span id="more"></span>



<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 Windows 平台下使用 git ，有时候会遇上 <code> Filename too long</code> 的错误。其实 Git 的文件名是限制为4096个字符。而在 Windows API 中 ，路径的<a href="https://docs.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#maxpath">最大长度</a>为260个字符。所以Git的Windows客户端默认是禁用长名称支持的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200517_161256_1106_745_firefox.png" alt="微软文档"></p>
<br />

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.longpaths true</span><br></pre></td></tr></table></figure>

<p>其中 -–global 为该参数的使用范围，表示全局的。若只想对本版本库设置该参数，可去掉 -–global</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200517_163329_802_322_ConEmu64.png" alt="解决方法"></p>
<br />

<p>参考：</p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#maxpath">docs.microsoft.com</a></p>
<p><a href="https://stackoverflow.com/questions/22575662/filename-too-long-in-git-for-windows">stackoverflow</a></p>
</blockquote>
<br />

<br />


]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>问题</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows平台下使用 Rclone 挂载 OneDrive 为本地硬盘</title>
    <url>/posts/14654.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200502230457.png"></p>
<p>Rclone (rsync for cloud storage) 是一个命令行程序,用于同步文件和目录，支持常见的 Amazon Drive 、Google Drive 、OneDrive 、Dropbox 等云存储。本文将演示在 Windows 平台下将 OneDrive 挂载为本地硬盘，并使用跨平台的 Rclone GUI 连接到云盘。</p>
<span id="more"></span>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/68747470733a2f2f72636c6f6e652e6f72672f696d672f6c6f676f5f6f6e5f6c696768745f5f686f72697a6f6e74616c5f636f6c6f722e737667.svg"></p>
<h3 id="1、rclone下载地址"><a href="#1、rclone下载地址" class="headerlink" title="1、rclone下载地址"></a><strong>1、rclone下载地址</strong></h3><p>首先下载适用于 Windows 的 rclone 👇</p>
<p>官网下载：<a href="https://rclone.org/downloads/">https://rclone.org/downloads/</a><br>        GitHub下载：<a href="https://github.com/ncw/rclone">https://github.com/ncw/rclone</a>  </p>
<p>在<a href="https://rclone.org/downloads/">rclone官网</a>中，Windows 平台下选择下载 AMD64 - 64 Bit</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210092619.png"></p>
<p>或者在<a href="https://github.com/rclone/rclone/releases">github</a>下载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211120423.png"></p>
<p>下载后解压到一个英文路径中。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/image-20200210093613457.png"></p>
<p>另外在Windows平台使用rclone还需要另一个依赖工具<code>winfsp</code>，下载地址：<a href="http://www.secfs.net/winfsp/download/">http://www.secfs.net/winfsp/download/</a> ，下载后一路安装即可。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210105225.png" style="zoom: 80%;" />





<h3 id="2、为rclone配置环境变量"><a href="#2、为rclone配置环境变量" class="headerlink" title="2、为rclone配置环境变量"></a><strong>2、为rclone配置环境变量</strong></h3><ol>
<li><p>在电脑桌面右键点击“此电脑”的“属性”选项</p>
</li>
<li><p>选择“高级系统设置”选项</p>
</li>
<li><p>在系统变量中找到path，添加刚才解压后的路径</p>
</li>
</ol>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/image-20200210093901149.png" style="zoom:80%;" />



<h3 id="3、检查rclone是否配置成功"><a href="#3、检查rclone是否配置成功" class="headerlink" title="3、检查rclone是否配置成功"></a><strong>3、检查rclone是否配置成功</strong></h3><p>按<code>win</code>+<code>X</code>，然后按<code>A</code> 打开 <code>powershell</code> ，当然也可以去打开 <code>cmd</code> ，输入<code>rclone --version</code>，如果出现下面的输出则安装成功，否则检查上面步骤的环境变量是否配置正确。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210102009.png"></p>
<h3 id="4、开始配置rclone"><a href="#4、开始配置rclone" class="headerlink" title="4、开始配置rclone"></a>4、<strong>开始配置rclone</strong></h3><p>在终端中依次输入以下命令行，请根据我下的步骤进操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\AutoRclone&gt;rclone config                    // 第一步在终端输入 rclone config </span><br><span class="line">Current remotes:</span><br><span class="line">​</span><br><span class="line">Name                 Type</span><br><span class="line">====                 ====</span><br><span class="line">OneDrive             onedrive</span><br><span class="line">​</span><br><span class="line">e) Edit existing remote</span><br><span class="line">n) New remote</span><br><span class="line">d) Delete remote</span><br><span class="line">r) Rename remote</span><br><span class="line">c) Copy remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">e/n/d/r/c/s/q&gt; n                          //第二步输入n创建新的配置，                                                                  </span><br><span class="line">​</span><br><span class="line">name&gt; OneDrive_local                      //第三步 输入一个英文名称 ，中间也不要有空格</span><br><span class="line">Type of storage to configure.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).</span><br><span class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</span><br><span class="line"> 1 / 1Fichier</span><br><span class="line"> \ <span class="string">&quot;fichier&quot;</span></span><br><span class="line"> 2 / Alias <span class="keyword">for</span> an existing remote</span><br><span class="line"> \ <span class="string">&quot;alias&quot;</span></span><br><span class="line"> 3 / Amazon Drive</span><br><span class="line"> \ <span class="string">&quot;amazon cloud drive&quot;</span></span><br><span class="line"> 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc)</span><br><span class="line"> \ <span class="string">&quot;s3&quot;</span></span><br><span class="line"> 5 / Backblaze B2</span><br><span class="line"> \ <span class="string">&quot;b2&quot;</span></span><br><span class="line"> 6 / Box</span><br><span class="line"> \ <span class="string">&quot;box&quot;</span></span><br><span class="line"> 7 / Cache a remote</span><br><span class="line"> \ <span class="string">&quot;cache&quot;</span></span><br><span class="line"> 8 / Citrix Sharefile</span><br><span class="line"> \ <span class="string">&quot;sharefile&quot;</span></span><br><span class="line"> 9 / Dropbox</span><br><span class="line"> \ <span class="string">&quot;dropbox&quot;</span></span><br><span class="line">10 / Encrypt/Decrypt a remote</span><br><span class="line"> \ <span class="string">&quot;crypt&quot;</span></span><br><span class="line">11 / FTP Connection</span><br><span class="line"> \ <span class="string">&quot;ftp&quot;</span></span><br><span class="line">12 / Google Cloud Storage (this is not Google Drive)</span><br><span class="line"> \ <span class="string">&quot;google cloud storage&quot;</span></span><br><span class="line">13 / Google Drive</span><br><span class="line"> \ <span class="string">&quot;drive&quot;</span></span><br><span class="line">14 / Google Photos</span><br><span class="line"> \ <span class="string">&quot;google photos&quot;</span></span><br><span class="line">15 / Hubic</span><br><span class="line"> \ <span class="string">&quot;hubic&quot;</span></span><br><span class="line">16 / In memory object storage system.</span><br><span class="line"> \ <span class="string">&quot;memory&quot;</span></span><br><span class="line">17 / JottaCloud</span><br><span class="line"> \ <span class="string">&quot;jottacloud&quot;</span></span><br><span class="line">18 / Koofr</span><br><span class="line"> \ <span class="string">&quot;koofr&quot;</span></span><br><span class="line">19 / Local Disk</span><br><span class="line"> \ <span class="string">&quot;local&quot;</span></span><br><span class="line">20 / Mail.ru Cloud</span><br><span class="line"> \ <span class="string">&quot;mailru&quot;</span></span><br><span class="line">21 / Mega</span><br><span class="line"> \ <span class="string">&quot;mega&quot;</span></span><br><span class="line">22 / Microsoft Azure Blob Storage</span><br><span class="line"> \ <span class="string">&quot;azureblob&quot;</span></span><br><span class="line">23 / Microsoft OneDrive</span><br><span class="line"> \ <span class="string">&quot;onedrive&quot;</span></span><br><span class="line">24 / OpenDrive</span><br><span class="line"> \ <span class="string">&quot;opendrive&quot;</span></span><br><span class="line">25 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH)</span><br><span class="line"> \ <span class="string">&quot;swift&quot;</span></span><br><span class="line">26 / Pcloud</span><br><span class="line"> \ <span class="string">&quot;pcloud&quot;</span></span><br><span class="line">27 / Put.io</span><br><span class="line"> \ <span class="string">&quot;putio&quot;</span></span><br><span class="line">28 / QingCloud Object Storage</span><br><span class="line"> \ <span class="string">&quot;qingstor&quot;</span></span><br><span class="line">29 / SSH/SFTP Connection</span><br><span class="line"> \ <span class="string">&quot;sftp&quot;</span></span><br><span class="line">30 / Sugarsync</span><br><span class="line"> \ <span class="string">&quot;sugarsync&quot;</span></span><br><span class="line">31 / Transparently chunk/split large files</span><br><span class="line"> \ <span class="string">&quot;chunker&quot;</span></span><br><span class="line">32 / Union merges the contents of several remotes</span><br><span class="line"> \ <span class="string">&quot;union&quot;</span></span><br><span class="line">33 / Webdav</span><br><span class="line"> \ <span class="string">&quot;webdav&quot;</span></span><br><span class="line">34 / Yandex Disk</span><br><span class="line"> \ <span class="string">&quot;yandex&quot;</span></span><br><span class="line">35 / http Connection</span><br><span class="line"> \ <span class="string">&quot;http&quot;</span></span><br><span class="line">36 / premiumize.me</span><br><span class="line"> \ <span class="string">&quot;premiumizeme&quot;</span></span><br><span class="line"> Storage&gt; 23                             //第四步 输入要配置的网盘类型 因为我们要配置Microsoft OneDrive 因此输入23</span><br><span class="line">** See <span class="built_in">help</span> <span class="keyword">for</span> onedrive backend at: https://rclone.org/onedrive/ **</span><br><span class="line">​</span><br><span class="line">Microsoft App Client Id</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).</span><br><span class="line">client_id&gt;                              //第五步 直接回车</span><br><span class="line">Microsoft App Client Secret                                  </span><br><span class="line">Leave blank normally.                                        </span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).      </span><br><span class="line">client_secret&gt;                           //第六步 直接回车                    </span><br><span class="line">Edit advanced config? (y/n)                                  </span><br><span class="line">y) Yes </span><br><span class="line">n) No (default)                                              </span><br><span class="line">y/n&gt; n                                  //第七步 输入n 不进行高级配置 </span><br><span class="line">Remote config                                                </span><br><span class="line">Use auto config? </span><br><span class="line"> * Say Y <span class="keyword">if</span> not sure </span><br><span class="line"> * Say N <span class="keyword">if</span> you are working on a remote or headless machine</span><br><span class="line">y) Yes (default) </span><br><span class="line">n) No                                                        </span><br><span class="line">y/n&gt; y                                  //第八步 输入y 使用自动配置授权</span><br><span class="line">​</span><br><span class="line">//输入y后会打开默认浏览器 登录Microsoft账号后 选择 是 即可</span><br><span class="line"> If your browser doesn<span class="string">&#x27;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=sUuYaGWtxruA81JiCokJGg</span></span><br><span class="line"><span class="string">Log in and authorize rclone for access</span></span><br><span class="line"><span class="string">Waiting for code...</span></span><br><span class="line"><span class="string">Got code</span></span><br><span class="line"><span class="string">Choose a number from below, or type in an existing value</span></span><br><span class="line"><span class="string"> 1 / OneDrive Personal or Business</span></span><br><span class="line"><span class="string"> \ &quot;onedrive&quot;</span></span><br><span class="line"><span class="string"> 2 / Root Sharepoint site</span></span><br><span class="line"><span class="string"> \ &quot;sharepoint&quot;</span></span><br><span class="line"><span class="string"> 3 / Type in driveID</span></span><br><span class="line"><span class="string"> \ &quot;driveid&quot;</span></span><br><span class="line"><span class="string"> 4 / Type in SiteID</span></span><br><span class="line"><span class="string"> \ &quot;siteid&quot;</span></span><br><span class="line"><span class="string"> 5 / Search a Sharepoint site</span></span><br><span class="line"><span class="string"> \ &quot;search&quot;</span></span><br><span class="line"><span class="string">Your choice&gt;1                            //第九步 输入1 因为现在我配置的是 OneDrive Personal or Business 类型的网盘</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">Found 1 drives, please select the one you want to use:</span></span><br><span class="line"><span class="string">0: OneDrive (business) id=b!qDQvcsZUTU-8eoYyKmtyyP1Jc0D8urZLlkATnfH1nWdJ1kkbrLsvQZLzVUTpeTrc</span></span><br><span class="line"><span class="string">Chose drive to use:&gt; 0              //第十步 输入0</span></span><br><span class="line"><span class="string">Found drive &#x27;</span>root<span class="string">&#x27; of type &#x27;</span>business<span class="string">&#x27;, URL: https://pmjs-my.sharepoint.com/personal/wld_365_w/Documents</span></span><br><span class="line"><span class="string">Is that okay?</span></span><br><span class="line"><span class="string">y) Yes (default)</span></span><br><span class="line"><span class="string">n) No</span></span><br><span class="line"><span class="string">y/n&gt; y                               //第十一步 输入y</span></span><br><span class="line"><span class="string">--------------------</span></span><br><span class="line"><span class="string">[OneDrive_local]</span></span><br><span class="line"><span class="string">type = onedrive</span></span><br><span class="line"><span class="string">token = &#123;&quot;access_token&quot;:&quot;eyJ0eXAiOiV1QiLCJub25jZSI6ImNRYjl5TDNZWE8yczdQd2N2WTlJRkV1ZXp0QVpZZV83QWpPaHZORTU0OTgiLCJhbGciOiJSUzI1NiIsIng1dCI6IkhsQzBSMTJza3hOWjFXUXdtak9GXzZ0X3RERSIsImtpZCI6IkhsQzBSMTJza3hOWjFXUXdtak9GXzZ0X3RERSJ9yJhdWQiOiIwMDAwMDAwMy0wMDAwLTAwMDAtYzAwMC0wMDAwMDAwMDAwMDAiLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC84N2VjYmIxYi0wZTdlLTRlMDctOWFiMC00NWIwOTM1OTFjN2EvIiwiaWF0IjoxNTgxMzAxNLCJuYmYiOjE1ODEzMDE2MzAsImV4cCI6MTU4MTMwNTUzMCwiYWNjdCI6MCwiYWNyIjoiMSIsImFpbyI6IkFTUUyLzhPQUFBQWc2eURUazJNKzZ5YjVLNEJSN2VUR0lHT3EvSXFPT0dSZzlPWitrREoyaTg9IiwiYW1yIjpbInB3ZCJdLCJhcHBfZGlzcGxheW5hbWUiOiJyY2xvbmUiLCJhcHBpZCI6ImIxNTY2NWQ5LWVkYTYtNDA5Mi04NTM5LTBlZWMzNzZhZmQ1OSIsImFwcGlkYWNyIjoiMSIsImZhbWlseV9uYW1lIjoiV2FuZyIsImdpdmVuX25hbWUiOiJYaWFud2iwiaXBhZGRyIjoiMzkuMTI4LjIwMC4iwibmFtZSI6IldhbmdYaWFud2VuIiwib2lkIjoiZWE4ZjNjZDctN2IxYS00YmQ0LWFiNzItYzM4NDg4NTE5NDdhIiwicGxhdGYiOiIzIiwicHVpZCI6IjEwMDMzRkZGQUVGNEE2RTUiLCJzY3A5YWIwLTQ1YjA5MzU5MWM3YSIsInVuaXF1ZV9uYW1lIjoid29ybGRAbXkzNjUudHciLCJ1cG4iOiJ3b3JsZEBteTM2NS50dyIsInV0aSI6Il85MEZWRXBZcTBTYzckFuVDluQUEiLCJ2ZXIiOiIxLjAiLCJ4bXNfc3QiOnsic3ViIjoidXlWWU96UGF5RVBVWXlSbFlEVEl6QjhUZVBkZnNTMkVHcHczNGNDM2JRTSJ9LCJ4bXNfdGNkdCI6MTUzNDQyOTU0NH0.Ki9vor6NtxXJWsdumYddz8agrzVYXRCXVg0paW7XqDTq8i_vht8GK79F0F7xp3BSKzK5Xgxb0GzwPV9dPTb4IiXM0d17P5pQB3wHLMUbVFvRbLXNwSEtSJGKLttvxL8XfT8e51k4kyyH07CtozVBsF6fmMnhftp9ZbcEVrgnFKdwTE5In83G05V7L8wDCMiKrN0KX9iTKzxT9em5QtVhGZRZJDnNS2pJTQNhiWVatjDB4VHojG2C6J1LtU6YOOOAM2uBil2ovLFhQPy0l299ZJTJeyQCLQGJki9kZgAVI42iGP4mzvVPQAJk5Oad_4nPsT87QVH4NBA&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;refresh_token&quot;:&quot;OAQABAAAAAABeAFzDwllzTYGDLh_qYbH8falkpBpCm5PZqagAkUNWFik3Mz2ZfDPeowwW9q5mlFoHSqyYNG8FayvZxxZEUGQWUaR520MuJ5i_mj9CNs0NahNOJAtvZOBV459VLMKaNiyK9GJIGvdDe4RkaV472hbq_po8K47yC053BLRIbRji9WfsCkSMj8UP792sNJ0Tm9ptfPmy1aP_TePX8dOWaC9qZN2jDIXJDjWjCvfDesNDWXAm9bpBp1oZmObLR85EKB9Vgsz7ccZIbKEa16Aiqb67xsQICG8AzjMli76nJ6o_EBGI3dQvikLg17kAKtdb9gGnCj7P1Rh6V_NW_SeN1A7mR7RXrjTvW0gd3_4tEQ4_vkjxz9L4Ymoh0NIwCE6Pu8cTLow83JJJPmdYM4LFHXYApm5fgC9CVFg4JYhALkTZ0KI9qtO3Qe16OyySjmtcs8rD3GnGtKQewRbMcVgkA0JpOzKRA53VFx1SB3rRc2rxSDcnVTx_Oja_6KuaUxQjhgi1XaH1Kk_c82iniwdj7EdHCbokk8eewYFyn4tBTL0xW8rwmoPDvvUvMVA7Z8Ph0AB66Ih5evroSEHsv072AyDWSwHfrEMueTeEgP5jA1aBSOXE2DDw3PySehFfbYpsh0AV3qPVP9lAHaGizEbFt9rEKl1R1bcMrEhxF9GjnvB5PChRK_abttEV2YWKWrTaEFJBTP40f96kCXZGMaE4RaUoMI7hKW4cLQrHuV5YCZQ_BQRj7r5PoUyelGPdvnW42lB8MvekksdrJAVnlUTTgVKlbpn9AUuOD2LUZ5A8IheWaLkhLXfUqjPg0UxjTLIAA&quot;,&quot;expiry&quot;:&quot;2020-02-10T11:32:10.852646+08:00&quot;&#125;</span></span><br><span class="line"><span class="string">drive_id = b!qDvcsZUTU8eoYyKmtyyP1Jc0D8urZLlkTnH1nWdJ1kbrLsvQZLzVUTpeTrc</span></span><br><span class="line"><span class="string">drive_type = business</span></span><br><span class="line"><span class="string">--------------------</span></span><br><span class="line"><span class="string">y) Yes this is OK (default)</span></span><br><span class="line"><span class="string">e) Edit this remote</span></span><br><span class="line"><span class="string">d) Delete this remote</span></span><br><span class="line"><span class="string">y/e/d&gt;y                                      //第十二步 输入y</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>此时，就会出现刚刚配置好的网盘名称了</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/image-20200210104149803.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e) Edit existing remote</span><br><span class="line">n) New remote</span><br><span class="line">d) Delete remote</span><br><span class="line">r) Rename remote</span><br><span class="line">c) Copy remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">e/n/d/r/c/s/q&gt; q                //最后输入q退出配置即可</span><br></pre></td></tr></table></figure>



<p>在 <code>C:\Users\你的用户名\.config\rclone</code>文件夹下就可以看见配置文件 rclone.conf 啦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210104648.png"></p>
<h3 id="5、挂载OneDrive为本地硬盘"><a href="#5、挂载OneDrive为本地硬盘" class="headerlink" title="5、挂载OneDrive为本地硬盘"></a><strong>5、挂载OneDrive为本地硬盘</strong></h3><p>此时请使用 <code>git bash</code> 的终端执行以下命令，因为我使用<code>cmd</code> 和 <code>powershell</code> 都出现关闭终端后挂载程序退出、本地挂载的OneDrive退出的现象。 如果你的windows没有安装git ， 请<a href="https://www.baidu.com/s?wd=windows%20%E5%AE%89%E8%A3%85git&ie=utf-8">自行安装</a>。若你使用 <code>cmd</code> 的话 ，<code>cmd</code> 是不能退出的，要保持 <code>cmd</code> 不退出本地硬盘才一直挂载着。</p>
<p>在 <code>git bash</code> 中输入以下挂载命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone mount OneDrive_local:/  Q: --cache-dir E:\OneDrive --vfs-cache-mode writes &amp;</span><br></pre></td></tr></table></figure>



<p>其中：</p>
<p><code>OneDrive_loca</code> 替换为你自己前面设置的名称 。</p>
<p><code>Q:</code> 替换为你想要挂载后硬盘的盘符名称即可，记得不要和本地的C盘、D盘等重复。</p>
<p><code>E:\OneDrive</code> 为本地缓存目录，可自行设置 。</p>
<p>出现：<code>The service rclone has been started</code> 则说明挂载成功。</p>
<p>然后输入 <code>exit</code> 退出终端即可。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210124133.png"></p>
<p>然后就可以看见本地多了一个盘，往里面复制文件就是上传，从里面复制文件到其它盘就是下载。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210124455.png"></p>
<h3 id="6、设置开机自启动挂载"><a href="#6、设置开机自启动挂载" class="headerlink" title="6、设置开机自启动挂载"></a><strong>6、设置开机自启动挂载</strong></h3><p>创建一个名称为 <code>startup_rclone.bat</code> 的文件，里面填写上面的挂载命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone mount OneDrive_local:/  Q: --cache-dir E:\OneDrive --vfs-cache-mode writes &amp;</span><br></pre></td></tr></table></figure>


<p>将这个文件放在<code>C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code> 中</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211114237.png"></p>
<p>重启计算机后就会自动挂设置的云盘了，当然这样做由于调用的是 <code>cmd</code> 因此还是不能关闭运行的 <code>cmd</code>。下面介绍一种利用 Rclone GUI 的进行管理的使用方法。</p>
<h3 id="7、可视化上传下载-RcloneBrowser"><a href="#7、可视化上传下载-RcloneBrowser" class="headerlink" title="7、可视化上传下载  RcloneBrowser"></a>7、<strong>可视化上传下载  RcloneBrowser</strong></h3><p>在 <a href="https://github.com/kapitainsky/RcloneBrowser/releases">https://github.com/kapitainsky/RcloneBrowser/releases</a>中下载 <a href="">RcloneBrowser</a> 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211120423.png"></p>
<p>下载好后进行安装，然后进行配置。配置 <code>rclone.exe</code>的路径还有 <code>rclone.conf</code> 配置文件的路径。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211121437.png"></p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211122054.png" style="zoom:80%;" />

<center>这是我前面解压rclon的路径以及配置文件的路径 </center>
配置好后就可以看见前面配置的 OneDrive 网盘了  ☁️



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211122953.png"></p>
<p>双击打开就可以看见里面的内容了，可以去愉快的上传或者下载了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211123555.png"></p>
<p>上传的话，选择要上传的文件或文件夹以及云盘的存放路径，再选择 <code>copy</code> 模式，点击 <code>run</code> 即可。下载与之类似。<br><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211123950.png"></p>
<p>在 <code>Jobs</code>当中还可以查看任务的进度、速度等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200211144441.png"></p>
<p>另外还可以设置代理，见下图：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403082502.png"></p>
<p>这样挂载谷歌云端硬盘就很方便了。</p>
<p><del>如果你觉得rclone 太麻烦，还可以试试 <a href="%20https://www.raidrive.com/">RaiDrive</a> 挂载，安装后选择相应的网盘登录即可，但我用起来感觉比较卡顿。</del>  不推荐了，2020年3月份收到邮件说挂载 Onedrive 、Google Derive 要收费了，无奈🙃</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/202002/20200210135030.png" alt="https://www.raidrive.com/"></p>
<p>参考</p>
<blockquote>
<p><a href="https://rclone.org/docs/">官方文档</a></p>
<p><a href="%5Bhttps://telegra.ph/Windows%E4%B8%8B%E7%94%A8rclone%E6%8C%82%E8%BD%BDOneDrive%E4%B8%BA%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-01-03%5D(https://telegra.ph/Windows%E4%B8%8B%E7%94%A8rclone%E6%8C%82%E8%BD%BDOneDrive%E4%B8%BA%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-01-03)">Windows下用rclone挂载OneDrive为本地硬盘</a></p>
<p><a href="http://piaoyun.cc/1290.html">使用软件rclone在Windows操作系统上挂载OneDrive为本地硬盘的操作方法</a></p>
<p><a href="https://p3terx.com/archives/rclone-advanced-user-manual-common-command-parameters.html">Rclone 进阶使用教程 - 常用命令参数详解</a></p>
</blockquote>
<blockquote class="blockquote-center">
<p>今夜偏知春气暖，虫声新透绿窗纱</p>

</blockquote>




]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>善用佳软</tag>
        <tag>Windows</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone使用代理加速🐌</title>
    <url>/posts/54130e76.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2011911/mt-fuji-sea-of-clouds-sunrise-2345.jpg"></p>
<p>国内访问GitHub速度较慢，克隆代码时的速度就更慢了，常常断开。因此，我们需要让我们的git走代理来加速克隆。</p>
<span id="more"></span>







<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只对github.com</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment">#全局-推荐只代理github即可，毕竟国内的gitee还是很快的</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我使用的是socks5 协议，本地端口1080，因此有以上配置。</p>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20191109200835323.png" style="zoom:67%;" />



<p>若协议、端口不同相应的更改配置命令即可。比如如果是http或https协议，本地端口是6666，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#全局</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:6666</span><br><span class="line">git config --global https.proxy https://127.0.0.1:6666</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下载下载速度就快了很多很多，以前常常是几KB&#x2F;s，真实受够了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20191109194558086.png"></p>
<p>如果你没有使用自己的代理，那么你可以在浏览器中安装暴力猴或者油猴，然后安装<a href="https://greasyfork.org/zh-CN/scripts/391911-github-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD-%E7%A0%81%E9%85%B7%E5%8D%9A%E5%AE%A2-%E6%94%B9">GitHub 镜像加速下载脚本</a>，就可以在网页中看见国内的加速链接了，复制下来去<code>git clone</code>就好啦。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img/image-20191109202424018.png"></p>
<p>参考</p>
<p> <a href="https://stackoverflow.com/questions/15227130/using-a-socks-proxy-with-git-for-the-http-transport">https://stackoverflow.com/questions/15227130/using-a-socks-proxy-with-git-for-the-http-transport</a> </p>
<p> <a href="https://gist.github.com/laispace/666dd7b27e9116faece6">https://gist.github.com/laispace/666dd7b27e9116faece6</a> </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<img data-src=" https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/201910/IMG_20160818_143927.jpg" style="zoom:25%;" />

<center><font size=1.5>20160818-云南保山 </center>
Welcome to my Blog. This is my first post. If you want to konw more info about Hexo please Check [documentation](https://hexo.io/docs/) . If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).
<span id="more"></span>

<h2 id="Quick-Start😏"><a href="#Quick-Start😏" class="headerlink" title="Quick Start😏"></a>Quick Start😏</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<p>❤</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>风景</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客Markdown写作</title>
    <url>/posts/35048.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200506232402.jpg" alt="&lt;center&gt;&lt;font size=1.5&gt;  From Pexels&lt;/center&gt;"></p>
<p>Markdown写作的基本语法，及一些Hexo特有的语法。</p>
<span id="more"></span>







<h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>支持6种大小的标题，分别对应<code>#</code>,<code>##</code>,<code>###</code>,<code>####</code>,<code>#####</code>,<code>######</code>，和样式文件中的<code>h1,...,h6</code>如：<br>#####H5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####H5</span><br></pre></td></tr></table></figure>

<p>######H6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">######H6</span><br></pre></td></tr></table></figure>



<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><strong>我是强调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**我是强调**</span><br></pre></td></tr></table></figure>



<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>试试<em>斜体</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">试试*斜体*</span><br></pre></td></tr></table></figure>



<h3 id="强调的斜体"><a href="#强调的斜体" class="headerlink" title="强调的斜体"></a>强调的斜体</h3><p>试试<em><strong>强调的斜体</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">试试***强调的斜体***</span><br></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>试试 <del>删除</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">试试 ~~删除~~</span><br></pre></td></tr></table></figure>

<h3 id="外链的超链接"><a href="#外链的超链接" class="headerlink" title="外链的超链接"></a>外链的超链接</h3><p>试试外链的超链接：<a href="https://upwon.github.io/">我是外链的超链接</a>,markdown对链接的语法为：<code>[]()</code>,如：<code>[我是外链的超链接](https://upwon.github.io/)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[我是外链的超链接](https://upwon.github.io/),</span><br></pre></td></tr></table></figure>



<h3 id="页内的超链接"><a href="#页内的超链接" class="headerlink" title="页内的超链接"></a>页内的超链接</h3><p>试试页内的超链接：<a href="#jump_1">我是页内的超链接</a>，注：你先要在要跳转的到地方放置一个类似：<code>&lt;a id=&quot;jump_1&quot;&gt;任意内容&lt;/a&gt;</code>的锚点。由<code>id=&quot;jump_1&quot; </code>来匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[我是页内的超链接](#jump_1)</span><br></pre></td></tr></table></figure>




<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol>
<li><p>有序列表 1</p>
</li>
<li><p>有序列表 2</p>
</li>
<li><p>有序列表 3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 有序列表 1</span><br><span class="line">2. 有序列表 2</span><br><span class="line">3. 有序列表 3</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li><p>无序列表 1</p>
</li>
<li><p>无序列表 2</p>
</li>
<li><p>无序列表 3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 无序列表 1</span><br><span class="line">- 无序列表 2</span><br><span class="line">- 无序列表 3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p>只需要在前面加 <code>&gt;</code>,如下:</p>
<blockquote>
<p>我是引用块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 我是引用块</span><br></pre></td></tr></table></figure>

<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p><br/> <br/> <br/> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt; </span><br><span class="line">&lt;br/&gt; </span><br><span class="line">&lt;br/&gt; </span><br></pre></td></tr></table></figure>



<h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>如：<code>AppCompatActivity</code>类,markdown对行内代码的语法是前后用：`,其中 ` 为键盘<kbd>Tab</kbd>箭上面上角那个<kbd>`</kbd></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`AppCompatActivity`</span><br></pre></td></tr></table></figure>

<h3 id="HTML-标签-键盘按键"><a href="#HTML-标签-键盘按键" class="headerlink" title="HTML  标签 键盘按键"></a>HTML <kbd> 标签 键盘按键</h3><p>markdown中可以插入html标签来实现更加丰富的显示效果。例如<code>&lt;kbd&gt;</code>标签来插入键盘按键 <kbd>Ctrl+S</kbd></p>
<p><strong>定义和用法</strong><br><code>&lt;kbd&gt;</code>标签定义键盘文本。<br>说到技术概念上的特殊样式时，就要提到 <code>&lt;kbd&gt;</code>标签。<br>正如你已经猜到的，它用来表示文本是从键盘上键入的。<br>浏览器通常用等宽字体来显示该标签中包含的文本。<code>&lt;kbd&gt;</code>标签经常用在于计算机相关的文档和手册中。例如：<br>键入<code>&lt;kbd&gt;quit&lt;/kbd&gt;</code>来退出程序，或者键入<code>&lt;kbd&gt;menu&lt;/kbd&gt;</code>来返回主菜单。</p>
<p>比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>F<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示为：</p>
<p><kbd>Ctrl</kbd>+<kbd>F</kbd></p>
<h3 id="代码块显示效果"><a href="#代码块显示效果" class="headerlink" title="代码块显示效果"></a>代码块显示效果</h3><p>注：markdown对代码块的语法是开始和结束行都要添加：&#96;&#96;&#96;,其中 ` 为windows键盘左上角那个，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">haimaxy-sa-rolebinding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">haimaxy-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">haimaxy-sa-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>要精确指定语言，</p>
<p>如：<code>java,cpp,css,xml,javascript,python,php,go,kotlin,lua,objectivec</code>等等时，在头部直接指定，如：```javascript，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showSnackbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> $snackbar = $(<span class="string">&#x27;#snackbar&#x27;</span>);</span><br><span class="line">  $snackbar.<span class="title function_">addClass</span>(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    $snackbar.<span class="title function_">removeClass</span>(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>```javascript</p>
<p>function showSnackbar() {<br> var $snackbar &#x3D; $(‘#snackbar’);<br> $snackbar.addClass(‘show’);<br> setTimeout(() &#x3D;&gt; {<br>   $snackbar.removeClass(‘show’);<br> }, 3000);<br>}</p>
</blockquote>
<p>在页面头部提供了很多中<strong>代码主题</strong>风格，可以根据需要选择合适的即可。</p>
<p><br/> <br/></p>
<h2 id="Markdown扩展语法"><a href="#Markdown扩展语法" class="headerlink" title="Markdown扩展语法"></a>Markdown扩展语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>班级</th>
<th>男生</th>
<th>女生</th>
</tr>
</thead>
<tbody><tr>
<td>一(7)班</td>
<td>30</td>
<td>25</td>
</tr>
<tr>
<td>一(8)班</td>
<td>25</td>
<td>30</td>
</tr>
</tbody></table>
<p>注：表格在公众号预览时，可能在PC端显示的不是正确的全屏，但在手机上预览时就会正常显示为全屏的了。</p>
<br/> 

<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>如果你懂html和css，那下面这些效果就不在话下了：</p>
<p><a href="#jump_1">来个页内跳转</a>，跳转到文未的：<code>&lt;a id=&quot;jump_1&quot;&gt;我是页内跳转到的位置&lt;/a&gt;</code> ,对应：<code>id=&quot;jump_1&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#jump_1&quot;&gt;来个页内跳转&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br/>

<h4 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h4><p><span  style="color: #5bdaed; ">先给点颜色你看看</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>  <span class="attr">style</span>=<span class="string">&quot;color: #5bdaed; &quot;</span>&gt;</span>先给点颜色你看看<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>

<p><span  style="color: #AE87FA; ">再给点颜色你看看</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span  style=&quot;color: #AE87FA; &quot;&gt;再给点颜色你看看&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<br/>

<h4 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h4><table><tr><td bgcolor=green>背景色是：green</td></tr></table>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=green&gt;背景色是：green&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<br/>

<h4 id="带颜色的分割线"><a href="#带颜色的分割线" class="headerlink" title="带颜色的分割线"></a>带颜色的分割线</h4><hr style="background-color : red;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr style=&quot;background-color : red;&quot;&gt;</span><br></pre></td></tr></table></figure>

<br/>

<h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;首行缩进测试</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;首行缩进测试</p>
<p>这没有缩进</p>
<blockquote>
<p>(每个表示一个空格，连续使用两个即可）</p>
<ul>
<li><code>&amp;ensp;</code> 半角的空格</li>
<li><code>&amp;emsp;</code>全角的空格</li>
</ul>
</blockquote>
<br/>

<h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p><span  style="font-size:1.3em;">试试改变字体大小</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>  <span class="attr">style</span>=<span class="string">&quot;font-size:1.3em;&quot;</span>&gt;</span>试试改变字体大小<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>



<p><span  style="font-size:1.3em;font-weight: bold;">改变字体大小，再来个粗体又如何？</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>  <span class="attr">style</span>=<span class="string">&quot;font-size:1.3em;font-weight: bold;&quot;</span>&gt;</span>改变字体大小，再来个粗体又如何？<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>

<h4 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h4><p style="text-align:center">
试试内容居中
    </p>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align:center&quot;&gt;</span><br><span class="line">试试内容居中</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<br/>

<p style="text-align:right">
那内容居右呢？
</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align:right&quot;&gt;</span><br><span class="line">那内容居右呢？</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>



<br/>




<p style="text-align:center;color:#1e819e;font-size:1.3em;font-weight: bold;">
来个综合的试试
<br/>
第二行
</p>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align:center;color:#1e819e;font-size:1.3em;font-weight: bold;&quot;&gt;</span><br><span class="line">来个综合的试试</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">第二行</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<br/>



<p><a id="jump_1">我是页内跳转到的位置</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;jump_1&quot;&gt;我是页内跳转到的位置&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<br/>



<br/>

<h2 id="Hexo-博客-Next主题特有的一些语法"><a href="#Hexo-博客-Next主题特有的一些语法" class="headerlink" title="Hexo 博客 Next主题特有的一些语法"></a>Hexo 博客 Next主题特有的一些语法</h2><h3 id="文本居中的引用"><a href="#文本居中的引用" class="headerlink" title="文本居中的引用"></a>文本居中的引用</h3><p>此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。   例如作为文章开篇引用 或者 结束语之前的总结引用。</p>
<p><strong>使用方式</strong></p>
<ul>
<li>HTML方式：使用这种方式时，给 <code>img</code> 添加属性 <code>class=&quot;blockquote-center&quot;</code> 即可。</li>
<li>标签方式：使用 <code>centerquote</code> 或者 简写 <code>cq</code>。</li>
</ul>
<p> 此标签要求 NexT 的版本在 0.4.5 或以上。      若你正在使用的版本比较低，可以选择使用 <code>HTML</code> 方式。    </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">&quot;blockquote-center&quot;</span>&gt;</span>blah blah blah<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span></span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 标签别名 --&gt;</span></span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>



<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">HTML方式 </span><br><span class="line">水止无痕地，云行不计程。</span><br><span class="line">到时为彼岸，过处即前生。</span><br><span class="line">——《送文畅上人东游》吕温</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>

 <br/>

<blockquote class="blockquote-center">HTML方式 
水止无痕地，云行不计程。
到时为彼岸，过处即前生。
——《送文畅上人东游》吕温
</blockquote>
 <br/>

 <br/>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% centerquote %&#125;</span><br><span class="line">标签方式</span><br><span class="line">晓看天色暮看云，行也思君，坐也思君。</span><br><span class="line">--唐寅《一剪梅·雨打梨花深闭门》</span><br><span class="line"></span><br><span class="line">&#123;% endcenterquote %&#125;</span><br></pre></td></tr></table></figure>



<blockquote class="blockquote-center">
<p>标签方式<br>晓看天色暮看云，行也思君，坐也思君。<br>–唐寅《一剪梅·雨打梨花深闭门》</p>

</blockquote>

 <br/>

 <br/>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;</span><br><span class="line"></span><br><span class="line">空山新雨后，天气晚来秋。</span><br><span class="line"></span><br><span class="line">明月松间照，清泉石上流。</span><br><span class="line"></span><br><span class="line">——《山居秋暝》王维</span><br><span class="line"></span><br><span class="line">&#123;% endcq %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote class="blockquote-center">
<p>空山新雨后，天气晚来秋。</p>
<p>明月松间照，清泉石上流。</p>
<p>——《山居秋暝》王维</p>

</blockquote>

 <br/>

 <br/>

 <br/>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>在 Hexo中可以使用 note 标签，在主题配置文件下可以配置风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#<span class="title class_">Note</span> tag (bs-callout)</span><br><span class="line"><span class="attr">note</span>:</span><br><span class="line">  # <span class="title class_">Note</span> tag style <span class="attr">values</span>:</span><br><span class="line">  #  - simple    bs-callout old alert style. <span class="title class_">Default</span>.</span><br><span class="line">  #  - modern    bs-callout <span class="keyword">new</span> (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style <span class="keyword">with</span> background, like on <span class="title class_">Mozilla</span> or <span class="title class_">StackOverflow</span>.</span><br><span class="line">  #  - disabled  disable all <span class="variable constant_">CSS</span> styles <span class="keyword">import</span> <span class="keyword">of</span> note tag.</span><br><span class="line">  <span class="attr">style</span>: flat  #设置风格</span><br><span class="line">  <span class="attr">icons</span>: <span class="literal">false</span> #是否开启图标</span><br><span class="line">  # <span class="title class_">Offset</span> lighter <span class="keyword">of</span> background <span class="keyword">in</span> % <span class="keyword">for</span> modern and flat styles (<span class="attr">modern</span>: -<span class="number">12</span> | <span class="number">12</span>; <span class="attr">flat</span>: -<span class="number">18</span> | <span class="number">6</span>).</span><br><span class="line">  # <span class="title class_">Offset</span> also applied to label tag variables. <span class="title class_">This</span> option can work <span class="keyword">with</span> disabled note tag.</span><br><span class="line">  <span class="attr">light_bg_offset</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

 <br/>



<p>simple 风格的是这样的</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_171642_1057_621_firefox.png"></p>
<p>相应的标签这样写就行啦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

 <br/>

 <br/>

<p>modern 风格的是这样的</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_171801_1055_633_firefox.png"></p>
 <br/>

 <br/>

<p>flat 风格的是这样的</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_171250_1066_619_firefox.png"></p>
<p>个人感觉 flat 扁平化的最为美观。</p>
 <br/>

  <br/>



<p>开启 ico 后的效果是这样的：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_172051_1075_627_firefox.png"></p>
<p> <br/> <br/></p>
<h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><a href="#tab-1">tab 1</a></li><li class="tab active"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">我的名字是tab3</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-1"><p>选项卡 1</p></div><div class="tab-pane active" id="tab-2"><p><strong>选项卡 2(加粗)</strong></p></div><div class="tab-pane" id="tab-3"><p><em><strong>选项卡 3</strong></em> (加粗斜体)</p></div></div></div>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab,2 %&#125; 名字为tab，默认在第2个选项卡，如果是-1则隐藏</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">选项卡 1</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**选项卡 2(加粗)**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab A --&gt;</span></span><br><span class="line">***选项卡 3*** (加粗斜体)</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选项卡名称自定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡 2 %&#125;</span><br><span class="line">&lt;!-- tab 自定义名称1 --&gt;</span><br><span class="line">这是选项卡 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 自定义名称2 --&gt;</span><br><span class="line">这是选项卡 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 自定义名称3 --&gt;</span><br><span class="line">这是选项卡 3</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>



<div class="tabs" id="选项卡-2"><ul class="nav-tabs"><li class="tab active"><a href="#选项卡-2-1">自定义名称1</a></li><li class="tab"><a href="#选项卡-2-2">自定义名称2</a></li><li class="tab"><a href="#选项卡-2-3">自定义名称3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="选项卡-2-1"><p>这是选项卡 1</p></div><div class="tab-pane" id="选项卡-2-2"><p>这是选项卡 2</p></div><div class="tab-pane" id="选项卡-2-3"><p>这是选项卡 3</p></div></div></div>

<p><strong>选项卡名称使用 icon</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡 2 %&#125;</span><br><span class="line">&lt;!-- tab 自定义名称1@text-width --&gt;</span><br><span class="line">这是选项卡 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 自定义名称2@amazon --&gt;</span><br><span class="line">这是选项卡 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 自定义名称3@bold --&gt;</span><br><span class="line">这是选项卡 3</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="选项卡-2"><ul class="nav-tabs"><li class="tab active"><a href="#选项卡-2-1"><i class="fa fa-text-width"></i>自定义名称1</a></li><li class="tab"><a href="#选项卡-2-2"><i class="fa fa-amazon"></i>自定义名称2</a></li><li class="tab"><a href="#选项卡-2-3"><i class="fa fa-bold"></i>自定义名称3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="选项卡-2-1"><p>这是选项卡 1</p></div><div class="tab-pane" id="选项卡-2-2"><p>这是选项卡 2</p></div><div class="tab-pane" id="选项卡-2-3"><p>这是选项卡 3</p></div></div></div>

<br/>

<br/>

<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>hexo 使用的是<a href="http://www.fontawesome.com.cn/icons/">fontawesome</a>图标，有<a href="http://www.fontawesome.com.cn/icons/">国内网站</a>和<a href="https://fontawesome.com/icons">国外网站</a>。使用的时候对应相应的图标名称即可</p>
<br/>

<p>  <i class="fa fa-telegram" aria-hidden="true"></i> telegram</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-telegram&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;telegram</span><br></pre></td></tr></table></figure>

<br/>

<p><i class="fa fa-google" ></i> Google</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-google&quot; &gt;&lt;/i&gt; Google</span><br></pre></td></tr></table></figure>

<br/>

<p>为了增加图标大小相对于它们的容器, 使用 <code>fa-lg</code> (33% 递增), <code>fa-2x</code>,    <code>fa-3x</code>, <code>fa-4x</code>, 或 <code>fa-5x</code> classes.</p>
<p><i class="fa fa-camera-retro fa-lg"></i> fa-lg</p>
<p><br/><i class="fa fa-camera-retro fa-2x"></i> fa-2x</p>
<p><br/><i class="fa fa-camera-retro fa-3x"></i> fa-3x </p>
<br/>
<i class="fa fa-camera-retro fa-4x"></i> fa-4x

<p><br/><i class="fa fa-camera-retro fa-5x"></i> fa-5x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-camera-retro fa-lg&quot;&gt;&lt;/i&gt; fa-lg</span><br><span class="line">&lt;i class=&quot;fa fa-camera-retro fa-2x&quot;&gt;&lt;/i&gt; fa-2x</span><br><span class="line">&lt;i class=&quot;fa fa-camera-retro fa-3x&quot;&gt;&lt;/i&gt; fa-3x</span><br><span class="line">&lt;i class=&quot;fa fa-camera-retro fa-4x&quot;&gt;&lt;/i&gt; fa-4x</span><br><span class="line">&lt;i class=&quot;fa fa-camera-retro fa-5x&quot;&gt;&lt;/i&gt; fa-5x</span><br></pre></td></tr></table></figure>

<br/>

<br/>

<h3 id="Button-标签"><a href="#Button-标签" class="headerlink" title="Button 标签"></a>Button 标签</h3><p><strong>使用方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标签 方式 --&gt;</span><br><span class="line">&#123;% button /path/to/url/, text, icon [class], title %&#125;</span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% btn /path/to/url/, text, icon [class], title %&#125;</span><br><span class="line">&lt;!-- HTML标签 --&gt;</span><br><span class="line">&lt;button type=&quot;button&quot;&gt;这是标签名Click Me!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<a class="btn" href="#">Text</a><a class="btn" href="#" title="Title"><i class="fa fa-home"></i>Text & Title</a>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn #, Text %&#125;&#123;% btn #, Text &amp; Title, home, Title %&#125;</span><br></pre></td></tr></table></figure>

 <br/>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn url, text, icon [class], [title] %&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn https://upwon.github.io ,首页,home fa-2x,这是YouForever的首页%&#125;</span><br></pre></td></tr></table></figure>



<div><a class="btn" href="https://upwon.github.io " title="这是YouForever的首页"><i class="fa fa-home fa-2x"></i>首页</a></div>

 <br/>

<a class="btn" href="https://www.google.com"><i class="fa fa-google fa-fw"></i>google一下</a>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn https://www.google.com, google一下,  google fa-fw %&#125;</span><br></pre></td></tr></table></figure>

 <br/>

<p>HTML示例</p>
<p>  <button type="button" style="color: #d54b44"> Click Me!</button></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; style=&quot;color: #d54b44&gt; Click Me!&lt;/button&gt;</span><br></pre></td></tr></table></figure>



 <br/>

<button type="button" class="btn"  style="background-color: #c35655; width: 76px;height: 36px;color: #FFFFFF">
            新建
        </button>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: #c35655;width: 76px;height: 36px;color: #FFFFFF&quot;</span>&gt;</span></span><br><span class="line">    新建</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>


 <br/>

<center><button type="button" class="btn"  style="background-color: #c35655; width: 76px;height: 36px;color: #FFFFFF">居中的</button> </center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: #c35655; width: 76px;height: 36px;color: #FFFFFF&quot;</span>&gt;</span>居中的<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>

 <br/>

 

<div style="text-align: center;">
   <input type="button" value="button">
</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<br/>

<div>
  <input type="button" value="button" style="display: block; margin: 0 auto;">
</div>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block; margin: 0 auto;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br/>

<br/>

<h3 id="代码添加改动标记"><a href="#代码添加改动标记" class="headerlink" title="代码添加改动标记"></a>代码添加改动标记</h3><p>只需将代码块中的语言指定为 <code>diff</code>，同时每行行首使用 <code>+</code> 和 <code>-</code> 来控制代码增减。</p>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:diff %&#125;</span><br><span class="line">- code snippet deleted</span><br><span class="line">+ code snippet added</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:diff %&#125;</span><br><span class="line">- print(&quot;删除的&quot;)</span><br><span class="line">+ print(&quot;增加的&quot;)</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">- print(&quot;删除的&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ print(&quot;增加的&quot;)</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<br/>

<p>示例代码<strong>2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff</span><br><span class="line"></span><br><span class="line">- print(&quot;删除的&quot;)</span><br><span class="line"></span><br><span class="line">+ print(&quot;增加的&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>效果2</strong><br>​&#96;&#96;&#96;diff</p>
<ul>
<li>print(“删除的”)</li>
</ul>
<ul>
<li>print(“增加的”)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 标签效果</span><br><span class="line"></span><br><span class="line">**例：**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>我坐在床前，望着窗外，<mark class="label ">回忆满天</mark>。生命是<mark class="label primary">华丽错觉</mark>，时间是贼偷走一切。</p>
<p>七岁的那一年，抓住那只<mark class="label success">蝉</mark>，以为能抓住夏天。十七岁的那年，吻过他的脸，就以为和他能<mark class="label info">永远</mark>。</p>
<p>有没有那么一种永远，<mark class="label warning">永远不改变</mark>，拥抱过的美丽，都再也不破碎。<br>让险峻岁月不能，在脸上撒野，让<mark class="label danger">生离和死别都遥远</mark>，有谁能听见。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**效果：**</span><br><span class="line"></span><br><span class="line">我坐在床前，望着窗外，&#123;% label @回忆满天 %&#125;。生命是&#123;% label primary @华丽错觉 %&#125;，时间是贼偷走一切。</span><br><span class="line"></span><br><span class="line">七岁的那一年，抓住那只&#123;% label success @蝉 %&#125;，以为能抓住夏天。十七岁的那年，吻过他的脸，就以为和他能&#123;% label info @永远 %&#125;。</span><br><span class="line"></span><br><span class="line">有没有那么一种永远，&#123;% label warning @永远不改变 %&#125;，拥抱过的美丽，都再也不破碎。</span><br><span class="line">让险峻岁月不能，在脸上撒野，让&#123;% label danger @生离和死别都遥远 %&#125;，有谁能听见。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">记得图片路径加上英文的双引号 &#x27;&#x27; &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">我使用的是HTML方式，因为我尝试标签方式出不来</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">   &lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200422083632.jpg&quot; class=&quot;full-image&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200422083632.jpg" class="full-image" />

  


   <br/>

   <br/>

  

  

<p>   <strong>Reference：</strong></p>
<blockquote>
<p><a href="http://md.aclickall.com/">Md2All</a></p>
<p><a href="https://theme-next.iissnan.com/tag-plugins.html">内置标签</a></p>
<p><a href="https://theme-next.iissnan.com/tag-plugins.html">在hexo-NexT中插入note提示块</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p>
<p><a href="http://yearito.cn/posts/hexo-writing-skills.html">Hexo 搭建个人博客系列：写作技巧篇</a> </p>
<p><a href="https://blog.lihj.me/post/next-tag-plugin-instruction.html">NexT 主题内置标签</a><br><a href="https://www.w3school.com.cn/tags/tag_kbd.asp">W3school HTML <kbd> 标签</a></p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>npm install 报错node-sass@4.13.0 postinstall:`node scripts/build.js` Failed at the node-sass@4.13.0</title>
    <url>/posts/17155.html</url>
    <content><![CDATA[<p>今天在安装谷歌开源的 <a href="https://github.com/GoogleChromeLabs/squoosh">squoosh</a>  ，npm install 报错<a href="mailto:&#110;&#111;&#x64;&#101;&#x2d;&#x73;&#97;&#115;&#x73;&#64;&#x34;&#46;&#49;&#51;&#46;&#48;">&#110;&#111;&#x64;&#101;&#x2d;&#x73;&#97;&#115;&#x73;&#64;&#x34;&#46;&#49;&#51;&#46;&#48;</a> postinstall: node scripts&#x2F;build.js Failed at the <a href="mailto:&#x6e;&#111;&#100;&#x65;&#45;&#x73;&#97;&#x73;&#x73;&#x40;&#52;&#x2e;&#49;&#x33;&#46;&#48;">&#x6e;&#111;&#100;&#x65;&#45;&#x73;&#97;&#x73;&#x73;&#x40;&#52;&#x2e;&#49;&#x33;&#46;&#48;</a> 。</p>
<span id="more"></span>





<br />

<p>今天在安装谷歌开源的 <a href="https://github.com/GoogleChromeLabs/squoosh">squoosh</a> ,图像压缩的，本来只需要</p>
<p>Clone the repo, and:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>You can run the development server with:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>就可以了，但是npm install就报错了。</p>
<p>npm install 报错<a href="mailto:&#110;&#111;&#100;&#101;&#45;&#x73;&#x61;&#x73;&#115;&#x40;&#x34;&#46;&#49;&#51;&#x2e;&#48;">&#110;&#111;&#100;&#101;&#45;&#x73;&#x61;&#x73;&#115;&#x40;&#x34;&#46;&#49;&#51;&#x2e;&#48;</a> postinstall:<code>node scripts/build.js</code> Failed at the <a href="mailto:&#110;&#111;&#x64;&#x65;&#x2d;&#115;&#97;&#115;&#x73;&#64;&#x34;&#46;&#x31;&#x33;&#x2e;&#48;">&#110;&#111;&#x64;&#x65;&#x2d;&#115;&#97;&#115;&#x73;&#64;&#x34;&#46;&#x31;&#x33;&#x2e;&#48;</a></p>
<p>具体错误为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! node-sass@4.13.0 postinstall: `node scripts/build.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the node-sass@4.13.0 postinstall script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\12447\AppData\Roaming\npm-cache\_logs\2020-05-06T14_00_42_188Z-debug.log</span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_222809_1089_580_ConEmu64.png"></p>
<p>解决方法</p>
<p>更改node-sass 的数据源设置,改为淘宝镜像即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> sass_binary_site=https://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure>

<p>然后重新安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>



<p>然后报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 2</span><br><span class="line">npm ERR! squoosh@1.9.1 build: `webpack -p`</span><br><span class="line">npm ERR! Exit status 2</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the squoosh@1.9.1 build script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br></pre></td></tr></table></figure>

<p>参考 <a href="https://stackoverflow.com/questions/42308879/npm-err-code-elifecycle">stackoverflow</a> 中大神的解决方法：</p>
<blockquote>
<p>Step 1: <code>$ npm cache clean --force</code></p>
<p>步骤1: $npm 清空缓存—- 强制</p>
<p>Step 2: Delete <strong>node_modules</strong> by <code>$ rm -rf node_modules package-lock.json</code> folder or delete it <strong>manually</strong> by going into the directory and right-click &gt; delete &#x2F; move to trash. Also, delete <strong>package-lock.json</strong> file too.</p>
<p>步骤2: 通过 $rm-rf 节点模块包锁删除节点模块。 Json 文件夹或手动删除它进入目录和右键单击删除 &#x2F; 移动到垃圾桶。 另外，删除包锁。 还有 json 文件。</p>
<p>Step 3: <code>npm install</code></p>
<p>步骤3: npm 安装</p>
<p>To start again, <code>$ npm start</code></p>
<p>重新开始，$npm 开始</p>
<p>This worked for me. Hopes it works for you too.</p>
<p>这招对我管用希望对你也管用。</p>
<p>PS: Still if it is there, kindly check the error it is displaying in red and act accordingly. This error is specific to node.js environment. Happy Coding!!</p>
<p>Ps: 如果它还在，请检查它显示为红色的错误，并采取相应的行动。 此错误是特定于 node.js 环境的。 代码快乐！</p>
</blockquote>
<blockquote>
<p>leaning <code>Cache</code> and <code>Node_module</code> are not enough. Follow this steps:</p>
<p>清理 Cache 和 Node 模块是不够的。按照以下步骤操作:</p>
<ul>
<li><code>npm cache clean --force</code></li>
<li>delete 删除<code>node_modules</code> folder 文件夹</li>
<li>delete 删除<code>package-lock.json</code> file 文件</li>
<li><code>npm install</code></li>
</ul>
<p>It works for me like this.</p>
<p>这对我来说是这样的。</p>
</blockquote>
<blockquote>
<p>Change access in node_modules directory</p>
<p>更改节点模块目录中的访问权限</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chmod -R a+rwx ./node_modules </span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>I resolve this error running following code</p>
<p>我按照下面的代码来解决这个错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm cache clean</span><br></pre></td></tr></table></figure>

<p>then delete <code>node_modules</code> directory from my project structure manually or with following command</p>
<p>然后手动或使用以下命令从项目结构中删除节点模块目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules</span><br></pre></td></tr></table></figure>

<p>After That install dependencies again using</p>
<p>在这之后，再次使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Delete node_modules and package-lock.json, and then run npm install. It worked perfectly here(run command below inside project root):</p>
<p>删除节点模块和 package-lock. json，然后运行 npm install:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; rm ./package-lock.<span class="property">json</span> &amp;&amp; npm install</span><br></pre></td></tr></table></figure>
</blockquote>
<p> <br/> <br/></p>
<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/42308879/npm-err-code-elifecycle">https://stackoverflow.com/questions/42308879/npm-err-code-elifecycle</a></p>
<p> <br/> <br/></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 tunneling socket could not be established, cause=getaddrinfo ENOTFOUND 8000 问题</title>
    <url>/posts/1004.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200315093901.jpg"></p>
<p>解决 RequestError: Error: tunneling socket could not be established, cause&#x3D;getaddrinfo ENOTFOUND 8000 问题。</p>
<span id="more"></span>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在使用 Picgo 以及在 Typora 中使用 Picgo-core 的时候，我正确配置所有参数。但是还是会报错 	<code>RequestError: Error: tunneling socket could not be established, cause=getaddrinfo ENOTFOUND 8000</code> 。</p>
<p>更详细的报错日志为:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">------Error Stack Begin------</span><br><span class="line">RequestError: Error: tunneling socket could not be established, cause=getaddrinfo ENOTFOUND 8000</span><br><span class="line">    at new RequestError (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\request</span>-promise-core<span class="keyword">\lib</span><span class="keyword">\errors</span>.js:14:15)</span><br><span class="line">    at Request.plumbing.callback (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\request</span>-promise-core<span class="keyword">\lib</span><span class="keyword">\plumbing</span>.js:87:29)</span><br><span class="line">    at Request.RP<span class="built_in">$</span>callback [as <span class="built_in">_</span>callback] (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\request</span>-promise-core<span class="keyword">\lib</span><span class="keyword">\plumbing</span>.js:46:31)</span><br><span class="line">    at self.callback (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\request</span><span class="keyword">\request</span>.js:185:22)</span><br><span class="line">    at Request.emit (events.js:200:13)</span><br><span class="line">    at Request.onRequestError (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\request</span><span class="keyword">\request</span>.js:881:8)</span><br><span class="line">    at ClientRequest.emit (events.js:200:13)</span><br><span class="line">    at ClientRequest.onError (D:<span class="keyword">\2</span>0200213<span class="keyword">\Reading</span><span class="built_in">_</span>writing<span class="keyword">\PicGo</span><span class="keyword">\resources</span><span class="keyword">\app</span>.asar<span class="keyword">\node</span><span class="built_in">_</span>modules<span class="keyword">\tunnel</span>-agent<span class="keyword">\index</span>.js:179:21)</span><br><span class="line">    at Object.onceWrapper (events.js:288:20)</span><br><span class="line">    at ClientRequest.emit (events.js:200:13)</span><br><span class="line">-------Error Stack End-------</span><br></pre></td></tr></table></figure>



<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在网上一番搜索，有以下解决方案</p>
<p><strong>方案一</strong></p>
<p>系统关闭代理，不要使用代理上网。</p>
<p>方案一对我无效。</p>
<p><strong>方案二</strong></p>
<p>npm 代理的问题</p>
<p>在终端输入以下命令行尝试取消 npm 的代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure>



<p>我有一次这样做后正常了一会，但是过一会又继续报错。</p>
<p>直到我 Google 到了国外小哥的<a href="https://support.qlik.com/articles/000049076">一篇博文</a>，拯救了我，请看方案三。</p>
<p><strong>方案三</strong></p>
<p>国外小哥的<a href="https://support.qlik.com/articles/000049076">博文</a>这样写道</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200314152313.png"></p>
<p>最终的原因是我以前在环境变量中设置过代理，我的环境变量中有以下两项。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200314151642.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/Snipaste_2020-03-14_11-30-59.png"></p>
<p>在环境变量里面把 <code>http_proxy</code> 和 <code>https_proxy</code> 两项删除即可。在 Typora 中测试图片上传也就正常了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200314151922.png"></p>
<p>美滋滋，终于一切正常~ 😁</p>
<h2 id="临时给-cmd-设置代理"><a href="#临时给-cmd-设置代理" class="headerlink" title="临时给 cmd 设置代理"></a>临时给 cmd 设置代理</h2><p>以后如果需要临时给 cmd 设置代理可以使用以下 命令行，这种环境变量只会持续到cmd窗口关闭，不是系统环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:1080</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>



<h2 id="Typora-PicGo-Core-SM-MS"><a href="#Typora-PicGo-Core-SM-MS" class="headerlink" title="Typora + PicGo-Core + SM.MS"></a>Typora + PicGo-Core + SM.MS</h2><p>关于 <a href="https://www.lzskyline.com/archives/87/">Typora + PicGo-Core + SM.MS</a> 图床 的使用转载自博客 <a href="https://www.lzskyline.com/">LzSkyline’s Blog</a></p>
<h3 id="1-安装PicGo-Core"><a href="#1-安装PicGo-Core" class="headerlink" title="1. 安装PicGo-Core"></a>1. 安装PicGo-Core</h3><p>因为Typora已经原生支持PicGo-Core, 所以只需要在软件内下载一下就可以了(PS: 下面这张图就是用的自动上传, 很方便)</p>
<p><a href="https://i.loli.net/2020/02/26/tjwK2zclRCE6JUy.png"><img data-src="https://i.loli.net/2020/02/26/tjwK2zclRCE6JUy.png" alt="image-20200226192555818"></a></p>
<p>首先点击上面红色1的位置, 选择PicGo-Core, 再点3(不要问我2去哪儿了….就当他不存在), 并等待下载完成.</p>
<h3 id="2-安装-smms-v2-API-插件"><a href="#2-安装-smms-v2-API-插件" class="headerlink" title="2. 安装 smms v2 API 插件"></a>2. 安装 smms v2 API 插件</h3><p>这里是个大坑.</p>
<p>因为 PicGo-Core 默认的 smms 使用的是 v1 的 api, 而目前 smms 已经停用了该版本 API, 所以导致 PicGo-Core 在默认配置下,  smms 图床完全不可用</p>
<p>翻了一下 PicGo-Core 的 Github 发现作者目前还没有把内置的 smms api 升级到 v2, 但是有其他开发者通过第三方插件的方式解决了这个问题, 所以我们需要安装这个 v2 版本的 smms-user 插件. </p>
<p>直接点击红色5的位置, 根据文本内容找到 PicGo-Core 的程序目录</p>
<p><a href="https://i.loli.net/2020/02/26/HbgqjYC5c9Kl1kO.png"><img data-src="https://i.loli.net/2020/02/26/HbgqjYC5c9Kl1kO.png" alt="image-20200226193128224"></a></p>
<p><strong>注意, 因为默认的 smms api 已经不可用, 这里肯定会上传失败, 不用管</strong></p>
<p>找到目录后我们<strong>在 picgo 的目录下启动命令行</strong>, 执行如下命令, 并等待安装成功</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\picgo.exe install smms<span class="literal">-user</span></span><br></pre></td></tr></table></figure>



<h3 id="3-配置-PicGo-Core"><a href="#3-配置-PicGo-Core" class="headerlink" title="3. 配置 PicGo-Core"></a>3. 配置 PicGo-Core</h3><p>安装完成之后点击红色4的位置(红标顺序不代表点击顺序), 打开 PicGo-Core 的配置文件, 按照下面的格式无脑全选替换就行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smms-user&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smms-user&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;smms-user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Authorization&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里替换成你自己的&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transformer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-smms-user&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>没有Authorization的自己去这里申请一个: <a href="https://sm.ms/home/apitoken">https://sm.ms/home/apitoken</a></p>
<p>申请前需要注册一个账号, 这个没啥难度, 就不细说了.</p>
<h3 id="4-体验效果"><a href="#4-体验效果" class="headerlink" title="4. 体验效果"></a>4. 体验效果</h3><p>保存配置之后再点红标5的位置应该就可以正常上传图片了, 我们直接在Typora内粘贴一张图片, 就会有相应的提示。也可以在图片中右击上传。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200314153045.png"></p>
<h2 id="Typora-PicGo-Core-gitee"><a href="#Typora-PicGo-Core-gitee" class="headerlink" title="Typora + PicGo-Core + gitee"></a>Typora + PicGo-Core + gitee</h2><p>更改上面的配置文件为下面的形式，记得更改成你自己的图片想要存放的文件夹名，以及你的用户名、仓库名、token 。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;visible&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文件夹名称&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户名/仓库名&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是你的token&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>在 picgo 的目录下 执行如下命令, 并等待安装成功 。（我的目录是 C:\Users\用户名\AppData\Roaming\Typora\picgo\win64）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\picgo.exe install <span class="built_in">gi</span><span class="built_in">tee-uploader</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200419182318.png"></p>
<p>然后就可以上传至 gitee 了 ，需要注意的是 图片不要大于 1 MB ，因为 gitee 会有限制。</p>
<blockquote class="blockquote-center">
<p>常常问题是提出了，但还不能解决，就是因为还没有暴露事物的内部联系。</p>
<p>   ——毛泽东</p>

</blockquote>



]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>pip更换国内源</title>
    <url>/posts/23493.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200507231100.jpg"></p>
<p>python 中使用 pip 安装一些包的时候十分慢，因为仓库都在国外。国内一些大厂或者高校弄了一些镜像，因此我们可以将其安装源设置为国内的仓库，从而达到加速的效果。</p>
<span id="more"></span>



<p>国内的一些镜像有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line"></span><br><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">网易： https://mirrors.163.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">北京外国语大学： https://mirrors.bfsu.edu.cn/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br />



<h2 id="修改源方法："><a href="#修改源方法：" class="headerlink" title="修改源方法："></a>修改源方法：</h2><h3 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h3><p>可以在使用pip的时候加参数-i <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例如：</span><br><span class="line">pip install scrapy -i http://mirrors.aliyun.com/pypi/simple/   <span class="comment">#这样就会从清华的镜像安装scrapy库</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>simple</code> 不能少, 另外注意各个仓库是 <code>https</code> 还是是 <code>http</code></p>
<br />

<h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p>升级 pip 到最新的版本 (&gt;&#x3D;10.0.0) 后进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<br />

<p>如果您到 pip 默认源的网络连接较差，可临时使用镜像站来升级 pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br></pre></td></tr></table></figure>



<br />

<p>另外说句题外话，在清华的 Tuna 下载一些开源的操作系统和应用软件都是很快的。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200507230040.png"></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/#">https://mirrors.tuna.tsinghua.edu.cn/#</a></p>
<br />

<br />

<p>参考：</p>
<blockquote>
<p><a href="https://mirrors.163.com/.help/pypi.html">https://mirrors.163.com/.help/pypi.html</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p>
</blockquote>
<br />

<br />



<blockquote class="blockquote-center">
<p>不要问我心里有没有你，我余光中都是你。                                </p>
<p>​                                  ——余光中</p>

</blockquote>



<br />

<p><br /><br /></p>
<br />]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>善用佳软</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客添加樱花飘落的效果</title>
    <url>/posts/64617.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200422083632.jpg"></p>
<center><font size=1.5>Thank you Susanne Jutzeler for sharing this awesome photo on @pexels for free! https://www.pexels.com/zh-cn/photo/2099737/ </center>

<p>偶然看见别人博客中樱花飘落的效果，感觉很棒，于是我也给博客加上了樱花 <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200418224427.png"></p>
<span id="more"></span>



<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510163656.gif" alt="效果"></p>
<h2 id="新建-sakura-js"><a href="#新建-sakura-js" class="headerlink" title="新建 sakura.js"></a>新建 sakura.js</h2><p>新建一个 <code>sakura.js</code> 文件，在里面填入下面的代码。代码来自于 <a href="https://lyuan.co/">折月’s Blog</a> ，在此表示感谢。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stop, staticx;</span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUgAAAEwCAYAAADVZeifAAAACXBIWXMAAACYAAAAmAGiyIKYAAAHG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBSaWdodHM9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9yaWdodHMvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcFJpZ2h0czpNYXJrZWQ9IkZhbHNlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NDFDMjQxQjYyNjIwNjgxMTgwODNEMjE2MDAzOTU1NDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNDVjOWViOC04NDc4LTFkNDctOGRjMi0yZDkyOGNhYTYxZWQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE4LTA1LTA5VDE0OjQ5OjM3KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyMjVlZWE3LTEyY2QtMTY0NC04ZDAzLWFjOTE2ZTAxZDQ1YyIgc3RSZWY6ZG9jdW1lbnRJRD0idXVpZDoxRDIwNUFGNjZCRDlFNTExOUM5REMwMzg2RjlEQjFGNyIvPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmMzNjIzMy1hOWNkLWNiNDQtODViYi0zZTgyMjEwYmIxMjYiIHN0RXZ0OndoZW49IjIwMTgtMDUtMDlUMTQ6NTE6MjUrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiBzdEV2dDp3aGVuPSIyMDE4LTA1LTA5VDE0OjUxOjI1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+XCpBoAAApBxJREFUeNrs/cmSI8u2LIipLnMHosnc59Z7jyxhjSg1oggn/EWO+SP8B34JhRyWCItk1at7786MBnBbWoNlZm4OOLrIvc8+t45bCjIQjibQuKuvTlUpCdva1ra2ta3zZdtHsK1tbWtbG0Bua1vb2tYGkNva1ra2tQHktra1rW1tALmtbW1rWxtAbmtb29rWBpDb2ta2trUB5La2ta1tbQC5rW1ta1sbQG5rW9va1gaQ29rWtra1AeS2trWtbW1rA8htbWtb29oAclvb2ta2NoDc1ra2ta0NILe1rW1tawPIbW1rW9vaAHJb29rWtjaA3Na2trWtDSC3ta1tbWsDyG1ta1vb2gByW9va1rY2gNzWtra1rW1tALmtbW1rWxtAbmtb29rWBpDb2ta2trUB5La2ta1tbQC5rW1ta1sbQG5rW9va1gaQ29rWtra1AeS2trWtbW0Aua1tbWtbG0Bua1vb2tY/3xr+o7+Bf/2//z/+1OfPAIgJErGbMj7M8fue+O1A7LLjcxyw+5hwZMbgQnLgKIftRsgMyYUjBYNhOn6AADiMOGDCyIQBCflwwNEdw24HHA5AzhjHJxyQwZTADLgmHJPhDRnfjo6PlPHbNOJDGZgEZsIgOAHPR/yPwxv+28MONOBghIEAiXce8LkzuAG/vRP7o+EzAcMRyNlxoJByxj4T/8su4+UgPE3A++jg5yfe/lvD73/b4eVfM17/zfE//y3h6UjsJ8f/9N8m/Of/Cnz/d0cegHES/t///Q7HHfG/+/8JT0fABGQTzIEkYMyGf/0vBh8N3/99wv/rP/1/sDs6/i//+t8DZhCATOFwzPj4/R3/MhkOmPBz/47dB+CY8LZ/w/NnQh4cu88dppSRU4abQwbQCRPhdDx/PCGbI9f7JLXbRfHpYw+n4MOkPAAUSacBmfv30f/rf+f+8m+GpyPw8Zrhl0IMAmK5KgAOWCY4Ib6r8pO+/hiV/5c/LyyVe6g8TnH5P/3f/q8bwv2zA+TfZ7HtvKbY4ScCOxCU4EaYE04hxb0hOYgEATAJTsGYkP2IQQBocAkkAGMBQcdgA47HA3aMg0cQkhmOGRhEZAMoIpdDhiREQYzXJQBDSQwygFGLdwET2/3c2luLx9fXzjhKk4hs8QTmsd2OAiHkIR4wZmFKxNMRGI7C5xPxt3+Lv+0GvL47/r/fBgBCJpAcYPwVAICbsPsE/v0VSJl49if8+/C/IEMwCIQBcCQLUBeBlOOFi4K5wanyGcgAiPEe5XSApInJsllCQkAVQNFStpTcUjoakxtNZqJIwtIx2XigpUyaG2xSdvPj9/+aPy3zoORuorKVD7OCoZfLxAUgMhegrEBYf1p8x2pYdxUKITVEXIBhewFit21bG0D+HWoQDgJwiERSAF622CFNgpsh5YypHPck4S7YEEcjQQhAsoRj/ixARHiBOVpAhsthNkCKPZwCvNvTB1Ugi7/dnpunr9mQYJjoGGWLOooVUAcDbAWV6CleN9sxJwzOeE/lczgakQ4OkzCNhBuwOwo/n+M+u4Pwsbd4dQLciJefwvR/CLDsgyWVP+SMxx0HgSCe8h7/037CwY7YY1cPeyQzwAxe3j9FeBKSwOf3p7Q7cuQ7d0oYCbPkifvDnqaULNvOhAE0c7p2ACEbTBwIjhCMYIJhAJggWICsMuQTnEdCB7m/7f6rv2XLb2781ITP6bdpSgcrgNhFhTqJChnv9eGosILijKAnCIvlxQsQbwC5AeTfM4IkACdhHtHUlBTxjYSjEYMATxHGEQyQK5GFlZ3daOWsLxgjyiphYAMVJIv9XsIC9xgHg4HIDFBzUxyM5QCUShxBYifDwYSXErlkCkmEkaAcEDFRERUKmCxA0ARMiIN5EHBIcT2JkapPgmVhShHRjZOQU5xExqPw43uNQCOqffp0iEAegDShe9Nz4DUcK6Aa9nmACLylT+ynXYlwC4CbYWLGHoTJzFxj8rTfH8ZnE14pfqP4Ctke0EBoEG0gMJLcK3J2Lx9XIrFz2kjBIhSvpx9NgI6QPgR/B/Qu6YNIo8kHTpYcU0IWcRw+NJ9HIoAjIAroTja/FhWeRIblUoGQHShSZV9J3A7bDSD/jil2xHQgiOTCNJRoToISW9rYsi2tnMZZ7ieHwSINhSJyYyBc7N8J7hmkAS7IAhgFYRRxNGFww2SOEQm5/e2IVZ3AToY3HiEMEfGWtJkIQGRJgfsIEuU1wAzKGUmEM0oHgwMYo3aWJuG4B3IidlNJlQnYFJ/JNMxvfXcUxqNw2AHjJxalgPbpuDAchePOsJsGJAz4Mb7jPx2/zyUAAPsUibbD0+v77nlwvEJ4pfEbHN9o9h20AEnoWcQe5FgvRrIU6wSjCRzNbIRAQBmug9wPcv+A9A66RR4vp7vk7hIyQTc3pckwCjo+C26atIj3r4PhalSIdSBswFeAsAEiojyjRGAgfGQ5LRBRTdjWBpB/F2ic910i9r1oHnQ1vpoml9splFSZ7XkC/AxZ7V5wCAMY4ZviEDMLgByGVEDTYSQkxyji04BnByY49khz8bBEgBkBkP9ucSBaV9+K9DRenxuQLeqC9TnqfZ3AWHJit7IBBmYgHQU8AXkE+AGYRxS5c4AufO6Ap/d4CB14+hA+98Tr74LXskWLeuNV7Y7A5154+knsfI8fw0d/WjIAw+uwG7lLT7T8QscLhb8B/AbxVcI30r6J/E7yReArpReSexhHGEeAVivEIBNrBUWYIP/UlN/o/i53wN3hzHBM5UWCJheY4cwwy0lJOEKi++dTdqUOIS80TuZwv1z3C1FhD4g1KjQ0AFyAoZWovfyhRYq/rQ0g/z4gyZq/IpXTfyYxOqJpYRGZycqODUDuYBoiNS6NmkSDKyOVWqXkAIeIIl1wd1hKyIdPjGNt1EQEeSwR5E8DkgyfzC2lriktSp1y5ylSWyqaQl2xoDaacgHI9h47gFRJ+02R0gNAAiEwABJAHuMPDpOQzcBJSBn4fDK8/MzwFK/l5V34t78ZYHMzCTWYKwXO3Qfw/h349jux0w7/y+7f4HASHEzpaWB64WivML0y41mO7yC+B0DiheR3AN9p9h3CK4QXCi8AX5H4DHJHlWoHlAMUNcl1gPs7MsiELKNzQgaZReS4rwQgR9GYmcQEV3bQkTnZu3Y05fyEI7y8rXujQs2NHdQSiUWKrH0PhoASAwgLxrfnyIiGliKjadu3tQHk32upprGtURN1O2SWRg1hU9QFkUsTptQRo/tNTCU6nKYJYzl8MoQdAJiBk8PlGC1hUmnBqEal0egZakMFbMEHu2OwrgSDIeqMQ9c3NtROdjwyW3SAWdPs2jcuzzeUjj0AmBMTiXSIDnNOhEod8rADcIiGy/ue+M/lL7oRr2+O//9/SS3qHnwZmTuF/Yfwb/9ZSJ7sv3x8p/yZlnZ7s+HVYP9C2t8A+4aBz3A8EfwO4G8k/ybhO8hvAL4B/BvEVwLfALwAeIH4VEJ2h3SE6x3SO+QfpFPQEbIRwo6uSWY7yI9AGgmMyvkIcgA50JjgHEEOFAY6Bk5INJl2BubrjRMuosI5Rdae0EmKXKcJILXHm6sBKaVF/RGurUGzAeRfC5Nexm/MgamOwCgiqADN2qgpoz4EvKS50ahJLXIKkPNlJ7uApTpYLt2Z+LvluKpZcWaN8ro8vkSVgwxHCs9eRnvK7cYAdbQ6ZAC+swSjJYIUHENJ6VVGdI5G2NEjrR5YGjXA23O82vEg/PitSzMNeH4XpgRMI8AM7HNL4xlRnWhZ9t/9D3gaNDz/H//tvzxZGp990Ctov8HSfwbtPwH2G42vAJ8B/Bbb8DfIvpN4AfgC4hniC4AR4gBglJQgOOSfdP0EPcN9kvMIMtFsiHOBEpgGAiZnYsTAiZCJTIASYANMBnmCmQmeIA12QMInjWU0oQGXz40zJEI7LFPkRMhWokKP/SoATw1UI9LUIgI9LQWBceLa1gaQf5dlAHKNwkr9Owk4lu4t5ZBx0XwgCLjXqnzbgdkQyBsaqTRqWhWfAZju5a/WbYzu+ABiStGVzgwQy2T721agdSfDkRkx+CNMc5INenRUss3znZlzJ9tLFJmc8DKuZCIwGGzKSEchjwZPMf9Yu7fjUTiOpVFTXs/uIPvb756ePmT7AwgyARgH8WV0vg6y1+T2Yjb8liz9N0rDd5l9S7TfSuT4n0H7TzT7DeQLYDsAz2B6BflMYF/qi0NpeZeOdE1bBbgTriTCYJYAGKUksv6eKCVQJiiRGkQNoCUQA+GDkBLgAwYlMg0gkkEDMAwpY0xHHc2RwZPGyVh+TwgwPI0Kc9lHSorMRdSpeZi8gqHmUiYsTlK5wLkb4WkDyA0g/6JKpJMYSif7EzO4tC5wqQVaS7GWjRqQIC1mHjG0TraBoAWo9o0aszEaNXUApetk77Ih07HDUEqkpQ1T7r9TwrtN8KlEjCxRbN+oKSMp9HJQ1eiSbI0aMUoHqZQOWDrZ2gF5IMZPlXonbJxg338XRRikJHBH4uX//P/ML0jpGbRXks8mfjOkvxntO5L9zWz4jTb8N0zpPyGlb6Q9C/YK8jst/Q3kd4A7gClCdMb+a8b5xNNNcdaB+DZuVUYFDAMcCcYBsARggDSUKsYAVyIxKvuRRESgwAhwonGQ5QGZOwAThR2TJhsxjsDgUx4+/xs7+rNpngo4AcNpJSos6fHNqLAAbE4xUuY2/+zvvKXZG0D+5SuVs/rMDomzd40ya51IcsASpEIFhJCY4HKk0qxwCKmM4sEFV4z6ZJ+Q0q7UIR1GQ9aEQYZPAs9u+BimBYbXCHIisHNDLiwTw3mjxrpO9pBxdlT27JpMRK1UMaRtk0MJOOwN40e2//SveXg62n50e/6XH3pS4p4Yni3ba5L9C2m/Uek3Mr0AfKHZNzL9C8jfMNg32PAd5DeZ/UZL30R7htmOiXvQ9rUBTVr5cNkiqPa61b3D2qwGoUhLCXII0NOoqCPumHiUcwQ0wG1E0g7EBGCMuiMGug2QBrmPzDiIHAAMoAYyJQMSpGEEh4MVNmUuJZK+cdJHhX2N8hQMLU5W2UpU2IGhuomFuRYJMKul3zWT2dYGkH/n+LFSDlm6hsJkjPGW0pCwfEo5VJthrBGb0TB5xoCumUMAaaYcjmnAYTqU7nZEmQMNDmAsqbFhnXJYj46xDMNlRM0UXce6drLFZSe7giJKpgpUiuPcyXYDhk/x+aenl5++e/7g0+j2bEzfEu03o73S+ULwBbDvNPsbLf2NKX2D2Uu5vIL2HcbfmIZvMPuGZM8wvsDsqTRFDMlIszLmwnlWc65ZtGHyGh/DS4W2lTe8zICnAe4DrKTMZgniyKwjqAGmJNcAq80YT8hIck9wGSkTUjIyRVVYKSJaJINScqTxmBNM2bwUiqUrUWFEhEolRbY5TZZhmSarn4EszRmfh9G9AGpO1kB1WxtA/l0B0k872Q5MKcI18wDI4QhMiWXULiiHaEPlbNxqz3OjRpVewplyyDQuKIf9wWU6jfQ0N2G610sQA6JRM2ruZLNUJU872T3l0MrQuiNqnUcDMsRxorl24/P/7Pv//f/ozyBeYOnV0vDNLP1Gpt9g9g3kE2ivMH6Dpd8wDL8hpW80vsLsGcZXpHJfS68kn2C2gzHBzFCH560Dxu4zmqPIOts0b2ojRLWhYdZ6IDGFj1ZzFDxF+J4S5ImUyd1gTCUFTyQTzJMcieSAXMBRiQGSyaCo/KWjp0xnPVedNk6WtcIZDE+jwqhNFhAsoFgJNW6lLpwMuYIp59Es1Kh1WxtA/r1hMvrOAZCpKNO0up/ZYgh6QTnEspONQuhgNyvMtoPPB39POWx8aUUkN1mkzo16eEI5FImxNGqoITrPIeew6GT3jZqpNmoATCUqHR1042hmuwTuTXjmgO9M9s2Mr6R9o9k3DMN3JPtOS99APsPSC82+I9lvGNJvsPQdZi+MKDHqkSk9wzjAaCyt/Dpu1MqK5Gl42803laICT0QjyvuPOcHCdnJHNGAsmjXuibJSK1WCEF1rIkE00VNoXdAgJgJJ8ZEnSoOSBiolSQNTSiYNhog+RUxrjZOzFPk0KtQ8XF6jQt+xpNlzvVGljlxPoOYqDR6169vaAPLvn2KjU7tx4DCUtFkq2++jHAIGyWFIFyiHgplFo4ZWGjVapxxS2LcBoNJDL42avQw/LEMeZYHcQX0cUGyNGpsbNZRcTjBDu72npxeMLzbaa4omyyuZvtHsN5KvoL0i2SstfUeyfynp8zONLyC/YUi/IdlvTOkVtBeQe5IDzAYYU4sEO3BbhLu12cE5bZ5BspxMvBuuNLaTT2OXKNJsmgFSIpkUnE6L35XgSKIMYoJ8IBlda5bGTulNCxpgliANMB8BO0ApUT6kbImUvX/nQgptnmOMhgxPokIZMaWICltkyXlf6zvcdMHc599PwXDLrjeA/CtX7SgndTxkYQZPLaXRYh4yaIOlxRCMGnfQUmvUNMqhA64TyqELSoKRIYsm4pPAixsOKeOpoxzWRk1QDhMmO8QsZn2Na5TDMr5EIhk5PCENL459Srvn0exvTOk7LX1jslcwvdL4Cto3pBI9WnSckdJvNLZaI81eo76YvpEstcX409FgYddUWUZXC0mcpuZhC5qINPPHu43dvFUB0FrQcxjkA+QDwSRwgJDgSjAOFEYJRzgToKF0vaPLHcdLuc4EMoE0kAOMiWZmE5MdkXiEcYTbpEXjRIz6YB4rGJ5EhZjrln1UOF/O+lEzAHtXm9wCyA0g/8pGDYqSD4r02Th1jRpFo6YBkgtMaKl4pRxmTaVRE3VHcACNsCy4hJQGTIcPjIzmjVI0ZhzCrlAOq7pPTzn0bvRo9FSkttY72RBwHIRjgo0TxidPz8PA55TshUwvNHvlkH4zS39DgF13YYhDmH2LdDkAEuQ3kC8lWnyC2UjaGKjcNVWkReS4TJuxLKrWcSl2qKD+ffeqOZ0ihs/RKI0xhOU0CKkOiUseMmcOA5noPihAb4CYKCaZDYAKmHpEvuIAs5Hyg8xGmI3GNI5HH3cfPn1KftwRXrQsaxe6jwpbp9sjyrWabnfzszqNCl2LSLQ1fFhS+cEi1t3WBpB/9+ixUuhOKYclovREpOM8OmOIiI9cUg5DG/LQmimqrBkGBFbKobyqPtY0PFg2qaMcLnDg5LhIMRY+Uw5rdAtgkNnLgUP6tOF5sv3A9C1Z+s3S8MqUXkh7jXqifceQvsMsmixM30C+wvgK8htSeiH5rTRkvpfbngAOJAmjtWix6zjXmmKNaJvAQz803wPpXFxdnrUUz9X6NewjzWXXO05UMsBGSCNcx4gUbQS0g/sEcgI5wmyEYwS1I5QV23cwTnBOJOu2PYEsINNsGvKQn96P+Zjgb//ZcprYGicBgL6MCCsl9TRF1gyGfVSo0vDRYJGKr4z/bGsDyL8kgmxipyVKi8ZGZUIE5TD4yx3l0NXogbVRQ1oLlAgid5TDFg0VdsxMOZxfR22keO2Ol0ZNTzms0dUow4GOZw9Gt4MmID35sN8d+ZxqpJjSb0zjbxxS7TTXkZzfmNJvsPQadcUWQb7C7HvUIUtaXSLGYJ90tUXyvLi4YIYQ6IByrvXqvKjGC8U2dpVilU+tpuOpfFjugJkRGuW+gyHTLUueg96ECVImmSXlKNsyI2jzU8AzXULcJmSILjED5jRNyZV3U/KXn9nfPvRBufrGyXpUWHjWJ3xqWVAR887K6A9XGz3WcbzNN7GKDSD/Qpis4rlDbdSMNX32og15QjnUFcqhO5g4n/g519tUBqPdc6TSRRuyNnJqJzsJmOgYZI1y6F1cupPhwyYgJ9t5SkTaJeNLYnrhzl4taojfYKk0VNILaS8FAF+R7BtS+h6pdNlGey2/RzptfCK5g1lapMEATnL7lQinn6w/AfhirXAeWhXw8/qZnQBph43tk6c3ewtAA4CnUqrNJF1kjujRIoRXqPqAnGBWwNK9gOZUznnRYyMdNAc9w+B0aH9E/tu/Kr+9+lEzvT5q0bk0V3yuJsRMZKTHbkXG7OQz6wGwB0V2Cj7asusNIP/SGiTqzFmk1VWlJmlGBCLP0l41XSwNnBrZWaEcsnwNHkUwGAsYJsHSCeUQYQDmcOwq5XAyTCaMLYWtaucRNO2VeKQncngelJ5pw0tKqTZXXsg5GsQwfGdKtab4DNoLkn2D2d+i3sgy5M3XEjGGlBhhTXGjfUxcDfRaCl3nWQwz0J1OVGu2mJgbTDYDXzoJx9RHp/GZN8ohu46GEZANkO9Bc8AzaBOoDMKjIMiQOKsgWPkwpIPI7ScoEi4iB5Aym5lrUt7/nqfPQZ6TJssnUWGaxSrWUmSqsLRWokSsRKGN+SRujewNIP8xVqMclpojywFAzLYF9QCt9UMWyqEVyqEtKIcxGM1JrZOd8xEp7Zp1A0lkBaPm3YBnGY6cFplnsXYwN/LZx6fvenrGwG9mwWYpIFi6z/bCxG+gvZYI8ltJoV9gfIbFSA8s7kOzVwD7Uo9LbXrbeAEI+0YLunpi1502Ow8S+yutR8MFcAo6p6csOj5YgCWWQEkQO6iLBJeXDGACmRURY+hE1u3ABDBqlrIR1A7gRNok00TDbsx+fHrD9Pbd8uGbCcLVFPmeqLAHwrO3j3Ppu21tAPn3jyJLSpQ0Uw73uQjjJoKFctgyJPcYncMsLZaYcPTphHLIpk6e5dilAdPxs1EOM4SRhiOEQdEdPaUcgjAmSwlpN5JPNvAbad9Ya4fkK0qUWBoqLzD7VmqPpRljESEanyP9DjsDGF/Aop7DhQrHEhA5lyPmkIjz9M5ippHLuqL6dPvk9xMcpDpFJMxNn/aArs6rOvJTRY2NkGigxgB8ZJBHEDuQE8Bo3AQY7kBWwAwbB3CkcZRzB+IIsylE5tNIYGfExGncPR95PE4+fRimlNF8jf6IqLCnltJLXdznz2VbG0D+3VfrZFfRB5872dGoCSOq44Jy6G2HtmLb2iiH5T5tjLu5HAo0a5TDM7DWMtjyoBymIY27RD6b2XMRh/ge9D/7RvKlpcelpkizVyS8wtIrLH2PWUeWYW97QeJrqHenl7Au6LLeKsWGrhlzFsydjuU02t9y8PviGel2e7Y1d7qm1VyILN+DV0Xuyl2y+DKlAbCR9AFmO8EngCMzR1kBQnEEeJRspDTCtFPSERk7Jkwi9nTPgE/FnWeitMPAPDqm17fJkVxTQvC0L0WF5ReufA5trLOPOisYllFPT8S027jYG0D+hRFk7UnX6mFSiOdWl8PJUjBeOINH72zXLLZoHeT2CuE8mRMMgOUJIFXKYTYVN0Ifnrh/5pBezNIrYw7xpUSKdfzmhbRvAF9h+AZLLzP9j9+Q0jekcjvtOSJIfgP4XCInsAcq8nK9se9anwAie5Ds0+/TGuXiOVdS9v6uNtcYAwwLCFbZotoeVjdyZARgpuwjyD2gieSoKB9kyjKArLBoyCHxWy5uOWZ2zEuLusSGWWB8KXSHAb4/mPBD+v27Phor9EpU2INhBULT/Bm7ET6iSfp6whmne1sbQP5lKXbTdsRMOawuh30kdY/LoVpbZ6Yc1vk+L3ax7jlYN61+WcRzRXyY8zXvxmEYnxKGV6bgPAP2EmISjHojUBkwpdGCOvQdQ93G11DcwbfClnkR8EyzZwCpAZCwmk7fcWa5L2rsgXIBnKdpNpflxh5IF4SbWUC2DlbLrEz1lNCLGmC2j06ZZkNqoa8IYhYYK3VKQTPfvmj4EIGMQax2Mnki8+5Af/7wfNj7wa14KXaZQANC74oTVgBwDBEUH9CJU8yPpUfcSg9bXubtWN0A8q9OtcNhCUlx1OXSlGlJX601VkrfCeXQgRn8aAvKIYvFgmvuZI/DALqCUUMiy/HkRgC7JxueacMrWSLASKVfCLwUEPxeosbCcLHXoqzzjU2CLH6PemM0aEjuEPqHJ5HahaLgSTFiFehqHH62eQU8yfWI8fLZa/X5iE4+7EShe+Z7awQoSF7a3oI89HRi3CdH8E8HmNs2WgYxgdrDFHOVhuICzgnME4H9IOSnT005MWvQlKYKvWWkp6j0TEPRgExdQ6ebHaMDqdIKs5rqz2nJZVsbQP7ljRp0LoFT8WcxlEaNF23Iely7Qna/iUlUvvU55TDm9RS86zRgmt6DEyNvquAC0rNsHDi8KKUXtHlG+4ZQ2SlyZEV2DGVMJwa7X1qjxkKyDAwhW6SWUu/CyuDkzZ+2y09T7AZyXZTG7raODdNG4XtBitOU+xqAXsJmXkEKzlqYsBApDqYTCShSbbMM+QSzHeWThGPpWGcQI2g70CeQR5K7YNRogjiCGgnsREwghpmVo3Fw2+0/NHFPPz7Da91QaaW7XaPJrPaTroUv9ql5Ysdu3w7UDSD/ARo1JUK00smuHO1shOXiKV2sCrIcAzsPmEI5nK5RDov9gjT7ljhE0tLTsHsysxdZegHthWTrQkcEaOHqx0inafY9utB8IdMrUv97F0HGY8e+C3yxccKVSG8BZNbV/dCJTixT7kXz5ioYnozqXIs411g4beZydu/pRTMQJcORKHVIcoK4I3UUORGYRI4gpnafUIkbFaLrE4gjYBOJUcQuuuOaSB5Ndtxljdkx/XiVW52uLN40lmd1cKtakDinIZ6CIRfSaZw52tvaAPKvadQAPeWQjqa6bRKOZhgVZl81nawmXrXmGOm01ZnFmG9slMMyDK04gIOAEY8fPA1DGp4xpG9geo5h79qd5rfSkAnQrCl2cKWDAYMuqmSpSSa+lLnIpwhh1wDn2jYsGttL5e9+5OYEKC81b26B5KXXsjA/6wbDy3fULILMolzRasZR02AEvSlAkVMBvSOAEcQYGj3sxoBahLiDFCNAsB2gwtu2oCiaRkA7unKk2j69f/rEo2T5clS4PA9xtlhozZslGHpRIs+77TjdAPIvhsnwoTEM7kgSDmVqBPKmvFNtEFpXeiYglqeZgbBu9drAqdqQlXKYM4dhGJiGZ6ThG9MQqTLw2mqIQKH/pVdCRZiWryC+weqYj9VI8VsnYPuKiJjGRbh1Jz4uDmNqCZK6kvOuNG/OQPJiyn3ltdWZSz9piplDnfBDWFUUcKwkd6cBGIE6D1l+kkeA8zbDEc49SC8d7glmR7jvC1jGdsOEzBxtlJwJ5HGCf/s3Tp9ppiGupchtTrIAYT84HgrlgO/QLBrax7YVIjeA/MtrkF0SlzyuT12jpkrg991GnVAORcDKrGOl0Dm8MWrC5RBIw2gwjmm3e0EaXsPyFKW22NLpnh/9ihpVlq513IbXIlz7isqeIZ9o3M8E8T5BXQO2C+IRutSn0QozRg8UDnUmc3b6Gshz5K6iwejEMNpAO3UuylsRMpBogHEHVaaMjgj2UDBsGj2RXpo3s8BFNHWmMvw6hdhF5XnT4XTA8tM7nvKLNCUdZyAErPiYz4IVRbNzDMk7txNBI3UfE+fHbGsDyH8YxKw87GzAmJeS/wvKoQNMbJRDVZdDz0iaxXNHFGUeF9xz2j+/7DkML7DU6IEgvoP2CvC5a768wvgbwDnt7uuLxhgIJ56RUhkI53DWjOkaKOuh2uXq7Hz1iv9oHyZWoLKV5s1a9ElejmJ5GuWrWGRrZtAUqbgFolQQrq8h1G1HsIBidKy9ux68a1dwtWdwzIXYlGH0xuUuEmmwlAFOnPLOsk37g46UT5aL9m+JCqN5M4/znEaFvTf2ormDUoPcIsgNIP8hokiiyEfkuVGTo5OtRNh0QjksNgs95dBgOGqmHNYok8k4piGNaffEIYU2YwhEvBZ/6W9zlMiQJwNLBGnfQMQ22jPIb0ypmGgFU4ZRb9xdjgZXLFV5IfVt7L5LIzxYkaY5AUlcS+d5IejklUbOaWNmQVcJ/ndhOHXacUFBdAPoBtoOVqTOqAKMjPEdZybtKPqudLOjgSMbI/G1ifQRxCgxapXhwR12ssQ4HDlOxun9VUesRYX9V2KnJwGe8LUFTw4fHJ62Ls0GkH/xuko5LC6HScCxWTkXymE5SGfKYSqUQzTKoQAmS6Ol4cnSEGM4xm8QX4uvdIkWESk2AijJ2pCxlmaTpcaYwiYhHmv7JiPUj+rwJBLkJYZMB0Z+oeh1rX64FkneYh1eUgVae23dnUktM/MEMBtkRYzYS0Rpc/rPVIRFpKRozIwkByQOoQKkncyOSBopHlWoiNHZxgjwACAFKGIs9d0MsyPkExIzpMnc9uNR+Z3KVDHOxAkrBh3rprxEN4cPOQCxgqI5VBwqt7UB5F8eQVbKocpIT4BhoRy645gGjNVfmlpoQ85DJmod61nFkUZyZ2l8YhpeYYVPXaJFNh41OhC0l07l+3uxO4gh8Jpip3AgLAerLWt8p9YHvCOFxUK/sfeROcNE/YlfxAIQT8d65hdXbW6logvpAOhBpIkRn/iubCZ8SiRlIwyjpFAYN02QTRCiW610hLiDFOmzsBMsQ17qjZhozIJN8LyL+iUUabjnQZaf35Q/XvUZNPK5BinTDIJddOjmjcpawkeYE2lKSNmQctoO0g0g//oUu8magUgufFaXQyxrQ+oyO501GaJjrXAZtKe026dhfMUwvIDptYsOq5rOa6UPkqWDDb5Eio0XgK80fgfTS5Esey2jQK+IjqytR3q4PHR9rdzYOtUn4KhL5lFdmn2JSrhIv3kHOHYAeVKTa7NYrnn+0dTKruEu2LhN85sTUeZ+UmvYBKI6pEwhS6UWaa66Pc50RY08OtlBIqSKOvnMxAndJ+T9IU3TPk+fTz7l8bgAxUVUWJg35gZza2AYF2sSaNvaAPIfDC1nl8PcXA6FUNPyNlAemKBqP9odlobJJ9sPL3sbdt8xDNFpZhn2BkrXGt/mSBKRTgNl3KfYrLINfL8Go4ZhhQDu7qJYPCJ4cDev+s7nuxXFrgnytlopz9N/aT5bEUAimHMrj7S/Ue7DaqpVO9tWJ/stIkSVOmTxD8SsQp5BTbWjXTrWRR4t5iIJTTI7AspwTlDVkfRxEHYvH3b8/PbpP//24Smz2MTaIipM2WCeELfPJYaqi6lSQyU3Js0GkP8gUWQ9GBvlMAG7Y2nUcHY5TPVYlYNIRcNHcDjHYZfM0pMNu1em4RuQvgF4IYpeIxAdaFhEiOQrYK+lKfNalL1fmSK1jm53BUd7KjJlt6PC0/usCVGcguKicX1aT7wkNtEB1K0Zx9XIdm2SWkuwXESf9W/5PPKjlaiVWvjoFM1IIIulNDGRnBRd6bEoHO1ozPI2EjQWDvskaRfzkxoBG2m+A+woaAyQ1L4qmSdhennf+TTiMOSkNFmLFNE1Ymrnmtap02MDxQ0g/wHXrMVYhFClMOwCYS54MlhxOURxOcwusKj/JIHZOI7j/gnD+NpYL80Eq7BegjIY+o1FiKIo8lR71dqMCRuEVLQcgeewL30AHO850IRVIIxSAWbb1VvqPfdEoLzyurjyuk/GgNqoUKcRWcewUJoz9Jmb3eYnuYxKCaSgH2Iq4rpTaL+HwjiJ4GQXaTQVNXJAuejdldS6EAhpcRYtRWk69fJjh/Ew6v3Fj2U4do4KEeImVUVq/QvhSclhWxtA/oURZNOGZIx5mxcwLLWtnIjxEATdefylb9SkYbd7Kt4v6SXmF/FcGDABkORzEY94otkTyKcSMbYLw02w3GbxO7CH2XBTBecRYDytPV7CO115XKvx6f5UfK0Jsxjb6cDx7KEl6gqD8Koc0qjYdQ4ovpvz+ZpOAZMQRgjPBCXWVgpV/gjn1L4PaRWhKFQKoYlMZZzLqRD0cKeihjhm+XGStOPxelTIJpnXAPehesa2NoD8O8BkjUas1CEnq6M/wpGz3L/OFBmQOKQnDOMzhCeATySfQAS4oV7nHrQnxvYKkPvycwZN4xOMzzTW+4wXI8YzrcV7osaTIfCT6FG6cL9rKfc5nK2MDHH9PRjvfOm9M4SKnWy4UM7q5mi2XI1N0/4O+lpkgrAvJkNFOBcOMxQdSQ/JTjljLAGKAcYio1Z/0ilJpEOMmiTcQU6JmJ4n5o8xu6g8fwbF5eK0KYXzkQFtEeQGkP9INci6i6aCG9mAsUnrn1AOBcidwzDuOe6foPwE8Bmw8jOiRViAJsBnEjVafAIQ95nB8gnWRZSw5wBVcE2k9zoonk6F6xzoFpHfnbJkZ2bQddDpWk59X6Tb61JcfHg/62mITlpPOaxeNdWeQZ2orrMMlQcmKhwc90ghmkshy92RKmumMGrkEySnNAEaIeygdJS0AzxHJ5zHYOxwB6RQ/Uk8DoZx0DRNzA4mXYoKtdgHefVr2dYGkH8tWrLrZBeAJBQuh4U1MzqQzEhLe9rwBOkJwhNoBfgUUWMAYWyjngtQ7su2JxBPjIhxD+Kp+FI/wdI+6HEFfR4p3J+msTrpYtwY2VlV4lmjFN5VCL0PHMmVSPNarVKlzGEsNgy589U+oRuiu94MvwofUCKdOxknJAsZNGmibFRSKP84dtGx1g7QEdIEYEdogjBJOsIVohhmpeONEQyfmx0sS8c8UVMnhHceHZ7Ul0UCmyfNBpD/eFFk7WTXRk0Rz7WgHGYL+4RkaWTa7WGpRIn2BHBPtNR5P6fZ2JWO6K7wgvfRNcUeZjuQeyQr221fHPkSfrWj2RcT9Ug4ogduuqNzdNqEIdfvwJO6JK5Ekb14BZfgR2cwbIQyN1ll0Agli3YMPRRGwpU7xHGFidKk0CuZypjPBCiLHt3qiCqPMWBuE6ESbTK3pg6UBTlhnkTfHZWnYXJPJedfqKDXRlPvrU1shoYbQP5DrUWjxkPZJxo1oTnoyTAegUMyaBjsWWnEYPui2B3gZngqPtO7th0FCAMw42K19lhA0Qpg0vaI+44Pz3vwxhjP4x/I1Vrlw6+HNyJHPlBH7SNNI5AtZrl7S9iyrbf3jT5LQBeLwK6QEsE9oMzEo2A7Vt9sY0bmBHkmkVXqklFv9OhsU2WbHJSzno0IIZkAaaDpRaY3TJ9ucNkMiMBS1acGwEmcDb62tQHkXx1BqmvUpFKHPDTKoTAl1mkSM3EH2r6lywX4iC6tZkmnWaLLmGOMNLs1ZSy61i215nOJLtOXQOgWOJ42YLQEPOlK3fIesLr4Oy6o93AdPM/ENFaA1oN2qJo+O8NeFyp9EsyptJe5SYtZRJrHXCQtABNMwLAHsoMUphDlgXtUMkXCS2fdPQDQoj2DuJQPrzPPiYF2FWEnH5h8T/rbqEOmWn/cOjBMiJ+zS/hWhNwA8h8sxe4ph+ooh3Wa91nDSKUn0BrYRW3RajpdfscTWNwEaxMm/GXKOE9cgmfNSifcL5TA7wXEe1LtVXC8kguf1h9P/bFPX9OqVezaS+f1qPEaTbKl1/PraWZZsJB2rNlA0eFkituoMEqbtccK/yk63gS0K6QpaHAieNBOZJfMm64d4YAcromQwz1LyARzKJBjAjDBUAbQ46fRxh25m3TMWT6NMMw0bJW2uWMqFh0bOG4A+Y8Jlc3EK3bQyYB9Lmf03TBEGpyekCLyK9HiC/uZxuIjQ5b7lJlHptLEKVFjzDxiX67vL36XjwDjGUPm/gNt0aC59LgL5cPrjZcr4HitVolrf6uOJ6JjzljURtrrLypFVjjZjjbqQ5TRxdo9T6RgI1xOYBI0gtgh40hpJ8dU5idHACPoY2nYjNGw0RDbWTxtNACFpWMYAe6MnF6AacoH/7Sjq8WJzfyj+alb+betDSD/gaLIGiSx2bzmcsMoJRuG6FqHx/QeQp1ZrHXIaNCgNF/M9rUpQ2tD37sKiESpTQJj0Nh+sSuzNrt4mlqfDHpLK4+/ixlza9ToCqrySgR670fApYDunKYzxnhaYDin2oTHPKOV8aRUHucRFNKYxDQAGEmNiu9lh6yJxhHwSW4jgVHCDtIx5lQ1wRXsHARoAtgXm/QJQBYwkbYbwEnK0xEfbkEuREKCgTAWWKRFOcA2gNwA8h9uFRMvX7gccnSOGNK+RHq7SKWxh7iLg0HRfY665J5QgGMZEI/HcNcAFK2bXZ+TFwGHJ3XBa3XFS2m0n9NjzqJFfaEBczNy5PUI9FdKCD0tEaUeWecdK+HFBPqsGxnzkQZZGbQxQVMZFzKBwgCkndwnShOYJtAnuU9AyjTV2ccJ0qRo0ITIBZSLj01QEUNQPsMQXW6ji/DBzJ+y54Hm7MBQRrgx9jnDNii+AeQ/VgRZlRwr5TA5cEwCmEYwBZhJT3O0aE8kS7OmMGWMzzGAXJkxFg2ZiBqfYfZEoDZnngt4jlebFOgpkV9Io3+VR32j5ngznb4FhsbHQbOfyyzAyPJcKu6SoXbGAnzsZiDLeUIxRM5kwc7xQsFh3pE2KTxpJpBOs6yoPZbh8RjnobsQoz+5FDWn+KrowfVGBjGRFkBpdHLIrwccPwb/zKlojZ7MqVrYr29rA8h/pBX5mpMYSh1yhCUbUpl3tKdCHXwGbE+zfakxPjcWTEodMNY6oz0h8Zm0+b7RvHmOOtVpGZRXE1VV0PA75hUvAKBuWbHeDZzCXfOPi0j4D4gmyeUQfN9EKr6vKCK66lPwWoP00GhsdcrUE4VSAn1PegYti8pw7MOIQxPEDCGLmMpw+B4qTRpoV8QsolZp2JE8hlsiM82OSBjT8Lwz/8xZ05QU6XUCYcUJc2NibwD5D1uDrCuJ6bc87Gcwq6wYhsJOFaGoTZiIEJ9BvsR1vlZzLsaIT+lWl851FPQXbBleAged9DUvpcXSn/8p3RMxPqrecylKvHeUqXc3NBYaYh+SYaZJ1qaNGaDcGY7NlgiiDTGwr0ziKCuRI0LlB9KR4C5Sa2RJRxA7gsX3JgbNy8B51CeNGYk7GDOGNO0nTfspTMSKTBAiDFULcv+2HZobQP4joqUIe9W4DwFbe4Y6Yy3wmSygSQT4mT0jxTaWn61RY71ARTBuYqRnNq3mIynyqUDF2u8rXtX3l2EvRJe90RTvONvwESfFC6/hEkieqpV396vU0LaN8/OEgpu6Jk83azlbnoM0KnMEfQKwD+Xx4q0tZbhCNDcEdZ3QMcCwptUMMI1tU6TXlklGqk1mI48ZyO/5cOizBj74UW1rA8i/WxSplmYPg7E0WIT9TBG0ffhP2x7GPRP3SGkP2B5WWDRmu5kxgx1phWbIXYx9cFd1rXhvSrkGDg/nYV9kwdxMq08Ebe8N0/mYoMWq4O7C0kHLKLcqkPcMG6F0h1WMvkpXuzZ15s+WHNIAZ4jhSjlSawWLxqIG2eYeiX00aJABHEuDLsNKoyaAMaLICp5mu2Q22dtxIgsNkdVJZwPIDSD/QWHSgDSkFNEfuINxT7MdaDskq6M6e7JQDYNPvWNKMzAad4TtQOwa3xqoNMT0JWB8NI3mWp2yalpWa9o7sbM1jHkZ9b4kqvGF2gdPJsd7kKzvuc5F0os1RklcC1cb5mGlES5fpbFTHW87NQ6zEcl3yB4ptWOS5xj1gaLOGJeJqKM+2CG8tUcE72AE609O7THSjsbjmIYj5Idea4PaAHIDyH/ICBI2wHahqMOSInMPS/saHbLOMtZo0orARAx+72gFOIsoBYAAV+OeKEIUD4Kh1sDxFqjpNNqcQ0498jwXwYz3RYf31BxvDoavxKsNEM/rlqTmURmvwGjFilWAF3YNZtpigNMchRYBIIMwyriDa4JppDBA5SdUZlgxgRyg8MsGkOKnxhJRhpd28HkSFD8lDQOYMBWieP06pPVG2rY2gPwLAZID0xApdNrDsGcKYIyOtdWZxT0shWdJ4pw+G4eWRofwRJ193MGwK+A43AuKvxRN9pqPq/Pj/PMaOuSvF9F4DnoXn/I0Cu4iTJKhCVlR1LumjSMUfur8pDSfRBbVAhvoGgAfBA7wAnQqP6kBYgrwU4rvWAlCApliOl2p/NUymEQrKrwGJpMmyiep6vVK2PrYG0D+dWDYFeQ1p4+WjCMtjUgWF9oA4xjgZ9XgaYQVsCMHoPwkRgL19qHwqseiCj4ATOCJOu8jlcNTJsw15syqWvgVHvYlZfJTIy3cEQF+iRXz+G1nJdhe7d0Qw9+Nb118bNgJ1KYaPWJm13hRK2/lhyInTiQYE91NNKNkCoBLpS5DiEbQQFLu1kqJhEVxWzMwtt9BDoNp+jT/OPjSqGxLsjeA/ItCxWkAfIwJm927h0iumTGlAWkYkAL0aBxBG2EcCyAmsl5HEUrFDiw83SpQgHJbjHiMxa41PRoU6FKkeEuxZxVBrmznZdsE3hzVeSCVvicNP7mdVx4X5ly87o1TGzRFeYRC4WHrZHCcMQ95irphY2nyGFLkbOBgIK2oYaQicGyAjMYKoFYiyfgJDfU+BVwHGBOGXfJ0mEArehobOG4A+ffAQi41Wi0BBziOuwQfDGkqFLUJhHGHZDukQhlkAb6oHwXgFQHccmmWoQCLKG67rT52BLhjPP7XyLVfzrhOGjN3p7+88Tt+mT5+Czx5x99r7oY1NWi+NCuCwU1jt+hEOtbl1RbMzBBPA0vKzAJ6YJrBjgXwPLaLA6VB7kOAoyLLqD+BYU7R02jD7pjH4VgkNFone1sbQP6xZS9eEK3uliGMPlnECmQkiB1SKkK3KOM5AXyo3OngU4/dyM6+AiKJuRaJrvZYQZNXmGPSdSy8Gj1ekDKTfg18O8vXuQTY6UX20mP1g+8z8YfNxPA1K9sSPXZVxw4IOxvbM+/sApSmog1ZIshqs7MAyJgcJ5hgSJJGOo6CD6XGOBY7hgG0AEFogDCQHKTSqFFr0ARARkaRICUKw8jBIHn0kTaA3ADyF6PC0+t34UBT6FeR+AM0kLQ0YEi7ovK9Y9QNd4sLuSOxn9PnqsbD9jgQI8wWAEnw60o9a3XDi8PfXALm4ml0OQLVSV5+Zs71B5y57gXpC1Yt7L+8CyB5cUeRgn0IzN40laZoRPBYeuoiAjQbP5qIaNEHuI2UDjAkRmNmiGgSg4SBYhJLFGnZICa6EsTQxJ3rltaiUiE5xAFmyDmMa7VpQm4A+WCK/Idkc4rOJeUNA0amMcAxOtBRY8S+ixR3MIvtZmNLrc0GgANrysSqB9jqlQPjerr5JrsDXGu3XRwKPwFFnYeDelS+rOLkNQXwRdj+i8C49hx1XOfK61sC64qxWKs9ls0dSBKaQdDURYroxn2slzwiYEmUQSpjOrWu6AmA0d0AJXoy0Q1uBriF900YLcDNBI/naPVLkEZzIWE6HsGNib0B5B8YFX6lIkcBYwYSaGZWO9Q90M21ImAgNLRu9HzbSNYuNUMgFYxmjWEHcQcrvtbXIqCLDZcLmo6n97klcnsRhGrNYaWux2vK4Q8yYK7dfmV+kvfc/+SxrWnTK483OmEAYz0zUjOaVnzkqUZmD7gSaR6gFl3qBJcBiapGN9HxNkZDx1TVMQxW5KJsblGrXI+fTAkKVd+tgb0BZPcG/s7voA5Q2OQYLaV5DKcAnjCC6tPkWdKs2ioUx0IBT5T2MDyXbVXt5xnEc6k73QRD3QOO9wLrCtjpUpf3KjCuRYg36H+PjOzcy0rUHRRGnYIkTmwjsBCl6BBxlkqrVUyd2EzMNxlESgrZHclAFRsuWknkQ1ySMe6D2sQJDmupenO5LVL0xGFIPljxscWfGyVsALmta2l2MgJmI20oplpVrYcBbGG+9QyEYo9gz6xKPuQLwBfAXsr9Q9ACKD419sx4vuER0NaltHuOYG7XKq+A5EMp96Wi4C997idAJ6yn7F9J17lSp23beSKHdgKcpuUMJbCsSc7fA+GWSJnkBi+D34YEZyJkmoEwle//jDnTmjRAbeiUcR8bOOwM8jAP29YGkH8JPgoY05CQdk+0IaTLtJAvewaKbmOA5p5W1Xj4VMy1omFjnJXBg01T2DYcFuhSDzZeBrbFMf4IFXAVYR8tcXwBCPkFIHs0erw3vV7ch3NTB7boSuuEU77obosnNcyz8wVb53nuQg8dGI5lznEGR2ko87ED5P32erFGPwQGmiVNPgnaypAbQP5lywDbFwHbJ0j7rimzbyl1a9hUr+syMA6OIV6BodALB7BrzLDOx50cuZcGtE/51l8uHOhO1HxQoeLB2uHN7V9t6twKaO00NT4X0uBC/af8Ts5Ne52re/cKPyUljrEdMIGNUhiRYwVQ1rlJWLGGteiEy0p3qBhzK81VH4cEunubpNrWBpB/fs2x1sRn/2VDSkEFlAojJlgysZPTQCaalaYNE2gh+wwayaCRkWUouLgvRWXKVg9jPhjp3dJxvJom8wFQvXHbvdasX603XhCiWE3L7wFldrYUXAHW03lNzEDZmuF9CHmqOVlmuCkyOtp1XKcMjKr8XHzdbShTi9NhdCPLrJkXnrhhom/1xw0g/xQoLPtVB4ZsvvJRfspAolk545ezeJjKtR29zqhJhBnLfYNeRrGMZ3B+DIJjrQKY/Bpj5o8f7tAV7NXt9NpOo7A/MJ0mb9+NvBtYr95+OrzOlQ+9NHfOt+NUBINoTyMJjIFa95i3JCGSgYrtxCyYAe5xCoV1NWUS8jKWK8BlFGgubVXIDSB/JSyctbhXgFAUvOxh6lhoMXRBErQQFKgRISsoVtCLCFFIhWdbo8WhCBeMUTdSAi0Vb5lyPz02p3Ft0Plsu9aBULeB8XrN8YKT4iPp8D3p9DVg5BfHh8g7ouprn/MMknM0WbnoPI9mibC89Fbu5Dw42g2kspyxFyk1SroNwj24CiqD6xIJYcj4k60zNoD8326KjCUYegHDyhI79XCqwNiuG81gg1TmG9l3EzH0Iz8QhmL6XpV5BoEDIzVPqCl4KbwTLFqAN470K6Hi8qYbPtdn2++tN57pg11Opx+NGB+sL/KR57p3jrSf1TxLtbl8rtNJgf57WB/SVzG/nOV2GkUHlPt8ShYgiY3DqFhF7LFPe+IOwxA6P0cD8nFLszeAvJYir0eFqiUbroBff8x3B5PIJmYwZJjYgGyUOHKuPRZJMo6k1WHwrkPJgf2wONBJoDVhitvptc4P8NU5yNUBcF4AO8xNilMwuUgb5IoSz+m2B6M6PQBsuNF3+cqUEU8+5C+m6GcBec+o0QnALd/n7DfLk+InSRpNDkIl3fYyLG5R1yYH2n4H7HdhR7utDSAjQ12PCtu5+VJUuJDbZwFPzqDYgSMgmhfmy6z8XJkzvTx+6jrTPasmGjhWbouIMYEYCKujGnb3kXcPg+ZWqtiGn3GiIM4rEavujE7u6SzrHHAeALaH8O+ujjgvn4luTBEsyjenJ63ZZpYldSak+GmVHWOxzRHy5aDRRLkZVIbHi2aajISMoUOJMmAOg5HcDxS5dbE3gIx1HJcp8mlxmheiQnRAqH57N6ZBAKmoSJvLQvCspdKJxjTLWC3GdEpUiQSL+iNtTqeL1NUQ4MiQ14/n5FVQPEv3tLR17g/GPqpbOYjPUsirh5TuRCWtp6fXRn7uif5Wosi7qYRfHiBf4VaudbYXpmOYudv9/qTF37NyojR6EG+KmTUZ0kAsjyNoRnoR5ymm1yajF+YNW/sw6pIpmaaJG9dwA8h5t+VJinwSlaxFhOJJSFBEpM0FK/oDptn8aKKQHBYAaKns5DHH2BTBm0J4iRyt/R56joWvzSJYYZzT686p8CwK5LVj90KD4ZKd66Vo8lFfmVtAdJVeyMfCwXsbMw9NJz0CIPfRLBdNlr5hc16LtK4OWZy2C32QNBiIXFzDWFNoI1yRSjsMFg1Bqj4WRiKBljrtoW1tANkD5bWocN7RKcA8GomnQMgTycIWLAikONCsT5lDXKLWGFvKXRR4qPn2XsgCqhYLJaLkWNRZ/rjT/urICW/PP+pe2s0VsLiHT303mF3zkuHjdcIvf8KXBukxa1+e1mD7z9JOuYow0AymBIGwAoSOUPThDHwwhTQakYSSkgtGIUGWGIrk/aiZxQGwoeQGkADyMNxMkXsgbNRZ4YxxIK6DTXIlkDtBA6WhjeXM4DgCGJt0mTQuQJClo92zZsCui91Jml0DKd4ZMX7l2OdKREqe1wm/0rj4EhXxzsfoDpDmpajwkVoq7wRPXa5Hxv5pkKWoM2IeFu91Ho0JXsbGWHxoiKo8Ps/gAjXKjG2EGcyU86Z5tgFkLLdo+FEFDNEBoS5HhdeODXV1S/OJgAXIteaMauQ3G2+BdXsFvXkUqHa40XFv5/pjHBiXAO6s06uLL5h9HXIBdDitgy2FFewKcNyTxv5BPOqz90RexMA/Bowvdfj5hcc/9Ak08kDQCWmwwqxRFwkGOLL9nEE0tVTd0bTtY04SxLSN+WwAWdbT8Twq7Hdd8fZxeP1go4E2AJYgjFKbf0yd5mPqQHFu0MxjPgvQnB/TUnTe9QJ1JeO7dbgu5pD14AdxAzOkP/6AvJZeX3xdj6TVp/Oc94Kj7svAL/9ZFuZURH8qHOsZFFmHvsvJrvpWnEvhVtXezuZVBhzp3AByA8go7+jBqPCBIEcAYSmBqZgkoShCl2gxmi61ez2Uxk0vPNHVK2v90cYSPVbHwvRYoKIl6i/k9blus3Dtg5BWZiVX/rBuRGePguRaNLvaqeb1RtXNCPfRbvUDe8c1kY+T5vb8aTbB21rADAa2Y/4ioxvOLpVe/7wXX3yVIaLlTTN3A8gvR4VXoKAOkTvisiMY9aLqIseRxgp01dq1gKLNzZdeJTy8sUvE2SLHoUuV+Hj6ttJ51pXHPDIzeZaW4yaQPYota4rjIq+PJf5qTfOPqH8uPi9bfkDsPzeenzSk5dxEhIg1mmQbEq9CAIboXMeJKWYd1aXntTZZapJSMYkQaLOq77b+2QHyUTCsd6+kLqEMl+O81O6CJXBUrTHS0gx0HNFqiJyFTsnOxlPWakPzdjuPDPRARrfWkOHSJfAMYO7kG6/1Gppg7B0D6GvVQi6UkC5yp+8Gx2sR62ogrMeemFfS7TUOum7UPU6mCBimg31qXT4dUqYY41EXPc71x46euGDicI5LCZqBoHKeNnTbAPL+qFAnoLh22NTj2CTICIrE1DyNizhplSsDQJiExFm6qqn7FJv5viBfo0VbKPl8hRN3j0DFPbKNq7YC10B2BZTWbBZOwfFugDulOGKdHdlTIi+Bl+6oT34Jmb9Yt7l8X56dmYoMRciZuYAOMpuquc+WOL04iMXsubtv6LYB5BIHBCBzmSpfih+s7VMsx7Ha9O5hHLH7PMIMJlZA88Q4PacuEizyZEyFDdFGNQTYkqfdUqOTbXdENLoNkjc72NeA9e763BdrjJcaLpcYPmtR4d0iu3du/MPTdD12xz7gLkXI9rpcVRCX89kr2DSEF7k5XiiJOpMl2++f8wZvG0DiwPuiwqYt1YFhm4sIBYD2oB/jC/afR+Pk0b1m6DRKlbFQ5xlhbGl3qz+WGqSlpbshRzCUxFl52v1efrXWt5L7drOLPB3z+VLEswaouCNqvAaMV8DxV0aD+IvRIHm5pnpt21dwUme/Fi72EiVrs3px0psp3IRbFH1IwJqlrOYsoLowpqZfsa0NIJG7E2kfFTatUVRAzFHJlhpAzjvtfDCYVIWaDY4EFukyVNWdWaWH4A7V55rdIDg4kph9sVGvY8fZ7XBYrQmsAcDpAX1Bv1H3pOE9uko3gOYXOtO883638OxeaiAfiHLXOvlfiW4vPXYxd7oMgVnGcjo6Q1ghigyd8bIne7FwDXL36Q67/GvdmE8VDMKWYm8ACQCJpylyiQyltl/VfUtLg86L2LH/PNBypQpyrBauNNsBCN8Zsxn8gF340mBPYA8rBlzEvt2/XcceAay8O51ezEKuN1x0K6I5HeW5ysZZYc18RYX7RmPmLNW8P2e+oXN2B1heGsDnF+rBa6UA6kQhafESy47JdTk6dc2Y5rsQE0FyoRfJbT/bexDhkvKWYW8ACWDHY4sKy+n0fjA8jagAOA1Pb5+jkPYweyqgtouLdqAVUNSumHPtYWHa1UWHBTzbTGQqqfUsiXb+p3EzT66jPLpR/bo1C4k7WTtfSalv1R1X73sniN2FXbz/5hO5u19aC7C7cPJZloytT3xQxyCFogXZCeqqbicj2jx5N2xpE2snG1sXewPISIn95NDnHQWibla3tmbUthHwofKrq64j4/cdemZMa7hYKIWH7Fk1dK/d6jR3wUHQbrdpz7rJt7UJL+LqqljFhbGgPxg077ZD+EPAsRmAX3+AVj7TSxMBX0fL5d9YNsy4SAeqsk+Z/xG7HZlGmLMIWbCNCVVVn8rL6XdgiUyJrfa0rX9ugLwnKqyKugsgXMPMODCsqPDOIraVI1tNucjEBnizswhqx7tuJQkjgyXGfrznygtYi8wYrnUV1E4aCGemh6fNnUuKPmu/X/0cb0WCvI1n/IWvc7XWqMdS6z9zXfp8z8evoj8YquBVAr9IniHEcOmEifQQk2qRI0m6OH/tZKMq1hkgS3bUBpAbQK4dOeJ5VHjxroxR7sL+EoHkIkWr6Uox5uIcAVZV6AKYpBGsoz7N9rUOlbPnZkc0ao+hRnnRlRxxqi94r+nUQxHiHSn4nZj5kMTZ3f7W/PPB8F7q5EWlcb/6RkPbWTXUbj41JZCs8va92s/SETMAc75NRUKNSjAzsw0gN4AEil8WT/jJK5hZTszhT3MlvpEPQNsxh9nUvamGJ4KpU+cJebPmca2hVwwXMYRgbk3NT10L7ykJ4Ob4SK1irT7naqNGjxUF76xD8lfS1EugxDsB/HbH506Au6d+eSGj5ok82pmKSnUshAXf2sIopPqlCwZ4YV3V7QrFHyBhJiWksu/V/bPN6BJIiXMLfFv/zBGk22pUWCNC8Xqoo05SyzwTk1LImFnQC10JVpwIyQHSKGKg2PxoNDsczp1vFWEKYWw+NPPA+OMBcg9w0nWsWHMrvGrt+ovRxq1o6+8WzDyozMNTEMPFsaKeP64awbMpRMzbVofyT9TGVeTJWKiq3tLrsAaGJdDjpAwZScqQiklXCnJse5FF+kzsMpxC5trWPz1AeloqiF88dDh7setCWsmMZMIoFFuEohAuYmR0pkvDxsIywZpi+FjmHMcmacbF3GQ19Upf1hpcUwk/w6EiknVmWK91Tve90dZpFHTP4PZXx2UeCvluhXRrz3+RmnM9Ib7y++WXd6kmiSpO0UWDpc7YG7abAgtZOoq0SN2tRJ3ejQN1zSe5/lCB+g0g/0MHkHYeFTb/64f8i5ico2wItR40t8KRVbexeV1rDMmz4o+96GxjBsTwu65GX8MsWVP3ZrsJemcH1+nBfNKNXoBk+1M8twZYmkrcD9r3sGp+ZWD8y3NB9848Pj46JF0GHOmKZ40uRKuVPCNCQYid3dfqV7XouGmefGDYxrJeiRfnZUaoDEIKWZuazwaQAGRcgOJXFiWkyQdkjS2VXgjhdhcV/nWzcsWsCr6sVyY2znb5yXs7rTeYHbr1qD461B0NnBuva9EMwtd1H/jAjOKXc3R+3ZPrSpAprZ1QrnwYZ/Jz5xlAU7qdwbDTV5EroNJBeCGUFnkBOtpj58fEdUqkMnxDyA0gC0A+CIarx9Qhl0J4a7DM4MYGfkvAi/GfVFKg0rjp71drRqj374I3XbVhvr3tRm2xDZX/icfJWnPmq6K6X8mwLz7HtRT8yoe+ep7glRrnLbDvgHQ5dtPoL6IVcJMHJs5A18bIPdKOyLBNwYf1yBZK7LiY9fKA0G1tAPkYEK6AjaQoZwtUdqNZmVMMYCRP/ENYZcpi7ILhIpfa0DiUoBjtERkD5EAq3iI3lLmvHP2L8Z4HdB1PZ/CEO8ED66rdX60xfukxl17PtaBXD551eAEd/6D5yiage8auEYxOD8LgLGWG6heLMuRaxAHiu6dFbAkxvA1rfbkSyIwCo7W9rQ0gr4Ph6X4uzYopXUOYkBmQZEWZp3aohehYg0Mx6Jq71IV6qHAzLE0dVvrhrt2XqmwcnqdmvP6ia71SVw74K6r/NzFHVw78O2uHD2XFd4/x3F95uIbv94ejK9+Fvo6JF6PJWXNzKT61vNYjnpbbOz4tIYii0ZVLHRJFCy2I2FsMuQHkBXAsALgAwwXIsDPOJDD5oBCcGKHCsxYHUDGmEw2bHRoQYoxokWnuWvdpOVhqk0Nzp2slpu6o46zAcl/080gKvlK7/MU0+tJLeIhSeEkJ/I8Aopugtian/EAn/JGywZlljU7UfSpItp99XdEhOUOYJzTGQcHhkBykg/BIyymaMkSX3CHP0M2hjm3900SQfh4VLk++TWm5sGYsrrNofrvMjrl4zqgyYJoPMecmTKUZ2syWQSKZYDSYRb3RYqCcjVVTa5RXOrvU3Zh4KVLUtcaO/mDQ6UDhvDFzi5r4R7sfXgLGW2NMt8YGTk5e7GuJuuN0sVbWaFe8NVoIDyJpAT15Ab8KkswQPBo0AY4MSy8XrQBmbexQ8vi52XZtABm73NSFhyWLlYWoaBsaZ9fpLjtq7f2Zy5jdJBqNQ6EEhgCFWYBfAGKwaKzUG60waqqALjqmDdmeo/jXnKo3rId7l2qEPHEt/DNt4R8Yy7kYOf4ZPtlr970YMfL8hgVWfkWk4/og+fl31mcK3UmbnKNHwaFIjVnEywCbz/i19lhri8FOjG3mdQBIceYPnxBCFElY2tBtA0hAA5dRYZWw73ZslsEIkxfR3Dk1H4/ZPCPNEV9REDdLsOJIWMd2mnpPsX61JmjRHAvZ0xKtWTA8UFC748B9NG3mFzLIlVnGi6rgizHDP7E9cFfPhdcdHk8/mBrxrvgG19nHanFwxqY5+6iW85Y6He5fUnYCAJtu5On303X01LFkmoFXgceS6TSHQ0shZDEMG7ptAAnk3XBWj6Q7rIBgD4YrxwddiLTainyZMQFWALPUGclEa4yH1HnP9I6GBhYvGslmjZ8yyc47wFEXNuoLNcVrA8w3QeNPSodvFjEfuvH6+76HT306m7j4CHgGlGvguZpWN5nGc0AlyXK9eln3dq48uZw6Gp46YgZQxnhQsfqSYJTn6c/MMzaA/I+yzL2BYAXEi4d+BUvNdi4MSleCGZGSlf26SpOxjfbADLQibmZF4ac4fs3PVpV/ak5vV6zfrwDjg/7WX6kl6ko6eepw2PHVV7FngREX5NOuzUBeba58QXziUvR8IRXnH6L9+Gi9YAmG0upkeedSLM0/1f+eQTgc0bmWe9bkRz9s4LgBJDBMvgqEqNFjtzuKgFI0ZzwRzMJwFGXNuJ3hXMim5QgjaVX+DAajFVwttcnZxpWzrWvXwb5w1FxNlS+RrU9mGr0eSbrjWDxt2PDOKOtGtHaNYXPL+6XXS7yKhV+YublBtebf2dRqEXESKjaGcSEcKqZJUgE9eeEhZoV2Wq6/g20UPDMaOJqfR06XzLZJyA0g16LCCoala+1V79FWSnBGkyE1KalZt7E2WWIQPDKZ2qFOMzCWbjaaDuRyW7BoLqerp34li1rUyTykLoAkihL12X1XuqlnSHEqvou7vF5KRe48FD0zqlrDuC+6BT4KiLgs/vvXCjm0dnjpSiNDyCRdXoASZZyn3E5Et1qUR+OGFUgFg+hwGRyCi5JMGLYmzQaQsbsJSCFt5la71idgWDvWJSmJpo2DjgTHrBzulWddtqnxsZv4RPzUiFD8GcLQCyOBHVS8a6CxGHqlS+DYWXqeBHo9YPIc4NZEc9GJVKxg4GVOMK9ni8Kyr3B3VFnPUmvOgCcozF8MY3mlhoq/Nmq88AF5ix5Jh6uY0eCEl12iwlJX1GJESJWTXW5D7YoLDplxS683gIw1PdnZuRmO0qRpu9GZcTZJ45SHxpqpA+DCDqoApzDoUpEuqw6Gdai8SpyRO5jV7btuqJxtwucKW0+6lnrzel2yA7MFSN6Vyt9Rs1yJKolbKuG8An4XwPFXxn0Wf/NaevsPkvOwgOL8ZblqxNgAsESKrdZYLl6hsNYiG4hW+HRgA8gNIMuyTt+kgeGlslV/3TXAa8SHoA5WjUez6kg4CtzNWpDYlVnHIYCzsmwwRByLENlVEca90qOYfy8Ubd0ztHwFxNaz4a+B4yob8E7zrlVWyVdMsW4p5VyLcpdpfnzW1040f2cAVQXBGk0uBI57hk2fKFVQVJ8WqEalNS1nliH9uSIlG0D+BwLIw4V9fKV7qTIjScDsU4OEwrFuQrdBIZRi7AelPknFthiwTC0F78cupNLcOTHl6pBxrWcxzwI/AGjSdcuFtZrlnRxo4lFJssvAdFY6uPakq32Yex0KT3FVN17jX5thY71bXSPFHiAdkAvKi/ucAmywbkJ6xSUdPzd03ADyQgbaWS+0znWvE0GAWUxZqUmYVfMttmZNdZAraj5tdIctWLE2lF7+ryOPDYV5T6S0ihu6JFfzgHzZmar4bYxo9gFNE4G3Azud1DfuPTRPRojuxq4HS5ZcZcTcW9/kymvm+kjT/ZWLXtOxASJJV4seC2smrCyjBVc711oAqkhIEEhTONeEqt7GpNkAcg4+yNnW+oa5VN3FZXUEh8V/2KqBfMhH22JbBURidjhsQEhyHuSdx35mhmFpTlzPovs0esXLpAeUX6UbCqtU5dP65UWgXO1IzyW2i5YHa6B4ExzvFLa45Fe2qgauO2qla5kIV/je95zxzj6HCoTxzITgJbKMlGJu2BTAZFE4mzUi6/6nOssbFgyWaC/fsXGxN4AEAORhvTOpAmxVtb6Zc5FIx0N/pHGOJGcv64UWZBGdYGXNWFUUX3Cwa0pe+dxnB+Tj/RLhTyNDXO35PKD/eM94zb12rldT+A7R7xkf5Z0fwrXONtd8ePQ1YDx/iVzJCrrh8YrGoRYpNJvXer/Um71LKrNsAty3GuQGkCtgeGLepc6wqqMsIOUc9UMVIy0plfQ6LFzFkVzImI0hfMulCVf1p0Hrco/F9vVB58Lbhlz3HXwnXexbPlX31h5PRR74SO6LFVWha6LAN/723X+aVyLHa4B/h7/u2gd699mvKegu+dWz2+HyzlqJn7VA1tK1DkVy5UnyjI1luAFkiSCHhZxir+NiVcG+bScsHxOFQUxhzmWMBg05NqtXY2ynjZ1d6wD2ornVpIvVqKuyZ9KXHP1upmZ/wD5/BShVHOlPr68Cxa2Gyj0WOLwRYd4Lwv0A/NX0erVDhou2C3fVQ0+sFO4CyVY+7LQgq9CtuvGdnlqIbvynXTKADMil+AnPDmaBxy3F3gByXuatldzA8HTyo2mgOA2OAMcqU2YYGghajR41G3KxRpJVvWc25wqFn6oPaamfRr7lVKC7rBF+ATR1AZUu1etuiWjw2vNfaQRdA527mjT3AKge17ZY6+4/7AqxpkPKi1+I1M0uFoADCl2QhU4YIz25aD2WrjVDIDfmHHOhFQqkk3A4Y5Yynn9bG0DGGl0LMKwsOy/FbHG+mDuHrEEqijxmiUXDMWiEmPUeOdcbuRDJpVWNSLYOeDP3Cmner568V0HyJDzWSqSyBpT3AOwvWRXgPGy/9MRnKTrP8/9HP7Rbc673ft6/XN956ENXAFvpYFfuC+BBNSwjO0AuXe4MZ24CFV7AUl0nXLEKrDozvXIUtrUBJICiNlophuyzHi2yGicBVxOZYDRkAtwC9NhGdyoQVlfCyr+e5x+LU6FCO7JSEzmrq50yZVaZMxfrdHfWLO+OLrl+261ZSF5Lp7+wbS3l5bUX9PUD/SKD5lpK/+hJozfbuvn9UXFqK5FhAFzhxhRlcK/pNWfjrn4+cp4pnS0aamqefaXTvq1/aoCcxhUwRG3YpKYs7pbw/O9vJkcqQ91prh0yNdtWIYGyMjgeArhAgntEmVbuAyWhCO2q528vpHqv49rdncYb4HnLoEuXcYf4RRvWR2urWukc64Fojn/Sa730XGs1kdNm0lod9MJ3q8aG6QAOHVGQlYKoZYtG1air/ITUWjas/pwSubVnNoA83elood5DK9dt7mq3QmVEj8xuIge4AhSNEQUCBlNv1Tor/Aizko8asNaa5BD1TMRjtHKQ3Eu/u1cX8lqAtsrHvvYUus2e+fIXc6mm6RdA8o/A5Dv9cPilJ7+vPnHxxNc1XNTnNn2jpt5NfnZ78bDpeKnqTbw8IeeKrAReN3zbAPK4f17OPCJGeSw7UnaknJGmHDHl5ElQbbQEGNbmTHSyB6KCXlwEVMAs9ymKPlG/HNs8pJgekoshz4Vp7wHD01T8zwgX/ki8PIu0LoS1d81T/kGvlV8BxItpwFKeTteUiWs6XJ5IRf9xaQMroNYdUW+fa44sgOheFYEESSSzAGXiLo3mbf0TRZBpygGIU0bKcd2yN53IMh9JuEZZkSkjB0ZKPDQPmRi+XUaJqBJo9fZmuVAFKazjZl8cX1mrP9JOJc/0ZcDTFx94V/T4q0fbaf2SvAGOXwPGu2qOvFAGeMhojJdnO9ttJyZfVTGcFOSzOk/cEh1rMFwN4wWFhSuQQTojN3e4qud1GfOBE8hyd/Pso4JUswHkBpAAgO//9XfQQ0GqORcWwdxc0m2RGPKUMJWxHfWeMq12WFJpW6TXxblw3lYEdTtzruZbczP6wGXxmzYhYl1StSaa+1X5skejPq78fknz4dG5x7UH6aSW92DOzWszVbzzS3gkqlwTO16tvS46hl2HujZelAlkkRnS1EZ9oAyyiudOAiZIE8AM+YT4/SjpCPcJ0zTR5WmDxg0gT5enqEF6cTaUnbFqOExT1BFDFDeRNszq4JzBLrrSQwd6qabfkUJzjjgDHOuw+Fm4yFu83e7IimboykjPpZy1YUh5vPqaol2sNfaRJq8XJ5cv/StjRLhQsjtr62NF8fw+pfObUeMtcPy1guf8Xio/+vR9zL8L0gQhLsAE6AjgWMEO0BHSJ6BPCAdIB7gfJB0W24RPAAep3N/9U56Pmw7kBpBn6/N5V8Z6Ouvp6iBXJiaSaMhIcnXWrR0DRphTbHbWC5I1a9e5822ts02VIfGiAHTxOOSN/PESV/tC6NYrj2vpvXzRAqcDR+JP8q2+67n460/+iGXtrzZ/bllE9Ldbdz+enJ0CAD/ni39C+IR0EPAZQKcDgOMMhDoIOEA6QjjGNi9A6cfYrsmPH0cKXns3y5Lmtv7pI0ieNv1avhoTteMEQ5ZBSOGuXmYbGyMmhCoC+MxiqpJW9Mti7CfMvGqqXeXMbP6dC/y6HwC0PPZ0MvG+Kvx4uwN+Sh3s7yNqFThXwXM1urtEmH5Ad5G8DwH5YFr95b955+23yhur340yoINchwKUBziOkI4Cjg0AI4KcCosmrkeEeQQ0xQUZqCm3H5F9gmtyuf6hdC83gPxHya+nJdB0sSSL6i2nCXKVKI8sAtPs6ooGyESLMdvCnAn716Z3ZiFs1plzwdgcEBe7Ja8Firfz1DVRh0td7K6Lekmu7OxPLWjTN1Ju3vGaz6hM/ZnrEhCtjUDdoP3xVs1xBVx5AzBugaIe9ONZ/biUpVJDjPQ6n4BhLtzqqQDjcVl3RI0gSyqOCcIBjklTPiq7B3izjKJzyRHf1j93BBm7fyphXS/qbaBPpI6mascKVS51ifysPICh6GOFXNhRChu1cGbYVMphUBOvna7/iP1UuANwq9/TnxlFXJqvXKM96vbnwQs58BprZzERsMK86V8L+cd+Cfc2xtbv5129sUSBOqIBZr1eAbBFluU6Jni77xTCFIhmDe0IV+Y06E8tjWwA+R/5DewaLC4Py6IFQBBmiUkGs6glwlIBvQRjpNxxfYDZwFJr7JoxVawilH5Y1H/QzL7srvTwLBOdN8z9in7kh3MkpjVgPBe3OB8Uv8D+uLc+95UaHq+lsHdIgvfOiLiXOscLAPzFyLHVFXnh9fFyTXK5vUSGNRrUsVi7TiLL9ZY+RxcbFp1qVb9sOMQM2kQoKyLO2gnPs5Yf54SHG0JuAAmUjq1m/v6CgABQMMgGmIZIk+sMYxhxhVgFxhn0GLeBxaWQI2A7Ll0NRwgjDDuBA8+Q5AaqrPKku0ZNa750Q8jU8qkXIz9d46YdLbqetp4Fg3/Pxs2tz+ce1L6Rkv8KdfHa/fq51btAUiWCRIztCA4pg3AKLiKAkJyNtyr4sSn/eB0sb4o9ksuzABN3dr1EvK1/4hRbhw4QV+gYk3bhXsgKbvsW+Tl2gu9oFo6FYe+6EzAGS6YAIYsd7GzutWuD5JLNDgR6DGS0fgTyNMjsGzYtEjw14ekroBfGxq+U+/5UyuEquGkh6r4uxssruHnFW/tekYq7rWk4s/vOhgp4rbutEiF2M5DwOuuodjZvdciq8uMtNZcyXBOEEjnWGiYmuB/L/TZg3ADynmii832lwImGSaEEHkA3NPdCFf40rQJgGfvRQHIsjJo2ChSUQwxFQbyojyOtkwt5O5o5HwX5wwqUuizLvdJE4e0I8tLg+MMv9RI3vYt8r7m96s/1uOYVcA2QrDXOcu/bMk25gV/Vd4wGTC51xwx5BceoOTqOqg0cV03LJ6l0wFVS8ZyPcB1Xm39bdr0B5LwzOLBmMwAQ8koJ7PjVTSh3gCGxCU8ggRqIVBV+hqb4Y8WPJlg0s1iunU5kn5hA8cGj80QBTCHPdn6nvra2oMmpzULqFBG1gjx6QBrrHpB8uD/EyyDOL6TYpzXCO6LHBeDeaMbEzY+MXilDiFGeiPxqB/ooV5lrxBHAAW1YHLEtRoLiAh2IyprBAfADPB9KpLkB4gaQ144xLVTsZ784gblZI6SZBYNZARyc5x2jITOL387zjbNj4Rny8TKN95Fh5j6i7A5A1oSbV+TOzM6HxtdA5M+wbBBuj0BeVde5p9N9y5EQWHSuLzFneB4RXkHBGyB5T8hfZhmhI6WD6vA3yhwkcADL8HcbDkdcJw4ga9c7AJM8wOwT1AHOg1zThowbQN4+Zo9+pmxTsILR3yMQBl02k51bRmkhhCJBFBT+muxTvarAZ12bmTBoFsa9O4q5lXp2L77ZxBKPmRt2jBpdYuA8gOSr7JtLwPhQLru2gV3aryvnlNPz1Bci9lvfw33FyUv1R5V5x0MBwwnEAWAZCMeR0FHAAeBnA8w6FK4aXepQR4BU0233I7IfQ/FnWxtA3lrela8SIYtJR5tITAC85pHNpIlN1eLU0zqGOsKooabS89xk6lR76vULGKjHQfJXapEXvLLnuchr4eMXClhflR27aMTFk4hSq0pIt/8Q74oeH4rsV0C0Rp/qJwn6OmTImB1r9Cfw2FEDD5COoo7I/Sxk/BS81h5z2+YFGKUM9ymix21tAHnHmp5tNtEsO6iMGKaWFs8WCbX2uFDgYQKtn28cFiZdYacwLoBxlkI7H3r80qjJuhdNSP2t1yhX5yEbuGAxF4k+ab/kRHiFw/046OHBjrG+9rn17+dGzZH8ol/3F3fLuaGiaKaoRoCaShMmQBMdtXBmzFQ+dtQdm6iFPkE/gnRcqoX+qUKhG0D+x0uxGxIYNBAaEmzK4O/HBC+qPNXHGp3mo5V65Oxa2AlVWCqPi+ZObdY0cV2kk+r+18HxztrX5XR6pTOs00YOznnZJy94bcxHXS0U96bY10SLeC+6PoDEQjfMfQFD/whwPPluVuuQsTHP7BgdJU2AH1rq3FJobw2bkl4fCnDOQhVz5/oQXG4/UDqSRR1yA8MNIG9m2P/yBCUL9xgLkLTfD8Z8nO0QwKrzWGTNMIamY4sYUxHQ7VkzKTyx63gPYjyIHGkc54mTC/WwK/XBy+BymiqfRJFroSR5/lwL1sytdvP8vIKfgKQW/7OPNM+e9nQuU3cOfK+NIC0fG091Wk/l8iRB/lpq/YVT8wUgnapkWSjx1NpidKhVa40hThE1ygqkrgPcPwF8tqaNynX3A7IfJc/96OO2NoC8DpAvI+gCJgc/DrBDRvr0iBrnwe5xjiKDNUOWuciwTRhZwK88prJoBiJuh3EE4iLQVjUW7vE86UGSF0DS9QdFl10auqAiXjrQuYDE9UHNa/7aK3OMp0ZXZySfJjF0Ho3dq6t5Lzj+Skp96TtYbnLUMZ1FswXdxQ9wfZbmzOcCBOvYT02tu2gSWdGcsQ20NoB85A38D/8OfE7g0YHsIMDENEppBH0IlkxLjWcGTFAKi/0C+tpkNzepoUu1E8LzOqlxr3/BEfCa9estwYc1ZF1THL9rtId3bzsFVi6iyRUAxBVAuUXJPgPHr0WIJP+4euMaSHIRaJdutA4xx1ilygIcBR0A1qixgWE3+jMB7H+v85OTTlkz29oA8q599t8/owZFADsLWbNPTyWtTmLpTLPYLKjVHYuTdtlmtZEDxM9WvCpajyQIqgqlrUUmq5HOSs3vhjXoldLXjed/JOK8ZC7FO4qHfv46pMv12EdOII/WKq/InvGesscXQXJm1rTPzkMBPOqMRei21h472bKm6Vhpg5U6WH7XVOwWqlnXBOUMuD801L+tDSABQE+AzOdR7p8Oz8aUShIb1AeDe5U2qxaILKDImW1HFo/rGVADNGtUWQaJuFJ7vDcauzD0rXPtxjMR3a8cCSuzj6dNFy3437r776h52dt5in32UxfqpZfqkXH/q6XMS4ybZkXxdxukVtAFC9AFIHq7XoEweNmOxqmO29Ru96roE11s6AgqhsWJfNd5jjGYts2QbwAZ+8fYMWlcUFbxufZwJwwxiWK0pdqdHgQNFBOoAeIQu5UGVK8a1e42xy7FTgLTZQ1WXQfFh87+OteluJU2L+p7p1zhy2wc/uLU90WhC30xijw7d+gKB/sXgHDNTuEyr3plu/qQulAJe6FbNb8ZoSmGH4DwlEFr4hQrhZqeS5+oPjSeP5w6inTzrnRSVZ9Wrm9R5AaQ8/rwaGqENgpxQKKQJCay2LqiORmGKZercK2VIFaLhSFAUXVGcqYbNuXxe3yveSMdPh2KPk2/1WWwhQ/Dk71+ofBz5WiQ7gYs3YVmOolBr8mN3UiDr4HdWtR5+r7Iy+aH1/72XUo/V0zTVssXytVgC+EvcwDwgeo1IxzCg8Y/IXwUIIzbomP9WWqTnw08VYCSJQW3IhRuOPc105ZebwB5aR1yJxYKs1DlMULWjLbAct2smGwt2DOFk113NyupuZFWZMlbQbI89pLU1o3h6F4cQpcOyEK36+mGF0HukqXCrwDjtZok78K3i0D9R5pprX3+Z6rjayDbvS/eqAPfx1/PDfDAg1TNuEqK3CJBHdq2efwnhCeqkddML2zNHicOcq/8rg0MN4B88PjYpWIZQ+h9osGMZgGG8bNAYbFTICqNkFCxU5hBswJlZd70kaQBNJWk8r6o6BQwa4SkyzVJab2DrTVbgxtH8AUK4sWIUWsAchkbr2pIfgkAeWWKp4++2U6Kp+BIu3Oy4FID55pa+Mn3QFKdKs8B0JHAUdAB1AFZnxA+BR3n7nR1KVRv2rWgHAa1sNYfuek9/oXrP/5U1VCGxAkYzSwlo6UARzPCaDQbWP1larOFtNJdKOztav2qjk0j621g1SQreG6itboHC1e72Fcz87mBXpvo9USwvD8Xdal7S6C3DbqW7pAzcF95Dt4Z6Z3dd4XqeGYbcAKOa899z+zjLTsCPiRZ52iug40Rc+y8rzu2jFehimmejSxdbyH418BRxdpVjOfiowXbbW0R5GJ/noeqabPBVqMNkhiaf3UFvgZ6TGHAhRkIK0ebSoD14hQ2d7BPIhDeAkDdTotuNGIemty50f2+Wm/kWjSJs7opT8PLR3yyeKUksSpSwfO/swJyXxPTvTUuheVY1vw3pBCQ6CPCT6mly58I+uAnpA84Ptp24UPuH4DeIb1DeoPwJukNQFyID6hEj18hCmxrA8ioALGzn0HiYkRH0XWOIydBMJhSeFyjDkMYYSGHZquqDXNnhAUNLx6kl6hzuA2ci6jt/HZdtH29kAKe3E/35GcPNdv78Z5H6oQrH8ZVcsyJ7uMjij28hwaq2/jZK4mH7miNHN8AvTdQA94hvEF8A/QzruMNqMCnN7h+SqiP+QnpHe5v3e8/RXwQyDorpWyR5AaQj9YISmWQgvBujECvHA0x1xguIE3PkUXh8VTNwcpQXwPC0sohTw4VnnVZT6lz4mMAtKo5oJUMfsUTu0/2TgFWt+qND65+hKgYpXE1Pb6vJPv1tOGOv8c7OfLkzVrjSUQvAJOkn5AC9GoECL0HYOoNKj/h76iA6HiD9EZ43Dc62u+IjvcH5B8wfbqUU+Xiw0+G0re11SAfeQOjKhmQ5iEkXgbCOxvMDjAZDtddPaoU+3oFBNVHVVXxohP5F64FOAqL5o5OwFEXwFG4Lr4rLS/9trPS6ok6kK6UXqWV7dc78NIDYIYV64SvAO09tcuQYQ4gdA9wE94h/4AUaTP8A23Mp4AfFD/JD8A+AH5A5feUPgB/B/wT7tOlevS2tgjy8eUejnNOIlUXhSJ+Ww2zSYJi8cCu7JhozvTjP8G/jtojS42y1SA5T6DxzrraJXaNVmh+K4igs872pchTqym67qp96jYo87bqeFNh77UddeGxp9niPaOKq5xqfp3SSN4HoEtBTi8jPB8N+CI6/ATxAcc7xAJ++oiIEnGRYpvwEdFliRxj+zukDxmOm074BpB/bGDlpY491Q61J8CMTAFqrOITTICZiBggD6HcuG5NC9KKFmTtdtuSt80rMv93AOMaUtyTOpEX0+cz6bPFoHlnvXBt8PkaWJ4qZuMEBNs7rf7cK7XFS1x1YkXYdqX2yAuAZleix2up9SXVJV07kckrmKkAGsh3ZH+H9CZXSaXL71FvfIN7pOLSm2qt0fM7XFFzdH9TAOYn2H1zveRdzWm2PHsDyC+VoyiCKr4zMbsowVjtEjiP+LAOhluNIrs5x4gqZ/fCGDInybToSNwyiLp48K0wYarp2ClbRmwaiE3af20o8XTOcUHW+QPSMq3YR3AJwOu89BsnkrvA8Zyb/VAK/QeehiH/gONN8gA+6CdcPyF/l1rNMYDP9Q55qUe2CPK9dK1r1PkO+bsT7xA+KeW6P9RznJ3tTBtAbjXIB1eMQBKQzeM6kpGaf2+K4epmHzmgDYNXhg0NZrUTXofF7aRpcxIlnhgeXioZ9ffXlRLTyuwfr3XNeULA7eqMKv/W6466UHO8o1Z5Mde/M429qWbUg7Ju1GN/5ex663cCgVWfMaaD2oSpqfFHuV4aMnqLWqMHILoq3fBdro8ATr3D/UM5vyvnGP2xEKKoPILZbk1BvpI2gNwiyK+tLECi8WhWhCZK5NdTCGuNsVi8miWYxb5IskWYNGNr5sQgOSsPe+m4ff3AWmRml0xl1hof511qnd7WR6OnNUi/0JTB/dTDPybgwhckzf6A+15K7R+pPfKstnssM43vgn8E6KmvKb61mqTrQ7W+qDL60yLKOvIzjwQ58GHHnH0/gtnL2y2ptGEx4hOd7K1Rs0WQD67jETge3NxlkKKK46TUUwRVj436e+FVlzaO5u0z5bAdTWnOJHkCPKdRzUno5Vh4dp8Blq7dXp9jJbo7BcdyEe7oFusLYHdl8FxnrXPdPzT+iHNhrz7eRfEXu9e3GDQ8id65EtGTxxIhvrX0GfgJcZ5vjJ8/44J3BjjW1PoNLPOR1BtYZiapN98PH++/PU88PfHxsn3atjaAfHj5JOggImdTdsKzQTlOtyqgCYQEmkpxL/LcLjJUE4xSO02HZqTQuSOdjbzocqqoS2i0NhZz/pyX/tQS8C50qa9R8dYuX4kQv3THP8or5gbS33p9vCsTmKK7vIz6ECM7AXQqg+JCzDRKb0LMOqJ2rt3fJY8aJfEO9w8of+YxrFv9SmQrbiC5AeSvLgrMgLwbfBQICXKVESBhYdAndpW5vpvKJh8ewCrd7d7HOw/CP6qetsJlJjqhonrAmS0jqEsK3PeMy/CLaHrJgkF64D12G8R1Tva15763AxzPmbtU+r3VGBstMK6rRYv1PmWER/goM5LvAD5IvoN8h/guw7uOPNokwQBPFlJ9Z4SDRRW6jfJudcgNIB88/gikKtJTJa5ttqhqyi+n6SB7qdEGtkvQYC/c3wHNnRHRvSC5Ej2uRn+4Ehl2f5S40e3lg+K2N0BmOSzOE2bQg3YJV+9zp9cOcbtBdPnG3KLEOs4DvSkaLrUL/dkaNXUAPABznnFUHSDHu0okiZzfAXwSzMxB2vKUYO49RyFeSWfcJt7xWW5rA8jVlRIwGpjI6MWUoXAyBnjO9qzS9tZZTlrDMHUeo7Ng7mkN8mIYdhKOXaoHXuxac0XI5o6pagIrhc3zlPwSM+ZLafalfP0atfHe/PfGbRfnOu8E49XoVCgqOx+l5hjgOA9zl3S6zkKiRZiS3gqn+h3yMgbkP+X5J6b8A+4/M/yD7i4jMAmUkAcDszdR5DrzSADe8c8JfVGMY1u/sv7jM2liONrU8WZa8wWsLJly16L1KAbdcEYiNiyZc1ScbLsgvnriQb0Y51lTAF/h+J5ZItTOJc5x/OIws84juq+C3yUguSD2wLvsBbsrtxTDcf4R34yebjVobj6FVMDxDfKYcQxw/AnXDyiEJgog/oTjB+Q/4rpmsQn3H5B+RNRZnsfw5gnHnM3TMUfGMzlMQh7SPMta369da9RsILkB5EMlSAKfYbsgiEwdvUJ9Os1uCLFFUiyD4pwLW7Bm3FVG0Ll2ILcDt5tR40oqiAuRyuUM+3Kt7rSxc0JF1L0K45dR6E5NxTVw1PVa5dnn9Wggecfj7vXCPt+US9r8E0K9/IDwBsdPAD8A/Kwd6xjlUWxz/JACTDE3c4qQhf+E4S27Dlac0VTyEjpgckxp2KqKW4r9J69cGjJQHRarTZYiXrEQngj71joCpBZ3WgNSluexahlLnnWJ761D3lX7uqPk14PnJaD8cubKXwxO+Pgb1Ree+uxl8/bzaeVktbzvVGqLP+D6HfAf8ADEAnw/5yjR30u6HR3sOv5TfWXcP8t85CfcP+D6nAY7tsriaTk7x0nFjcVlg2ejsmJfW8ZfwCLaAPI/9nIRZkXXkT0DhnX4u9QQa2ExBsIjJS/WC6hMmTmSZFP8Ifo5yLV5vYV4Lq+ne9eOet6BCuq0AQn0g3NdjaEDvI5tc0tNG7g843lhpEiLB1xRnXj0hHIt8taF8alrQeb6ZJBDOMCLaERT39FneMtoeUEMg9f7QPhQ3d5Ue0qNkniX/CDJK/CRpa5YXBobQCYD3We1+PJ2rXy6vDcD2dYGkGd7OEGYrMWJ5FxHjNpeiR/JYrOADi1mVKkPIM87D+R94HgWld0h338m6DC3vmdcK1YLaymqnUSAXMQb654r9wPIDaA/tV040zm7O0y+aE62EABeRozShWbQtRGfudMeNUfXrKgTUV+hA84NmK6TXSJHfy/36+qO+Sfcf8L9DdJPAB8yxSC4ca5AWBSWZQCn0skeEpDnTjZ7c7fynS8ph1sUuQHk/YkoNbkBTnXGmKzRYMz5GJeodaoBybBqqGk4ToHyesTXBZv95TrAnIg8cA3oeN6fuCcK/NrnONcReSMn/qXZzpPbSPyhmeNdTfLarcY74D+hqriD2ph5gwrQlYvq/GNjx+hNtYsNvEN8g6U30GIkSMikgYoZx9J7gYyooMkMJHl0st07e1+0gqVOPvStk70B5MOZl1zwRhdEh1JmcyiGTkT3RNeR61JlhZpd65ZLYOseuwqIJ4B5GVxuq49L1248j5CaSMUlAHwgQvylIuqvPt1qFPmF5z2NzoVjRIb+BqFEg0EPVFUEb8IUqOK25bp/tBlHKFTA5R/w/KHp+CHPn2JRdSSBMuMYjWrBYfE2LFJsSvCUzt/3RjncAPIPCRi8ZsblrIszQNIqKM2gSZBkY2dYBbfZWJnSzRrbH/aGdBkle842dBEcV8HzHjXxvt54bVbykijvpec7y77PueTShTRdv/h5n08fZMg/y4B3SZ/xIeld7nONcRageJd7Fad4g4f2o9zf4TlmH7MH2Hp+B3Xsx7dYRniEWa2nLyUyR7vQr4w9nVEOaRtybQB55zoqZnGiLzMPeVcz5T56YJuVLFhqs5xEISgWemEcsmHO5NCJ5tYciT6W8nDFovWe6PHUH+VujxldzzsvgeGlF3UPk0b3Fjh1JoQhXXpDDzB/TlXMe+R1TQUQ30rNMcRt5TWlDvWdSKd/yovTYMw//oDrp2YR3JmnTfz0Ib37uD9erEU06ueMjgRgFSBtTscXZpHqObLEZgO7AeRjAYLDzcyN5hbAJRBeZLSLZVf5GfZdBfSUS5XfEfSy+rNen+I6w+kGd47CXKgR8pf4zLhguX0D+BaR4wX9x1vRrHTX61k3BtPV6HMtlZb6AFPr0W0HyFf/7nJNQR8s9UYvIBhD30X8Vm8BhB6R4SyO+wHXZ6k3vjUnwsawwYfIg8xcZ8xUgvIGfIYY60FNs6cASh+sdLVPKIf9x0M8wEja1gaQAGwwYKCnZBlpyDTzADVmMMCOPQCKGWAG6304hRETc4AnM4CJLPcBpgKSCwAkVyKER42jLo2+XFLjuWigdVp35P3SZmusRN1ZAtAdkeQCqE/BeaHu2+4jrQhc6EJN9aa1LsKmNUZ15igRKhzpTunb9Q7XAdLHnG4rdB7dSwpeZh2hz6g96gOuA13zFFlPvyKbGIU6gKQEGYGswqgZViiHRXD+jHJoWxS5AeSd6297IZkwJGcyhzHDLCMxIzEAk8yxnZlEhtEL+DkIESXqLL93qbaXUXL1ALgAxzWdwQs867Mo8gwEsNB8bJjgK3OIHYjoatPmMqhejeZugvraTXdYqN4TnV56mHTfizk/OR0h/4TrE9BB0kGuzxIV1p8fkH9I+lDW7EQo/4gaZJmBLGk5XG/K/ib4Z4SI8YGq1AfFckomy4xjd64ojcXWqIHDh6KQe8vwbFt/1/W/AS42wNEUUz5ymEUdklSJ/HxpS1CPtHafAohAScnLVMbZYOEVSfH7cmStCs9qBdhW7kssGzVrUdtdwPRrn/Wa7sfNeutdKHuDSviQCrnmGnQogr/VrrMcVVSiKn6/V0ZMqIN7UA0jlf4Jb9TB+RJqPT8BfgDKoGBCqetwmRe3Rk2dcdQ8EF4ph1mYjI99NZuJ1xZB3rNSNFBcYW9Y8jNUoEMDQqOzryfOCFLqi5yTPLFr2sDBUJs8K0Je4hzfm9reAi1dF4XVNfHdS4/lvUCIx/Uj7xXhvZKmX/wsHrFomM8yUwPAqDf+CBEKdHXIMvvYQLCK4OoNjiqAW71oYvzH/d2NH27IrcVcxniunRh63Y2+M9062daBad/qWaMcbin2BpD3LC+QBlekyiUKXKTFkT4rmNmmqD+W5s0MhHMtnK2gpy5M+3NP19Klwt7y570isdcGynkB1G4BH3gvOAF/5kem0/Jkb/LVPoupsF7eivNgY8QA6IVw3+dZyMaqeYtUus44+kfrXHuRQSNOOtY+T4OdfMAsr61RDjHbuC4phwn0UptcHKEb5XADyC+urAxPLOGiz23OVtlWG+VhPZpUDFxqtBldAV+0SFndFq60Lh5KcXgBRHCZecIVpZxuO/GgB/Q9UeDVx+m6OPA9jJ+rTKDzcoO0UpPjIoxee4oc3OgARnnpOlePai/daXmdaZy3ZY/aosclHuM/4flDefp5HPWWTYca6WklRFQnX0edpNknAFkph4bQhkTOS8oh+vnJmXJIbpTDrQZ5T4oNAAPhR4c0t0mLRtnpkLg6l/v+4ic/T7ZHj/LhmvkagNbi/cV60ppm5Eq0wAtg+0cHFhcrCnw8/b33j63RyGsN1ri8w+ksqtS8ZKRSa5QqMP4EUMRt53lHSD/Ue10DP+G58Kz1A/I3UD8s4f34mvLwE7JjV0tsFey5UWPwWeezNGrcEpQjKslkixaZBZPDhwS+H+DsReRYGDinX/wGjhtA3pVtCTA45C4t0uwKbn0K3YMgVmW6aspeAbaELl9qKJ4U0tuvbe/v0Ixcj4guRUq/8DrujhoX4Mj1TH9VUJfXhTmuojAuK6iTp9W808/pGPxo/9HADwpNR+n39rtQ5Mv0E9CPEJmYwbKJUKjOTeIHdukdUh6Ojjwadp8hfHsuoza/NnURZE85NJSmzKR4jslBL/40p+c8u3VC2dLsLcW+cUwHQzBpRV6i1BKrZkWvAhG5SnBkej2wQFj0nMVL9beHDLB0FxCtR6C8opDWh1u8et+HI17Nf6UfTSSuKRf9QnDDe7af/4FSNTkUlsu/F7HbuGT8gPRDRd9RGbVR81YEcd+lYtG6cC3UR2HKvOeRnx8vYyaANDl8mP3cVKVHGefUlj6fjHv1lEOcUA5j3qJSDnlOOVzOjne75BZFbhHkrXUsvVySCmEIsXEAixN2LXLPdgitey1SpArDhg6DszZyULZJ3gpB/AP0DB8LkW9H0Lce8NVxkL7Wx5XuKW+96Fuf1ZpP9cmsaf/zNLKcf53g/lFA7iM8YYpxFqraTp1txCeAz9Kk+ZzdCKvJlj4BfhQ/mg+RH0opO0KJxyYsmyirpQ6767Ot3jONcjgCnggrg+W9cVeVOjtRWdkQbAPIG/vZVMtTcpbmi6KWXUFPEMpgeO1el6FwwIN2TZURtgqGHo+J+iNmCqL9KfulLgeOa4IUd9c7vxKOr26+y7bggc/lcqjIi+wirpQdyoSCilBtdRrU7C6oar7V7uPFbMs/VOuQdS7SS0oNvMv1k8QHyANLnqGi/B0dZ658Fyp86qU6eFXVozzAVcVviJ30WaUcpoQ0Zagq/Ih1unI29+D8vUhbPXJLsa8daglggpDkytmVsxDlSBWKWeVe1+tFhEIVJINmWOmIXABijkHgBbiup5aXMGAtnb7Kb75jRrDLd4kVAP2Kx/aFtJ9r9cCzzwCXZdxuybudamFeCrp1Qv+J1+WzbFkRlYhB8PeuW915WfsbXD/k/lOOyr3+aPcN+bM3SD+ZWCxaJRZfdU9Fe9mBnEqE11sfLb4zw8LUrVEOraMcYh7rqZTDMTjZ6j++Zskw5+ebeO4WQd4XfNlchnLPbp6DbghOgDKkCoAV+KYOEOMS95nm3wtQCoWfXbncF1q6p+oxrY50ClacIwC/rHq93lPR12vyPZf7nojuDBx5G/i/ElryQRBffl4TgEM0Vprg7ZsiAnxrArgqzZg6BB4iE8WZsEaOsU3AG4U3GN58sAOP7vQYnTWPzvNAwrLDR4CTlzN0y4O7TnZUdyqfukWQyQoYxvNJDli4HFKOnIrRQk9H3TBwiyC/DJDeJhjdhawpT8hyZA+Ac8Ul1HscLofcIWa4XFXRRyWylDug3M9PwiXJPQbScdua4BSI7klRydvD2LqVm19Jvy8yay7wyNeC0UfB8cuzerfkzZQhHcps4zty2CGERqPeI5Jsw95vcP8os40/y0zkT7iX2qT/lMKilZ5/wvATAz4Bzco8EswVKjwk0hSdbPjcqFmQVde8W9lHnJztF8pRSAfMHTI713+89iltjZotgrwOkG3P9AxkTtmJKVNDFrKYTHAINJcj0+QQwycWdIgudy+iFg7BFQpABSgX6fac2N47GHlv1Cfdi4o3tv9CzVHL6FEP4dhXm1eX3tvFJ4oh8JpGR3f6DTVyjFnHn5VFI/Bns0qIFPpH+92L1Bnwg8BPGd5IHQVTSJTNSt/MQB4JJSJlx+feFm9dYi8n2kQr1r7/3m2it5+xDGCHuUHDpbd6S7P1lR1sW/+UANkFehLl2U3MdDM6RZeQSTocGSYXlANLmcGUIU0gs6RM9wxahinLPRfJs5BNE7KgieTw8LH+0H11G5BOjpJWrP/VY4W38e/+iIX333TmS3OpfIEM4KOkxAUcy5xim3FU52GNLv1W8bfWLEQBvcHwRuGHkr1DfigsK5CKkZsughQYnexjRH26MM5F1dmCK5RDF5jmRg1JYBKwDxOvwb0Nkfe1axXjpHaS3gbHN4C8ttwzOv0v1zFnuKZkyInIQIp0OiHTzUG5DJnQrA3pNsGKQC5V65BRl3SV26KmKSgTSHcNX+vO0HIBbCVpaxYSOhe2YH+AXHD3uxqVXgetGj3yEZC7J3q84Fixqux1/lxTmU382YRuZ6Otny0iFH4KnSBFb7bVvKzxBvINxDtyflPiu5NHy9D6CUmojRqRSCWV9mEeyVHv7KEKoHOmUdXCm5qP65xymGfK4fBxBNLQTogxdB73g9Rqm3Fy3MBxA8iLmWme6dXumZMmZWTCMpyTgRNTngBkGSfCj4DtRE6ET6BNMGUIk8gj3ScwTQAmSZnABPEIqDRxlEHaXEj6hWjtCpNGrXZ4AqjX1Hr0x4EjHq09nukYLihDJ2k4V84fa42gdj1D+Kwd5qKwMxtnodgfFOMtAFXpe770s5BVscc9ZM6YjrXmSHX+2pxBLchVQLYASHNHHgg76Ezfk00kykBM867SUw5RTLzKiE9POczJQFejHDbxXGCjHG4A+diajgd0jn0OQ/YjciYzwcmNE8mJ5BFAAKLziIQBwgRognyCpwxqAnmMtBtHiEcQA6QxHssD5AOEATBC/EKbawXg1uwTqu5GL6rr54+V9Dg4XnBgXELZjZriqngElhxEXg4Hr0aMy+cN/2pVCbKmwlNVed6KKviboDamM/Os8R4ca48UO1LwN8rfNNibMg6QO8y6z25W766ZQhvvsfAotwnw0cCPE8ohZ1M19ba9RTy3Ug5dQBIw1fJIMuDoMfaThlURjF8vdG/rnw4gzRZ0PGmfJ590yBNHJhtt4tGSHUCONBwhDBCPkI0AjqCOAI+AHyAbQB4AjIAGyA8SR9KOAA4QBpAHAWODxms776P7bXMrvGBw9WhkeAscb9EX7wTXu/Jr3ik8fFpzlA6RVntnoOU/OyCMlBuqArc/CpMm6o3Bjvkp9+BdQz9p/Jl3fPdkx+E9O0rNUJ2orcqsoTMhwVua7QmAEcPk+HxKJ5TDYol0Sjk8E8/FarQcICwgoQ2UgyelmGX1eZGmb2sDyAuRDBoL0J45Zddxes8H5mnAYMndBjM7SjywGDRAGgsYDpAGkAnAIGAg9AlxgHEAeICQQAzl80rxWE8xwMbLc5CLTOi0qP4nrgcPGOICz/rasPvddUlewNabfyfog9K7QmXnR5ldLDVIvEUUqR9t3rEOgwMlWvTCtVZT9SHxU4O9fb7sj8PxqDrAjVbuY9WVj2jQorACCZaFvLPSqPEis3fpZHiDcthVG3rKISeAY7gcRn2zcLlKOYaru9CWZv9pAdh/+DewE1K9jILtTPbEo2M65Hw8ep6O7joKOkA6AjoKfoR0UMjxHyOS5IT+d7BeP8TvmK8HsB5XkY68EWndXVy96Xx6H2hxeVnW9hav9Rwc7zEi++qs41XKTy7gWFXA30ok+Napfhf2TBG/rRYKYAXDD4jvIN5IvtP4DvJDg30AOnoaJM6RGlek406rsfQiB2VETVyaQ+FJFtDEKZqHdbNgby6HKtQDL40XpEI5lEod0mef9laHnMVza+OG3FLsLYK8BJCpYEkGPAvKDj8o03T0KR91nBIGH5X9aGYHSiOFI4QjpAPIMdJnpRpFImQmR8RITzq59BGnQRgf4yD7eQTQF6pCzRJAl14tfscJ64ZzLZKo6hVepkHqK6u0SpaTIvu5RV1Jh2+D4/XokUtq4JXoEfPrlz6B2ljB+wyIeINY6o8VKFEB8Ue5/hPgG4gfIH7WrjeMPwG8H16fDvvf38TSfcZCvduiRrj2VqoCngIUU6lJaiAsX+hkd99ri0wLi0rGkDkDoxmTyzYPCQAfEniY4ENnhV6637WTvcxKtihyA8iVdfjXDGXN7T0SNML2Non8lMs854E+JAgGcCincisgsgBARofaQCWI6ew+PTiiXpddract0m2WQeJaY7JFYwAxagSSptlOrB9U7529Cs+8DLVLXuKc3LjmTWuVA8g9yD2APaChhSc4bcqcyqytRJb31ijXujGXGzK50QCln3L9LDTBt6bLCP8RIz6oVMEy0tPMtspjUPQfY0DczT7pONYBbHOHm0HV0be4DKq6EGq2Kop0NywVzDEzanJ0soejA4PNJz7TiXhu7mTOLGqcRfvRpGj8TA4kgx0AEzANtkpG2GBwA8gHMzWGN3ayIPUbIxJIzPjUp78refaU3JO7zKCBgsV7ZwI4BFjIACVAKSLHiCzZgBEJ1Bg1SSUJicYR8AGw3dVUmVgfAm9KE5ogHYv81iel4H6H104uKtkZkiTl0ryYWgtbqHYRtUyQy8FlAeTcw7gH+AzwFeALyCcQewDDdeuGK1Ei76k13tGQYetUf0D+U1Fv/H0xx+h6E/QDrh9w/xHRZXEYRBkUlxqLRmUwnEN6d/BTxEQA9OBD2+SYdgYZYHUWsSspFJ3Qs8idLuQhIs90dBzGVKLO2dyItVZYT3onI1DMGcAAR0SiTfCi/jl3KA3wByiH2jrZG0Cuptjf9pF6LJolpYa0t6zJP3VUgmsgMDD0ACvoDaIOhA0tfa7ptXAAkQQNEAZSR8A+y30MwqCsAw0DTLHttFmzLGkt/a4jXfPC3vgJ11sHDB+QH1EiGwUYTp2fDjplovnZGq9czqAWDTQ8AfYMyGFGgAYpomdjKscoF2lhjVz6aPLOmirvUe9ZRpEO4VDYMT/lTQn8Z2nKvKt0sQtjpjBlqiJ47WZjBkjgJ4kfMLzJcFBKGR5eB5wETwabMrDfwQ1IXVNr1k9WSSQc6shT5mU0x4poRerg6UR9aEE5vFCFRU0iFpRDL51smymHuEQ55Jcac9v6Z4kgB1sAUJy5rSqoCHtOBA5yHwAfIA2CDoRGQEeAB0BjRJI4SBjoOoA+QBzhPIJIcR0DoAMMQzRrcAA4wnEAtUcvaHi6w57vvI4A65n2xtaJrV3ZrAakcrhrBlZ1zyx0JmRepoIMxJPAEZBTRZ0I6iTdpBq+8bS5dNpx1u365FVw7G+z9n1lQMezUZ0yjlOYMe9AU+uZARKa02vgJ4g3gIVVo59I9gboE9PkTLtSqiPoGT6OSJ8HCPsyilNqf2ym6K3eSHZ+MKWTfUo5dLsAfxdcDufMogfXQjms2pB7BKMmd5TD2lnvKIdq8nnb4PgGkGsRi1tzf8NaFjvQkXDIP6fRjuloKR1gNpZ0NhoujkNJsweYjoKOhB0hHICIsiR8Ej6AVuYkIxKNmUgNBWCHs3BKOrtetFRj+Jkh66+Z8fEB4gPSm6KbPgNffX/qxsNVwdFP7Wn34cwIsdjeloPSu6ZNGSDpEO4kCsc1Pch7ZiIv39cBHIoXTAXEt9aAKWM9wZrBO+roDvGjCEzUBs0PkOUEwzfQfmiwt2k3fI5vH4Ln9kLUWCvBhAGii131GC9mqDZ/f32jZihA6olItenTzaxSpXBDCwZr525I96h5rlIOUTrZCePxABXKYYXTnnJYB9pZ/G62tQHkCUAuR1eYYoSbsye2IOT8Nh3S5KOmHLONZCIYg+J1OFyqTZjobMfnM0I6lo72saTfE9i0I48gpjjgpbMuBMtZ3xcQfmwK1+UnAySrVcA7xA9An6hOjcX7W65KqSmhTGgVBTi2sGSAcQToJIv/d/sZYVGUJcLkjFgR/+UFtYpbNcdbne2aVhd6YIkANfOq39rMY40U222In8TP0s0uQFnGfKSfID60Hw4AhcHiG+v/fKfAba6QFzOfy8EkziiHmC0Q5OXrLN1vy8GdTodZPJeLv1XnIXPX2C5D6ClB2ZuJV6UcIntQDocl5bBXUfPVD3aLHjeAPN0tdqUx05lWRZBVSPwl1dZOx3z0Q8p5sJSOlEZAJRpkoRKiCueWmh+DfghGk4Q2FXAs98FEFn62MJXmzrr4I5u69CR5HVWpcv9lmLnS6BCG9q4PSBnRVS3FS69SMdXb+6SqxRhqJ6NSujh+OrfHCq88rYrdYsTgJEU8bbZqmZYT551qFF510P/CnnUxyhOGWZFye40UP0paHXxqcjbZCguFNyS+6+ifcDmSNWYMWh2v/J4DGC1neLJS/zuRsOsGBqwCZG3ANMqhIU3RtOGHN8qhRNA6Xn1/7llQDlvTO1L7QjnksbB5Unqw7bI1ajaAPEt/xjib+orlaOXFZgmkO3zyacpMadKQJqoAG1QUyDFVdXEBmVGnm4qyT1XyqeCYQWQFMB5Zt0F2rrPYdtpJ0EfxPnmr3imK0ZYPyD/g+pD0AffPApClm918vxEeOt6n2HMySFlMIDW8U/vXW+vx3CTgOjhqCXr3oOip8Va8+ENT1AHepeoRow4gUeuRc+RYa47Ez8Ke+YFasyR/YkhvMBx4cEd2YEgxYkOGBnJKc+/JVTrZGXkYI62t84lpSTmsqkmt2VLFcwvlMGXH8ckWlMP60bI1as6jb0qXe1maTbxmyiHOND82yuEGkDeXuoo/JMC9zEWWSwWKRAeR8zRNtJQ5DBMteYyX20RoghjRYWhEltEbjiFcoQmOCYYMx7HIo0XKHduPEAdQyyhyBjCH/Aj3zwAJHOI6jnAcIP8soy7zBfgEkeGiFh1s1zzis5CwHnFufUsYCGOxsS0lx4U/1q+6D14Ax6VKei7g+BOuH6pzi637rJ9FiOJHAcffw6O6Ct2q8KvrAHi5zfAG4kNDOgRGZKA0OVSEJeABmDV6s5zhYwCk2DdqOhGQEjGq6Yp1e1wG8o5RyzwI+jLlcAY+Wkc5ZEifcQfkZEhZpY7pG+VwA8gHAfJjmsGwP6MaYh6y7vxGgD5pOh5Rx2ZQABA6llriLrZzQti6TwxFn7HcfpRwJNsYUKTmWGyfAI1L5BAgHBWNoUMwRQIAJX0A/gHwE/JP1RSy1iIhL2XIiALdl+5VLK0AcQfaGKM8wMyjYU2t48JWo43Kvp0i3cnrfuj44xJAa70xhtirXNnvcP8x0wabX8xPQFGLDL717xB+LzXKSiX8CeB3CD9g/ImU3ny0I4UJU1HVMQDZ54jKDJxyeTcsTRBH3o8Y8zHuZ5hZLJojyNZUOzFSYxHPdSt0pVKTpE4LFbPLYSCgt1vYpM/KEHpJgpL3LodRpxwOEzSkGX85C2pYBXP55nK4AeTKymVEpR4cNVA6H1sRyMxRUUfMPinrSOoIV+hDUtGYCWm0yr3eYeZi95exu89A4oiafsfn2u+lh9AtxGLGr4i+Ric7+MY/Cbwp0swfxcY0NxLbPPtYjr5m1r2DcZg1/1mSLgOMmgGSABm+3/H4akaW1hHwktzPnQrgdXB9LikEt1repchebA/0ozVq4vI7gN9Lal3qjfoB8HcQP0F+YLCJoGTBSHEi6tFTLko8hTSg6SS99VIWDgBzsxhwXH8PbVMbxVE03dyIVBsuAzEUyuEseTajpWNp4qUTERMDka1SDg3M8R7yYOBneW8tID2hHK4IaG5rA8gIlHbDuRDDSgBED7NM7McJH9MROY+Y8hGDHeE8MJWONVrqXDrWOrYmTnVFjJbk1KJOICwboqFTHRRTY8nUCGhWtn6H8NbAEDPfWHNkVTyclVXVc+WnHRmV1zy07nR0q3P3OryAoXfujj43bOgPCWFcGxi3xWs71uaJvNNndMwzjkABxTLb6K1J86PMQv5YcK6JMNUCPpDdgx6IODlWsLESqVWhh3RBtrw0biog1fT2EuWw8amLTmdQDuMNh4kXMR6LFlTLm7UQzwVzVxuO59eYutGdSjlEa9R42iiHG0D+ykp2BoS1P8PTZoERGpn96Ee6T0l5gg8ZVtTD59pjdKZh4UnjPsGsNHSaN01YNsiatazMQ8k8ut+pdLc/AH9XE3rFB1zvUjG5b+rX+igp+EfUH3UohvdBG3QthsPLAVMc6QvQRZLnnD28Z7/vGRgdzdq2ejTyel62EAe/aVZWxSaqNFk1yXqfU+ei0hP1xbkO2TNoajodohPxeOOHxnTgMftcuuCi9qdSYaAXsKqpfp07VKnzlREfmzKmfWqUQxWAPKMcVt58bb64kAtBNWUVyuFUSsGCnKX6cVKH7CJHypdVyp5y6EByx1Q72Xf0XjbK4QaQ50FL7vt4Xe2rCH7Hzt6lhYmuwbI+pknZM7JPNGVQM0gCAXJh3jXBLFPdOI8x6pOzp3ZElsIkKJNe/G5wAPSpaL58QvqE+6GrRZbtOAj6BPDZcbIPAA6Kn3O9Mfo0zpD82UXdlLk5MJJFqIIdOCqHg6NUPL8FFnYO6Lfw8TprZsGn9tnKAL8rao0/Oz71T0F1249gyhTmzMJjBm+AfofxB8AfSPah/XBQknOSN+pdEZeNHcFQI0oC0OTBISqdbBR+c2tnucOHGPUBh0hXq/oQTymHkR7n7sSQPGorbVzoaR2e5k725Q+1dZ87yiERjRokwJv02brLITfK4QaQF49dCwHTFimw7uhrgU6Zud7R/ZOZk6Y0eFbyicaSNndAozrmozmKpAplD1O5Tx0Uz+Wxk4BjKZfPHWvUDjU+55/4LKM+8wXNV6WaS310w+KuSPEowwhYIpBnsAt/bzFUfCgKJhUQDNAUlja31bwsuu+PpdTz6E6uYhOaVXZ+j1qjfkgFNGv6XKLIOWLELFVGVJCs4PgOw6RkChHG3Im4FWfAEjkyR9SIMmyNrlGD0ghplMPs8GFAOh6j4dJRDtFFczEwXoyra6m2mnjBADPYMV7TLcqhmnJT9yF3lMO54VKAfsJMOZxCZGONctgAeKMcbgB5tvvt0gUFLp1V2VvzZs+MT59wKPau7i63ifQsWKZhAkszh8yQjiJHBqOmzDsiSzoyxnxi7CduOzanGLX6Y+vUqgLBzDn+0Qm+/ixMkd9jkBo/QHyUlBjK2RESgns4ExjIyVpjnIfAvTRswtHRTrbV6DLKZd7Cpjlpn+UGaxf3koxZiAp/FKGJ9yYiESD4e0mr3zuLhBjVAWJ+EfwJlt/lbyCjeUP8REqf8d69dXx7Be7WZVbt/Hp8LAUgiVLXMwOmYwMmGcFjSbFr57qnHPqVWsMFyqF5NGpS73K4VLmbO+Id5dDkcFoTz50ph1ZMvKKTzUOGRps79AvKYc2hNsrhBpBn3cWVUZQKhqdSU01CUcIuTZ6niXk6YmIAHYYcpl08wD0sF5SGYtwVHWvHAEMRy2W1Ykhh5KVqYwdUybKQH/sA8KNZlM4Uux+dkX0Flx+ztmGZDXSflCfAS1ods5klnGqgV2uKGVBudUir21BMySxHw6bVJ+N1XhAP77FzRtCYHyifyRukH/LOWjXkx36H63dVemDxse7UeCqVcAZM4A3UTyR+Kg1HTkVBApESR/eim0usxmaOiK5qt9oIHLzR9Joobi803I9ZqzZqfNEpPqUckieUQy9RI1kA0pA+Qhl80divDl2wEuTPlEPUIfaMVcohFaUASk3xeKMcbgD5QIrNfuZuPhBUpmLWbVLlO8uY0oGTUsqeYNmC2yVKSkQTzo04qyFumzCMU7Xq3krCdSyUippuF1TGISJJ/WTzbW6c4zcFYLzP+ocxHK1Cs5PxSNIElY51bbjAyRK5ogAhkUurqgNA5jbqE6XZHC3WmadNzpI+yz7MWdpddSc/K+BJ/vv/2t7V9cax5cYiT/eMfDfJBkHy/39dkJcAC3sszUf3YeWBPB89GvlugnvzsixA8FiS7RlrupqHxSoGoU9rEXgZ/cZpZ4yP7rz3XTKNJBUfUL1S+BDSq96m/hrGnOvsG+///08/fx2WQizq5Bk/iIPlMAQZ3Q22SI899g7F85bDIFLRbjlUA+oSBBmWwxNdPe9LvCbLoak6TwLDclgNWF5ZDj1nSo1DqPmFhvZKrkkkQaKPBxq+3hkt4ndpUUDj11Iql+2G6wZsFsPmpqDGEmThRIQa/R7x012vKoxN4TR7+GUaPcpYfTDNDm9xzLyOAAbeYjD6NoQMu4K80uwGq1cAV57XTXZZoVKc5NQAWAx7N8NwRVs3JTEjOX+dJPr8Y1MT/HXKU8P2FytZW0TbdeyLsZhZ7MnfXlG2FastqWfYBb1iVLkA+BDgnaVcAdxRZIeFVfATC0xZHLOzZc4vKuLVZMt3rwasxas+CcIs2v8az3Ms0Lqjrs1y2KyJOinZrfrjYYhcjdjFe+DLbth+myyHc4RjE2qeHTXyYn/kcyfD3HJobfaxizKvCsW0HCZBPl83ez0SoQioJVw0BZzdNNPFRhJyWkxE7/W6sWzWqMT85h9bjdkrEvd5kQS15+cEBT4AKiXcLl5hHYePSAuXzS1UaxdlYnNfe0yzCKkIoixyExoJlilwAuI9xzbw7aM6GiM77NXiUAlcufavuSjQxoIYqvgUCnm4+jgJUN4q8JCJUKLtfQgyuLIn8OAC8scQXPARARN+/FZXp+23012u24baQziexItJkCEH2fW5HnbxhdpixIIhnx01Zu5IibOqVvtsOexHW/RVsEP2OFoO2xIvqleQVHmhVj/VeS+Ku5nUDpZDhPC0ArUULO21Vet/UbcKpOUwCfLl225Z/UijGsO4+qnv+Kqq7BfVIrWe17vKJrRKmAxnTjteGemOFJVICFKhRWQLbiB9tUGM4ThB0qZ8xpb0TQA76eM/MPuA8RKpPje2QWnwHcL3el5udtLtdDMxKEEbA96zfRBzlYgh3LSESM+FRA+s8IO2QKWZjeWT88gvvBrq+w3Ala5EX7oThu33/MlWKbog03qNP4AgSeEVIu/xcbWl3Ki6q6o3NHaO2Ju+2AqHRO3WK8Qs1Ng0ky8K2A6WEGr2I0Fir2OHdRChnRec6uNoOayfhKjPwjBjDKeF58aXrUgfu+F0j2qWQ0YfclgO4zXE0bptOSzmHm/Z/a3HpUDuD1hZnDw5LIe+uoHdcpijPkmQk4r99kSA/GX7hc9dGnomOJflbtedhUZYrVAYqfTVWVJBMRh9pKZWUmSL0KuWzK2hKVaANxg2F0u8XoWItbWzMGwC3tiO24Ir4Z5sAW5U3MWw72fd67nwdDcV9ZyJXoeQU1+UfuXFDhoRicfxIVLiPFdi1YL0ZWQq/v3H814kfbvy3N0ubXwn5htjedYlfNM/ew/Sj9Q/AX73X+VdRK4+siMPQva6ngiaB9c+Dft3IWR2kUQMJosc2ojHcFrpfTyoeGgFJ6FmJo0DmYzB8e40AL+wHHJYDqOK9C2HEtmQ7qhheTr+t2AgUShsshzGjKYWYJ8sh5t1JbtZGeX6dAOLYzf06bzyOccu8Q/bg/zFnZJPup6EAaU/ji/6amOpOJW7VewKbKA9hHaVqu9c8AbRM0ROEC7i1sNCgRn4gKAKpIrRKKgg7lTuVLGISNtgMAEqBcYTSBEDsSuxoaJSQVsLuVU73WEQwXo3qBd7AmGBShEnQlfRPWjCfy+d6BQaBDk+BCoqUAmCDEIUFVXt1xRaxWi3WHz1AzWGvSPxuy/OQh/2bip080239O8LIBcUuXBd7lyXB24P27XgZEatFbUUoO5dRBlhYd7K9dZGWAaDxA5K+izUEE60XagJD3azHKq+Prq3SqwarCnXk4BztBxOS7xCQW/ZkKu45dBWgdyj1/nKctie+7TCQo2oImN0pz0/lUmo0S/lmEQS5K858unN0lVGweFeKl+pfu34pGImYjBUtfrx+Ouy1DeV8w+LQCtTCtRUhQUGwSaGXSopoNgqShGiyGZCEwK607VlFewnH1zU4tPc2OkFSVwoPBV3FN5DXTVC72yySqvyIomik2OrFqNtJfPnYqshopJEGStrpUh77K2BD4A3GtwSSbuA/N5aAGOZFhpBjrEl4OLH6e6Z/gmRDyzLhwgeti7GtxXl+hjzgI0IdgKrfp5vfnXfo40fpE7HAE6WQ5Wj5bDGUgyVrkuN+HlfvcBSUMywLQqW2HLYwiAOlsMnJZuecWGL/7taif1cAO5dqHm2HPZcyTajo3EzkC8shxzP0eaAi5eNzPlhUmcSJHx2bEQPEvKLa4y/w7JT0opJBfZvpW7/suB8uaOqop78QrKpiJmb7BYXZ7t4ugVMSDH67pwWEdFOzO1ardPOZSVsWfvFqY9NYaZh5ShRUpW2Lwf49DF2eRMFisXX14qvtKX4LKeKq9KMpCGzdxg+YHyH2QXghd5vfA8xZqxCYFuLwAtELhBcAPmA4Iql3LmWh/37P9vyX9/pA9xy3H562CLYKj4OkjN87vtZOwoH6cgQasYbQnr1JxKWw1PshVF30HBZRkFYrYfn4rxENJm0UKRPlkNBHNnj2at5cjJVvILU1yM2Q8l+rvtGn/Ol5TDeG1jgA+M2hWZgCDTWyBXyxShC4h+SIFfhJ/L7P7enZYQSUIH1suP2b+sYreDrcpWRUi3H5MBR6XzlzJBXcfxAXRcnWLe9KSoH8am2x4uvbVUF4NWg+lEbbX2tf659X/HSSAjVHYKrLweLY7XZO5vNUXiF4gcMPwD8iNTuadCbF0gE2raUndPyjmp3nIuhokZuJbAUSBvbKXGEfCJIXy/g7pZP7ZMuOERKz3xE/sJyqHv07GbLoWpXgH3PY/Qhd4O9LVgeDxBvo1+5W6/WPlsOx/NTa1sOFcqwHJZZ5JmbkOwC07PlUF5ZDs3XDckOyJuH5667jVbCZDls/09Hy2EiRZo/thzt7zuKYLmbX5fFL7rf5dev9CF5+vqwUhxegZi5lxiGcucQwQmgLCJFWzJ4FLzhq9CwGWqp0wykQWQXwQbRe5TYG0R/Ts/Jwn5yR5EPMdypvIPyAcN3KP8mJt+hbcOgfGDRd8B+Anpl0TvWcofIXv/jX/fyn/9NOStwoxNM9Tgv2asfWZcC2W2IHOY3I4ldLNhqDzzvQk3zWE+OGivlF5ZDBWzzJZMHyyE+Ww7Fd1tX1ch5xPD1/96baxKODpZDErUIFmMfJejH85jR9JavHSyHQLh5wmreXjeLTEJNgT521LX45kMMy6HJk0STFWQS5J8KAXQjJOL1deexx8OD+vMkVeJpNUFcwMaRTwgee00x2lKqoLxXsEjkGRZj0U0hdxRViBYAqhJVZJ+BkeqhGSKxfOzDY6tbD5LFa1R7RJL61lPVgQcgV4CbgBvBW/ijf2DVd+pyheABq5vsVqnrg0UqBGQp3j7YK3BagccDKAWyAdirE+SHzxxy8WAHU0GJ3poVhVY77jfvQkbbRTCtJujOmaiedAgm3ntUHFZJWFgO8cJy+LzE0ax7sjvxfmU5bCERfLIc7m45xM1dPAfLYQ+tkGPLtVWLbW9OO8Yz5h73seXwuGsd3XKIlG+SIP8/SLG3hMSDC8rdUM+C9d2DA+bj0fNBRuaRPBkdJxeMpy13h0GMoYwKFpSq4D+th0xCCDZ5e3vH9e6rIlQegNwiJ/HUeosCFgrWMQYpTvEiuwA7jBU0Tz5XqVQxz7zEQ8gHRYzW9kxpRdG7lWXzz1TI3cTKAn77jVIfwOMeJ/wgw/MJ8uMGfIs9zlsFz6u/4r3C1oLCR8SGEQrDJotXmqclqJ5jsL/aMB+Hkv3Zcng8wf7SctjCLvhiy2FUk7YoqNUPExyTjJhWkwvaCE6zHPp4jy/xIrZVIB8Vgs+WQ4G5UDO3VVQh+94th4XA3m6ecap3JVv+l5bDRBLkH6/6RNq0Xz/lWrF/8/FGCcVSnm7iLUdwVIife0DsjXrBPPHB3oeU+HFwJHPP1slS9kjeeUDlHYIikMWrRHfVmKgRpkrxIXbFAyoGwmBEPa9ENUqt7DtppqdoywKaQR97PAeOPSo+s+clU/WAhd4BEIFsO/i2An+zsfpiq+Bfzi6YVAPfTsOhMis0babv7zkWPlsOD5+fxmPMWyMC+HF/Le6FboPZZTlYDlkKyl7dctiFmhgRmpRsQkevr/chg9BCqHmc9XjT5bGC/Luqu2fLYcuGjNxLfrUZsSf7JJIg/4SGpr/xgrgUWD4qHn9dQd1iWZN6ehifK85hESZfVKXyC7HmUAJ98bzMIKoGFdJtP9N2Kb9eawxc624vpXxfAuVN//CAHKJ6JBTduTqW6SYAVU90a1sCp2Oo7BX2l2/HP7jXQx7jc0jnEGqmER3j1JrAi7nFZ8thzOabQYovAmeJf09jT1FkQTpxayjZ6NKvVoOd/PhPOY9tiC8sh17sz8/JCbJbDreIO/tqkSEm0n1auCvTCaVbDsMB6q4dwBbFEq0A1OEzbJkYmlfxH3uoZFqSEolE4ssDZSKRSCSSIBOJRCIJMpFIJJIgE4lEIgkykUgkkiATiUQiCTKRSCSSIBOJRCIJMpFIJJIgE4lEIgkykUgkkiATiUQikQSZSCQSSZCJRCKRBJlIJBJJkIlEIpEEmUgkEkmQiUQikQSZSCQSSZCJRCKRBJlIJBJJkIlEIpEEmUgkEokkyEQikUiCTCQSiSTIRCKRSIJMJBKJJMhEIpFIgkwkEokkyEQikUiCTCQSiSTIRCKRSIJMJBKJJMhEIpFIJEEmEolEEmQikUgkQSYSiUQSZCKRSPzZ+B+GrlwhibMxxQAAAABJRU5ErkJggg==&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sakura</span>(<span class="params">x, y, s, r, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s</span> = s;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = r;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sakura</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">draw</span> = <span class="keyword">function</span> (<span class="params">cxt</span>) &#123;</span><br><span class="line">    cxt.<span class="title function_">save</span>();</span><br><span class="line">    <span class="keyword">var</span> xc = <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span> / <span class="number">4</span>;</span><br><span class="line">    cxt.<span class="title function_">translate</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    cxt.<span class="title function_">rotate</span>(<span class="variable language_">this</span>.<span class="property">r</span>);</span><br><span class="line">    cxt.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span>, <span class="number">40</span> * <span class="variable language_">this</span>.<span class="property">s</span>)</span><br><span class="line">    cxt.<span class="title function_">restore</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sakura</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">x</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">y</span>(<span class="variable language_">this</span>.<span class="property">y</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">r</span>(<span class="variable language_">this</span>.<span class="property">r</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">x</span> &gt; <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">this</span>.<span class="property">x</span> &lt; <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">y</span> &gt; <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">this</span>.<span class="property">y</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnr&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">s</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">s</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">r</span> = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">sakura</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(sakura);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">draw</span> = <span class="keyword">function</span> (<span class="params">cxt</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">draw</span>(cxt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SakuraList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">size</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">option</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret, random;</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            ret = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fnx&#x27;</span>:</span><br><span class="line">            random = -<span class="number">0.5</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1</span>;</span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x + <span class="number">0.5</span> * random - <span class="number">1.7</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fny&#x27;</span>:</span><br><span class="line">            random = <span class="number">1.5</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">0.7</span></span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> y + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fnr&#x27;</span>:</span><br><span class="line">            random = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">0.03</span>;</span><br><span class="line">            ret = <span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startSakura</span>(<span class="params"></span>) &#123;</span><br><span class="line">    requestAnimationFrame = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">msRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">oRequestAnimationFrame</span>;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>),</span><br><span class="line">        cxt;</span><br><span class="line">    staticx = <span class="literal">true</span>;</span><br><span class="line">    canvas.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">    canvas.<span class="property">width</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">    canvas.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;position: fixed;left: 0;top: 0;pointer-events: none;&#x27;</span>);</span><br><span class="line">    canvas.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;canvas_sakura&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(canvas);</span><br><span class="line">    cxt = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> sakuraList = <span class="keyword">new</span> <span class="title class_">SakuraList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> sakura, randomX, randomY, randomS, randomR, randomFnx, randomFny;</span><br><span class="line">        randomX = <span class="title function_">getRandom</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        randomY = <span class="title function_">getRandom</span>(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">        randomR = <span class="title function_">getRandom</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">        randomS = <span class="title function_">getRandom</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        randomFnx = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnx&#x27;</span>);</span><br><span class="line">        randomFny = <span class="title function_">getRandom</span>(<span class="string">&#x27;fny&#x27;</span>);</span><br><span class="line">        randomFnR = <span class="title function_">getRandom</span>(<span class="string">&#x27;fnr&#x27;</span>);</span><br><span class="line">        sakura = <span class="keyword">new</span> <span class="title class_">Sakura</span>(randomX, randomY, randomS, randomR, &#123;</span><br><span class="line">            <span class="attr">x</span>: randomFnx,</span><br><span class="line">            <span class="attr">y</span>: randomFny,</span><br><span class="line">            <span class="attr">r</span>: randomFnR</span><br><span class="line">        &#125;);</span><br><span class="line">        sakura.<span class="title function_">draw</span>(cxt);</span><br><span class="line">        sakuraList.<span class="title function_">push</span>(sakura);</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        cxt.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">        sakuraList.<span class="title function_">update</span>();</span><br><span class="line">        sakuraList.<span class="title function_">draw</span>(cxt);</span><br><span class="line">        stop = <span class="title function_">requestAnimationFrame</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> canvasSnow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas_snow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">startSakura</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (staticx) &#123;</span><br><span class="line">        <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas_sakura&quot;</span>);</span><br><span class="line">        child.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(child);</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">cancelAnimationFrame</span>(stop);</span><br><span class="line">        staticx = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">startSakura</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="移动-sakura-js"><a href="#移动-sakura-js" class="headerlink" title="移动 sakura.js"></a>移动 sakura.js</h2><p>将 <code>sakura.js</code> 移动至 <code>themes\next\source\js\</code>  目录下面，如下图所示。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200418225818.png"></p>
<h2 id="引用-sakura-js"><a href="#引用-sakura-js" class="headerlink" title="引用 sakura.js"></a>引用 sakura.js</h2><p>然后在 <code>\themes\next\layout\_layout.swig</code> 文件里引用 sakura.js 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 樱花 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/sakura.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>





<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200418230037.png"></p>
<p>并在<strong>主题配置文件</strong>的末尾添加如下的配置：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200418230416.png"></p>
<p>最后 <code>hexo g &amp;&amp; hexo s </code> 生成并预览，没有问题的话 <code>hexo d</code>推送至 github 即可。</p>
<p><br /><br /></p>
<br />

<blockquote class="blockquote-center">
<p>小园新种红樱树，闲绕花枝便当游。</p>
<p>– 白居易</p>

</blockquote>



<br />

<br />

<br />]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows快捷键不完全指南</title>
    <url>/posts/56966.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200402103903.jpeg"></p>
<p>键盘快捷键可以节省时间，这有助于快速完成工作，我们可以提高工作效率。 在这里，我们重点介绍Windows 10、8、7的键盘快捷键，每个使用Windows操作系统的人都应该知道这些快捷键。</p>
<span id="more"></span>



<h2 id="Windows-中的键盘快捷方式"><a href="#Windows-中的键盘快捷方式" class="headerlink" title="Windows 中的键盘快捷方式"></a>Windows 中的键盘快捷方式</h2><p>键盘快捷方式就是按键或按键组合，可提供一种替代方式来执行通常使用鼠标执行的操作。单击下面的选项，它会打开显示相关的快捷方式：</p>
<h3 id="复制、粘贴及其他常规的键盘快捷方式"><a href="#复制、粘贴及其他常规的键盘快捷方式" class="headerlink" title="复制、粘贴及其他常规的键盘快捷方式"></a>复制、粘贴及其他常规的键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + X</td>
<td>剪切选定项。</td>
</tr>
<tr>
<td>Ctrl + C（或 Ctrl + Insert）</td>
<td>复制选定项。</td>
</tr>
<tr>
<td>Ctrl + V（或 Shift + Insert）</td>
<td>粘贴选定项。</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤消操作。</td>
</tr>
<tr>
<td>Alt + Tab</td>
<td>在打开的应用之间切换。</td>
</tr>
<tr>
<td>Alt + F4</td>
<td>关闭活动项，或者退出活动应用。</td>
</tr>
<tr>
<td>Windows 徽标键 + L</td>
<td>锁定你的电脑。</td>
</tr>
<tr>
<td>Windows 徽标键 + D</td>
<td>显示和隐藏桌面。</td>
</tr>
<tr>
<td>F2</td>
<td>重命名所选项目。</td>
</tr>
<tr>
<td>F3</td>
<td>在文件资源管理器中搜索文件或文件夹。</td>
</tr>
<tr>
<td>F4</td>
<td>在文件资源管理器中显示地址栏列表。</td>
</tr>
<tr>
<td>F5</td>
<td>刷新活动窗口。</td>
</tr>
<tr>
<td>F6</td>
<td>循环浏览窗口中或桌面上的屏幕元素。</td>
</tr>
<tr>
<td>F10</td>
<td>激活活动应用中的菜单栏。</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在登录屏幕上显示你的密码。</td>
</tr>
<tr>
<td>Alt + Esc</td>
<td>按项目打开顺序循环浏览。</td>
</tr>
<tr>
<td>Alt + 带下划线的字母</td>
<td>执行该字母相关的命令。</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>显示所选项目的属性。</td>
</tr>
<tr>
<td>Alt + 空格键</td>
<td>打开活动窗口的快捷菜单。</td>
</tr>
<tr>
<td>Alt + 向左键</td>
<td>返回。</td>
</tr>
<tr>
<td>Alt + 向右键</td>
<td>前进。</td>
</tr>
<tr>
<td>Alt + Page Up</td>
<td>向上移动一个屏幕。</td>
</tr>
<tr>
<td>Alt + Page Down</td>
<td>向下移动一个屏幕。</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中）。</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>选择文档或窗口中的所有项目。</td>
</tr>
<tr>
<td>Ctrl + D（或 Delete）</td>
<td>删除选定项，将其移至回收站。</td>
</tr>
<tr>
<td>Ctrl + R（或 F5）</td>
<td>刷新活动窗口。</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>恢复操作。</td>
</tr>
<tr>
<td>Ctrl + 向右键</td>
<td>将光标移动到下一个字词的起始处。</td>
</tr>
<tr>
<td>Ctrl + 向左键</td>
<td>将光标移动到上一个字词的起始处。</td>
</tr>
<tr>
<td>Ctrl + 向下键</td>
<td>将光标移动到下一段落的起始处。</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>将光标移动到上一段落的起始处。</td>
</tr>
<tr>
<td>Ctrl + Alt + Tab</td>
<td>使用箭头键在所有打开的应用之间进行切换。</td>
</tr>
<tr>
<td>Alt + Shift + 箭头键</td>
<td>当组或磁贴的焦点放在“开始”菜单上时，可将其朝指定方向移动。</td>
</tr>
<tr>
<td>Ctrl + Shift + 箭头键</td>
<td>当磁贴的焦点放在“开始”菜单上时，将其移到另一个磁贴即可创建一个文件夹。</td>
</tr>
<tr>
<td>Ctrl + 箭头键</td>
<td>打开“开始”菜单后调整其大小。</td>
</tr>
<tr>
<td>Ctrl + 箭头键（移至某个项目）+ 空格键</td>
<td>选择窗口中或桌面上的多个单独项目。</td>
</tr>
<tr>
<td>Ctrl + Shift（及箭头键）</td>
<td>选择文本块。</td>
</tr>
<tr>
<td>Ctrl + Esc</td>
<td>打开“开始”菜单。</td>
</tr>
<tr>
<td>Ctrl + Shift + Esc</td>
<td>打开任务管理器。</td>
</tr>
<tr>
<td>Ctrl + Shift</td>
<td>如果多种键盘布局可用，则可切换键盘布局。</td>
</tr>
<tr>
<td>Ctrl + 空格键</td>
<td>打开或关闭中文输入法编辑器 (IME)。</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>显示选定项的快捷菜单。</td>
</tr>
<tr>
<td>按 Shift 与任何箭头键</td>
<td>在窗口中或桌面上选择多个项目，或在文档中选择文本。</td>
</tr>
<tr>
<td>Shift + Delete</td>
<td>删除选定项，无需先移动到回收站。</td>
</tr>
<tr>
<td>向右键</td>
<td>打开右侧的下一个菜单，或打开子菜单。</td>
</tr>
<tr>
<td>向左键</td>
<td>打开左侧的下一个菜单，或关闭子菜单。</td>
</tr>
<tr>
<td>Esc</td>
<td>停止或离开当前任务。</td>
</tr>
<tr>
<td>PrtScn</td>
<td>捕获整个屏幕的屏幕截图并将其复制到剪贴板。 注意你可以更改此快捷方式，以便它还可以打开屏幕截取，这允许你编辑屏幕截图。依次选择“开始”菜单 &gt;“设置” &gt;“轻松访问” &gt;“键盘”，然后打开“Print Screen 快捷方式”下的切换开关。<a href="ms-settings:easeofaccess-keyboard?activationSource=SMC-Article-12445">使用 PrtScn 键打开屏幕截取</a></td>
</tr>
</tbody></table>
<h3 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a>Windows 徽标键键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键</td>
<td>打开或关闭“开始”菜单。</td>
</tr>
<tr>
<td>Windows 徽标键 + A</td>
<td>打开操作中心。</td>
</tr>
<tr>
<td>Windows 徽标键 + B</td>
<td>将焦点设置到通知区域。</td>
</tr>
<tr>
<td>Windows 徽标键 + C</td>
<td>在侦听模式下打开 Cortana。  注意此快捷方式默认情况下处于关闭状态。若要打开它，请选择“开始”菜单 &gt; “设置” &gt; “Cortana”，并打开“当我按 Windows 徽标键 + C 时，让 Cortana 听我的命令”下的切换开关。Cortana 仅在某些国家&#x2F;地区可用，并且某些 Cortana 功能可能无法随时随地使用。如果 Cortana 不可用或已关闭，你仍然可以使用<a href="https://support.microsoft.com/zh-cn/help/10748">搜索</a>。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + C</td>
<td>打开超级按钮菜单。</td>
</tr>
<tr>
<td>Windows 徽标键 + D</td>
<td>显示和隐藏桌面。</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + D</td>
<td>显示和隐藏桌面上的日期和时间。</td>
</tr>
<tr>
<td>Windows 徽标键 + E</td>
<td>打开文件资源管理器。</td>
</tr>
<tr>
<td>Windows 徽标键 + F</td>
<td>打开反馈中心并获取屏幕截图。</td>
</tr>
<tr>
<td>Windows 徽标键 + G</td>
<td>打开游戏栏（当游戏处于打开状态时）。</td>
</tr>
<tr>
<td>Windows 徽标键 ‌ + H</td>
<td>开始听写。</td>
</tr>
<tr>
<td>Windows 徽标键 + I</td>
<td>打开设置。</td>
</tr>
<tr>
<td>Windows 徽标键‌ + J</td>
<td>将焦点设置到可用的 Windows 提示。  当出现 Windows 提示时，请将焦点移到提示上。 再次按下键盘快捷方式，将焦点放在屏幕上 Windows 提示所固定的元素上。</td>
</tr>
<tr>
<td>Windows 徽标键 + K</td>
<td>打开“连接”快速操作.</td>
</tr>
<tr>
<td>Windows 徽标键 + L</td>
<td>锁定你的电脑或切换帐户。</td>
</tr>
<tr>
<td>Windows 徽标键 + M</td>
<td>最小化所有窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + O</td>
<td>锁定设备方向。</td>
</tr>
<tr>
<td>Windows 徽标键 + P</td>
<td>选择演示显示模式。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + Q</td>
<td>打开快速助手。</td>
</tr>
<tr>
<td>Windows 徽标键 + R</td>
<td>打开“运行”对话框。</td>
</tr>
<tr>
<td>Windows 徽标键 + S</td>
<td>打开搜素。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + S</td>
<td>获取部分屏幕的屏幕截图。</td>
</tr>
<tr>
<td>Windows 徽标键 + T</td>
<td>循环浏览任务栏上的应用。</td>
</tr>
<tr>
<td>Windows 徽标键 + U</td>
<td>打开轻松使用设置中心。</td>
</tr>
<tr>
<td>Windows 徽标键 + V</td>
<td>打开剪贴板。 注意若要激活此快捷方式，请依次选择“开始”菜单 &gt; “设置” &gt; “系统” &gt; “剪贴板”，然后打开“剪贴板历史记录”下的切换开关。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + V</td>
<td>循环浏览通知。</td>
</tr>
<tr>
<td>Windows 徽标键 + X</td>
<td>打开“快速链接”菜单。</td>
</tr>
<tr>
<td>Windows 徽标键 + Y</td>
<td>在 Windows Mixed Reality 与桌面之间切换输入。</td>
</tr>
<tr>
<td>Windows 徽标键 + Z</td>
<td>以全屏模式显示应用中可用的命令。</td>
</tr>
<tr>
<td>Windows 徽标键 + 句点 (.) 或分号 (;)</td>
<td>打开表情符号面板。</td>
</tr>
<tr>
<td>Windows 徽标键 + 逗号 (,)</td>
<td>临时速览桌面。</td>
</tr>
<tr>
<td>Windows 徽标键 + Pause</td>
<td>显示“系统属性”对话框。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + F</td>
<td>搜索电脑（如果已连接到网络）。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + M</td>
<td>还原桌面上的最小化窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + 数字</td>
<td>打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + 数字</td>
<td>打开桌面，然后启动固定到任务栏的应用新实例（位于数字所指明的位置）。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + 数字</td>
<td>打开桌面，然后切换至固定到任务栏的应用的最后活动窗口（位于数字所指明的位置）。</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + 数字</td>
<td>打开桌面，然后打开固定到任务栏的应用的“跳转列表”（位于数字所指明的位置）。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + Shift + 数字</td>
<td>打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例。</td>
</tr>
<tr>
<td>Windows 徽标键 + Tab</td>
<td>打开任务视图。</td>
</tr>
<tr>
<td>Windows 徽标键 + 向上键</td>
<td>最大化窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + 向下键</td>
<td>删除屏幕上的当前应用并最小化桌面窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + 向左键</td>
<td>最大化屏幕左侧的应用或桌面窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + 向右键</td>
<td>最大化屏幕右侧的应用或桌面窗口。</td>
</tr>
<tr>
<td>Windows 徽标键 + Home</td>
<td>最小化活动桌面窗口之外的所有窗口（在第二个笔划时还原所有窗口）。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + 向上键</td>
<td>将桌面窗口拉伸至屏幕顶部和底部。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + 向下键</td>
<td>在垂直方向上还原&#x2F;最小化活动桌面窗口，而宽度保持不变。</td>
</tr>
<tr>
<td>Windows 徽标键 + Shift + 向左键或向右键</td>
<td>将桌面上的应用或窗口从一台显示器移动至另一台显示器。</td>
</tr>
<tr>
<td>Windows 徽标键 + 空格键</td>
<td>切换输入语言和键盘布局。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + 空格键</td>
<td>对之前选择的输入所做的更改。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + Enter</td>
<td>打开“讲述人”。</td>
</tr>
<tr>
<td>Windows 徽标键 + 加号 (+)</td>
<td>打开“放大镜”。</td>
</tr>
<tr>
<td>Windows 徽标键 + 正斜杠 (&#x2F;)</td>
<td>开始输入法复原流程。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + V</td>
<td>打开肩式分接设备。</td>
</tr>
<tr>
<td>Windows 徽标键‌ + Ctrl + Shift + B</td>
<td><a href="https://support.microsoft.com/zh-cn/help/14106">从空白屏幕或黑屏中唤醒</a></td>
</tr>
</tbody></table>
<h3 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a>命令提示符键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + C（或 Ctrl + Insert）</td>
<td>复制选定文本。</td>
</tr>
<tr>
<td>Ctrl + V（或 Shift + Insert）</td>
<td>粘贴选定文本。</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>进入标记模式。</td>
</tr>
<tr>
<td>Alt + 所选择的键</td>
<td>开始在块模式下选择。</td>
</tr>
<tr>
<td>箭头键</td>
<td>按指定方向移动光标。</td>
</tr>
<tr>
<td>Page Up</td>
<td>将光标向上移动一个页面。</td>
</tr>
<tr>
<td>Page Down</td>
<td>将光标向下移动一个页面。</td>
</tr>
<tr>
<td>Ctrl + Home（标记模式）</td>
<td>将光标移动到缓冲区的起始处。</td>
</tr>
<tr>
<td>Ctrl + End（标记模式）</td>
<td>将光标移动到缓冲区的结尾处。</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>在输出历史记录中上移一行。</td>
</tr>
<tr>
<td>Ctrl + 向下键</td>
<td>在输出历史记录中下移一行。</td>
</tr>
<tr>
<td>Ctrl + Home（历史记录导航）</td>
<td>如果命令行为空，则将视区移动到缓冲区顶部。否则，请删除命令行中光标左侧的所有字符。</td>
</tr>
<tr>
<td>Ctrl + End（历史记录导航）</td>
<td>如果命令行为空，则将视区移动到命令行。否则，请删除命令行中光标右侧的所有字符。</td>
</tr>
</tbody></table>
<h3 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a>对话框键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>F4</td>
<td>显示活动列表中的项目。</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>在选项卡中向前移动。</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>在选项卡中向后移动。</td>
</tr>
<tr>
<td>Ctrl + 数字（数字 1–9）</td>
<td>移动到第 n 个选项卡。</td>
</tr>
<tr>
<td>Tab</td>
<td>在选项中向前移动。</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>在选项中向后移动。</td>
</tr>
<tr>
<td>Alt + 带下划线的字母</td>
<td>执行可与该字母结合使用的命令（或选择该选项）。</td>
</tr>
<tr>
<td>空格键</td>
<td>如果活动选项为复选框，则选择或清除复选框。</td>
</tr>
<tr>
<td>Backspace</td>
<td>如果在“另存为”或“打开”对话框中选择文件夹，则打开上一级别的文件夹。</td>
</tr>
<tr>
<td>箭头键</td>
<td>如果活动选项是一组选项按钮，请选择一个按钮。</td>
</tr>
</tbody></table>
<h3 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a>文件资源管理器键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + D</td>
<td>选择地址栏。</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>选择搜索框。</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>选择搜索框。</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>打开新窗口。</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>关闭活动窗口。</td>
</tr>
<tr>
<td>Ctrl + 鼠标滚轮</td>
<td>更改文件和文件夹图标的大小和外观。</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示选定文件夹上的所有文件夹。</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>创建新文件夹。</td>
</tr>
<tr>
<td>Num Lock + 星号 (*)</td>
<td>显示选定文件夹下的所有子文件夹。</td>
</tr>
<tr>
<td>Num Lock + 加号 (+)</td>
<td>显示选定文件夹中的内容。</td>
</tr>
<tr>
<td>Num Lock + 减号 (-)</td>
<td>折叠选定文件夹。</td>
</tr>
<tr>
<td>Alt + P</td>
<td>显示预览面板。</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>打开选定项的“属性”对话框。</td>
</tr>
<tr>
<td>Alt + 向右键</td>
<td>查看下一个文件夹。</td>
</tr>
<tr>
<td>Alt + 向上键</td>
<td>查看该文件夹所在的文件夹。</td>
</tr>
<tr>
<td>Alt + 向左键</td>
<td>查看上一个文件夹。</td>
</tr>
<tr>
<td>Backspace</td>
<td>查看上一个文件夹。</td>
</tr>
<tr>
<td>向右键</td>
<td>显示当前选择内容（如果已折叠），或选择第一个子文件夹。</td>
</tr>
<tr>
<td>向左键</td>
<td>折叠当前选择内容（如果已展开），或选择该文件夹所在的文件夹。</td>
</tr>
<tr>
<td>End</td>
<td>显示活动窗口底部。</td>
</tr>
<tr>
<td>Home</td>
<td>显示活动窗口顶部。</td>
</tr>
<tr>
<td>F11</td>
<td>最大化或最小化活动窗口。</td>
</tr>
</tbody></table>
<h3 id="虚拟桌面键盘快捷方式"><a href="#虚拟桌面键盘快捷方式" class="headerlink" title="虚拟桌面键盘快捷方式"></a>虚拟桌面键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键 + Tab</td>
<td>打开任务视图。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + D</td>
<td>添加虚拟桌面。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + 向右键</td>
<td>在你于右侧创建的虚拟桌面之间切换。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + 向左键</td>
<td>在你于左侧创建的虚拟桌面之间切换。</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + F4</td>
<td>关闭你正在使用的虚拟桌面。</td>
</tr>
</tbody></table>
<h3 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Shift + 单击任务栏按钮</td>
<td>打开应用或快速打开另一个应用实例。</td>
</tr>
<tr>
<td>Ctrl + Shift + 单击任务栏按钮</td>
<td>以管理员身份打开应用。</td>
</tr>
<tr>
<td>Shift + 右键单击任务栏按钮</td>
<td>显示应用的窗口菜单。</td>
</tr>
<tr>
<td>Shift + 右键单击分组任务栏按钮</td>
<td>显示组的窗口菜单。</td>
</tr>
<tr>
<td>Ctrl + 单击分组任务栏按钮</td>
<td>循环浏览组的窗口。</td>
</tr>
</tbody></table>
<h3 id="设置键盘快捷方式"><a href="#设置键盘快捷方式" class="headerlink" title="设置键盘快捷方式"></a>设置键盘快捷方式</h3><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键 + I</td>
<td>打开设置。</td>
</tr>
<tr>
<td>Backspace</td>
<td>返回到设置主页。</td>
</tr>
<tr>
<td>使用搜索框在任何页面上键入</td>
<td>搜索设置。</td>
</tr>
</tbody></table>
<h2 id="用于辅助功能的-Windows-键盘快捷方式"><a href="#用于辅助功能的-Windows-键盘快捷方式" class="headerlink" title="用于辅助功能的 Windows 键盘快捷方式"></a>用于辅助功能的 Windows 键盘快捷方式</h2><p>辅助功能快捷方式可帮助你将电脑与键盘或辅助设备结合使用。</p>
<p>下面是 Windows 10 中辅助技术的键盘快捷方式列表，包括“放大镜”、“高对比度”等其他快捷方式。</p>
<p>若要查看 Windows 10 中“讲述人”的键盘快捷方式和触摸手势列表，请参阅<a href="https://support.microsoft.com/zh-cn/help/22806">“讲述人”键盘命令和触摸手势</a>。</p>
<h3 id="“放大镜”键盘快捷方式"><a href="#“放大镜”键盘快捷方式" class="headerlink" title="“放大镜”键盘快捷方式"></a>“放大镜”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键 + 加号 (+)</td>
<td>打开放大镜</td>
</tr>
<tr>
<td>Windows 徽标键 + Esc</td>
<td>关闭放大镜</td>
</tr>
<tr>
<td>Windows 徽标键 + 加号 (+) 或减号 (-)</td>
<td>当放大镜打开时，进行放大或缩小</td>
</tr>
<tr>
<td>Ctrl + Alt + 鼠标滚轮</td>
<td>使用鼠标滚轮放大和缩小</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + M</td>
<td>打开放大镜设置</td>
</tr>
<tr>
<td>Ctrl + Alt + 箭头键</td>
<td>按箭头键的方向平移</td>
</tr>
<tr>
<td>Ctrl + ALT + I</td>
<td>反色</td>
</tr>
<tr>
<td>Ctrl + ALT + F</td>
<td>切换到全屏视图</td>
</tr>
<tr>
<td>Ctrl + ALT + L</td>
<td>切换到镜头视图</td>
</tr>
<tr>
<td>Ctrl + ALT + D</td>
<td>切换到停靠视图</td>
</tr>
<tr>
<td>Ctrl + Alt + M</td>
<td>循环浏览视图</td>
</tr>
<tr>
<td>Ctrl + ALT + R</td>
<td>使用鼠标调整镜头大小</td>
</tr>
<tr>
<td>Shift + Alt + 箭头键</td>
<td>使用键盘调整镜头大小</td>
</tr>
<tr>
<td>Ctrl + Alt + 空格键</td>
<td>使用全屏视图时快速查看整个桌面</td>
</tr>
</tbody></table>
<p>话说镜头视图真好用，比如你做一些教程或者录制视频的时候使用别人会看的更清晰哦，效果见下图。先按Windows 徽标键 + 加号 (+) ，然后按下 Ctrl + ALT + L 即可出现。</p>
<p><img data-src="https://i.loli.net/2020/04/02/ZFW5KGiYx7uQAXH.png" alt="image.png"></p>
<h3 id="其他辅助功能键盘快捷方式"><a href="#其他辅助功能键盘快捷方式" class="headerlink" title="其他辅助功能键盘快捷方式"></a>其他辅助功能键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>按右 Shift 八秒钟</td>
<td>打开和关闭筛选键</td>
</tr>
<tr>
<td>左 Alt + 左 Shift + Print Screen</td>
<td>打开或关闭高对比度</td>
</tr>
<tr>
<td>左 Alt + 左 Shift + Num Lock</td>
<td>打开或关闭鼠标键</td>
</tr>
<tr>
<td>按 Shift 五次</td>
<td>打开或关闭粘滞键</td>
</tr>
<tr>
<td>按 Num Lock 五秒钟</td>
<td>打开或关闭切换键</td>
</tr>
<tr>
<td>Windows 徽标键 + U</td>
<td>打开轻松使用设置中心</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + C</td>
<td>打开或关闭颜色滤镜</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + N</td>
<td>打开“讲述人”设置</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + S</td>
<td>打开 Windows 语音识别</td>
</tr>
<tr>
<td>Windows 徽标键 + Ctrl + O</td>
<td>打开屏幕键盘</td>
</tr>
</tbody></table>
<h2 id="Windows生僻快捷键"><a href="#Windows生僻快捷键" class="headerlink" title="Windows生僻快捷键"></a>Windows生僻快捷键</h2><p>Windows中的快捷键我们都很熟悉了，可是下面这些快捷键你平时用过吗？与普通的快捷键相比，它们的使用方法有些特别：这些键不能同时按下，而是要用两步或三步的连续操作，才能实现一项功能。虽然如此，使用这些快捷键也比使用鼠标方便。</p>
<p>Alt+空格→X 最大化当前窗口<br>Alt+空格→N 最小化当前窗口<br>提示：“Alt+空格→X”表示先按下“Alt+空格”组合键，然后松开组合键，再按下X键。下面“→”符号均表示先松开符号前按下的键，再按下符号后面的键。</p>
<p>在桌面或文件夹窗口中可使用以下快捷键（注意是文件夹窗口而不是具体的文件夹）：<br>右键→I→N 按名称排列图标<br>右键→I→T 按类型排列图标<br>右键→I→Z 按大小排列图标<br>右键→I→D 按日期排列图标<br>右键→W→F 新建文件夹<br>右键→R 若在桌面则打开“显示属性”在文件夹则打开该文件夹的属性<br>右键→E 刷新当前窗口，效果等同F5<br><strong>提示：这里的“右键”指的是主键盘区最下排右侧的Windows徽标键和Ctrl之间的那个键。</strong></p>
<p>如果当前窗口是某个具体文件或文件夹：<br>右键→S 创建当前文件或目录的快捷方式<br>右键→R 查看当前文件或目录属性（相当于Alt+Enter）<br>右键→O 打开当前文件或目录（相当于回车）<br>右键→T→A 发送当前文件或目录到软盘<br>注意：有些软件可能会在右键里增加一些菜单，这些菜单的快捷键可能会与系统快捷键发生冲突。比如WinRAR会在文件或文件夹的右键菜单中增加一个“添加到”的菜单，该菜单的快捷键S会与系统右键菜单“创建快捷方式（S）”发生冲突。如果要去掉这些“外来”的右键菜单，我们可以打开WinRAR，在菜单栏上依次点击“选项→设置”，打开“设置”对话框，在“综合”选项卡中点击“选择关联菜单项目”按钮，在打开的对话框中清空所有选项前的复选框即可。</p>
<p>如果当前窗口是记事本：<br>右键→U 撤消操作，效果等同与Ctrl+Z<br>右键→P 粘贴，效果等同与Ctrl+V<br>右键→A 选中全部文字，效果等同于Ctrl+A<br>使用“我的电脑”和“Windows资源管理器”的快捷键<br>目的快捷键<br>关闭所选文件夹及其所有父<br>文件夹按住 Shift键再单击“关闭按钮（仅适用于“我的电脑”）<br>向后移动到上一个视图 ALT+左箭头<br>向前移动到上一个视图 ALT+右箭头<br>查看上一级文件夹 BACKSPACE<br>其实，这些快捷键大家都可以在相关程序的右键菜单中找到，在这里只是选择了几个比较实用的归纳了一下，你也可以自己研究。比如当前窗口是某个文件或文件夹，那么用“右键→M”就可以对该文件或文件夹进行重命名操作。不同的程序有不同的快捷键，大家可以自己研究试用，举一反三。</p>
<h2 id="应用中的键盘快捷方式"><a href="#应用中的键盘快捷方式" class="headerlink" title="应用中的键盘快捷方式"></a>应用中的键盘快捷方式</h2><p>键盘快捷方式就是按键或按键组合，可提供另一种方式来执行通常使用鼠标执行的操作。</p>
<p>以下是 Windows 10 中多种 Microsoft 应用里常见的键盘快捷方式。包括以下应用的快捷方式：</p>
<ul>
<li><a href="https://support.microsoft.com/zh-cn/help/4531783">Microsoft Edge</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#cal">计算器</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#game">游戏栏</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#groove">Groove</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#map">地图</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#movie">电影和电视</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#paint">画图</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#Paint3D">画图 3D</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#photo">照片</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#voice">录音机</a></li>
<li><a href="https://support.microsoft.com/zh-cn/help/13805/windows-keyboard-shortcuts-in-apps#word">写字板</a></li>
</ul>
<p>在许多应用中，当你将鼠标指针悬停在某个按钮上时，工具提示中也会显示快捷方式。还有一些应用需要按 Alt 或 F10 键以显示可用的键盘快捷方式。如果菜单中某个字母有下划线，请同时按下 Alt 键和带有下划线的键，而不是选择该菜单项。例如，按 Ctrl + N 可在“画图”中创建新图片。</p>
<p>注意</p>
<p>使用触摸键盘时，您需要按 <strong>Ctrl</strong> 键来查看一些快捷方式。</p>
<h3 id="计算器键盘快捷方式"><a href="#计算器键盘快捷方式" class="headerlink" title="计算器键盘快捷方式"></a>计算器键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + 1</td>
<td>切换到“标准型”模式</td>
</tr>
<tr>
<td>Alt + 2</td>
<td>切换到“科学型”模式</td>
</tr>
<tr>
<td>Alt + 3</td>
<td>切换到“程序员”模式</td>
</tr>
<tr>
<td>Alt + 4</td>
<td>切换到“日期计算”模式</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>存储在内存中</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>添加到内存</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>从内存中减去</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>从内存中重新调用</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>清除内存</td>
</tr>
<tr>
<td>Delete</td>
<td>清除当前输入（选择“CE”）</td>
</tr>
<tr>
<td>Esc</td>
<td>完全清除输入（选择“C”）</td>
</tr>
<tr>
<td>F9</td>
<td>选择“±”</td>
</tr>
<tr>
<td>R</td>
<td>选择“1&#x2F;x”</td>
</tr>
<tr>
<td>@</td>
<td>求平方根</td>
</tr>
<tr>
<td>%</td>
<td>选择“%”</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>打开或关闭计算历史记录</td>
</tr>
<tr>
<td>向上键</td>
<td>在“历史记录”列表中上移</td>
</tr>
<tr>
<td>向下键</td>
<td>在“历史记录”列表中下移</td>
</tr>
<tr>
<td>Ctrl + Shift + D</td>
<td>清除历史记录</td>
</tr>
<tr>
<td>F3</td>
<td>在“科学型”模式下选择“DEG”</td>
</tr>
<tr>
<td>F4</td>
<td>在“科学型”模式下选择“RAD”</td>
</tr>
<tr>
<td>F5</td>
<td>在“科学型”模式下选择“GRAD”</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>在“科学型”模式下选择“10x”</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>在“科学型”模式下选择“cosh”</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>在“科学型”模式下选择“sinh”</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>在“科学型”模式下选择“tanh”</td>
</tr>
<tr>
<td>Shift + S</td>
<td>在“科学型”模式下选择“sin-1”</td>
</tr>
<tr>
<td>Shift + O</td>
<td>在“科学型”模式下选择“cos-1”</td>
</tr>
<tr>
<td>Shift + T</td>
<td>在“科学型”模式下选择“tan-1”</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>在“科学型”模式下选择“y√x”</td>
</tr>
<tr>
<td>D</td>
<td>在“科学型”模式下选择“Mod”</td>
</tr>
<tr>
<td>L</td>
<td>在“科学型”模式下选择“log”</td>
</tr>
<tr>
<td>M</td>
<td>在“科学型”模式下选择“dms”</td>
</tr>
<tr>
<td>N</td>
<td>在“科学型”模式下选择“ln”</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>在“科学型”模式下选择“ex”</td>
</tr>
<tr>
<td>O</td>
<td>在“科学型”模式下选择“cos”</td>
</tr>
<tr>
<td>P</td>
<td>在“科学型”模式下选择“Pi”</td>
</tr>
<tr>
<td>Q</td>
<td>在“科学型”模式下选择“x2”</td>
</tr>
<tr>
<td>S</td>
<td>在“科学型”模式下选择“sin”</td>
</tr>
<tr>
<td>T</td>
<td>在“科学型”模式下选择“tan”</td>
</tr>
<tr>
<td>V</td>
<td>在“科学型”模式下选择“F-E”</td>
</tr>
<tr>
<td>X</td>
<td>在“科学型”模式下选择“Exp”</td>
</tr>
<tr>
<td>Y, ^</td>
<td>在“科学型”模式下选择“xy”</td>
</tr>
<tr>
<td>#</td>
<td>在“科学型”模式下选择“x3”</td>
</tr>
<tr>
<td>!</td>
<td>在“科学型”模式下选择“n!”</td>
</tr>
<tr>
<td>%</td>
<td>在“科学型”或“程序员”模式下选择“Mod”</td>
</tr>
<tr>
<td>F2</td>
<td>在“程序员”模式下选择“DWORD”</td>
</tr>
<tr>
<td>F3</td>
<td>在“程序员”模式下选择“WORD”</td>
</tr>
<tr>
<td>F4</td>
<td>在“程序员”模式下选择“BYTE”</td>
</tr>
<tr>
<td>F5</td>
<td>在“程序员”模式下选择“HEX”</td>
</tr>
<tr>
<td>F6</td>
<td>在“程序员”模式下选择“DEC”</td>
</tr>
<tr>
<td>F7</td>
<td>在“程序员”模式下选择“OCT”</td>
</tr>
<tr>
<td>F8</td>
<td>在“程序员”模式下选择“BIN”</td>
</tr>
<tr>
<td>F12</td>
<td>在“程序员”模式下选择“QWORD”</td>
</tr>
<tr>
<td>A-F</td>
<td>在“程序员”模式下选择“A-F”</td>
</tr>
<tr>
<td>J</td>
<td>在“程序员”模式下选择“RoL”</td>
</tr>
<tr>
<td>K</td>
<td>在“程序员”模式下选择“RoR”</td>
</tr>
<tr>
<td>&lt;</td>
<td>在“程序员”模式下选择“Lsh”</td>
</tr>
<tr>
<td>&gt;</td>
<td>在“程序员”模式下选择“Rsh”</td>
</tr>
<tr>
<td>%</td>
<td>在“程序员”模式下选择“Mod”</td>
</tr>
<tr>
<td>|</td>
<td>在“程序员”模式下选择“Or”</td>
</tr>
<tr>
<td>^</td>
<td>在“程序员”模式下选择“Xor”</td>
</tr>
<tr>
<td>~</td>
<td>在“程序员”模式下选择“Not”</td>
</tr>
<tr>
<td>&amp;</td>
<td>在“程序员”模式下选择“And”</td>
</tr>
<tr>
<td>空格键</td>
<td>在“程序员”模式下切换位值</td>
</tr>
</tbody></table>
<h3 id="游戏栏键盘快捷方式"><a href="#游戏栏键盘快捷方式" class="headerlink" title="游戏栏键盘快捷方式"></a>游戏栏键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键 + G</td>
<td>打开游戏栏（当游戏处于打开状态时）</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + G</td>
<td>录制最后 30 秒</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + R</td>
<td>开始或停止录制</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + Print Screen</td>
<td>获取游戏的屏幕截图</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + T</td>
<td>显示或隐藏录制计时器</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + M</td>
<td>打开或关闭麦克风</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + B</td>
<td>开始或停止广播</td>
</tr>
<tr>
<td>Windows 徽标键 + Alt + W</td>
<td>在广播时显示相机</td>
</tr>
</tbody></table>
<h3 id="Groove-键盘快捷方式"><a href="#Groove-键盘快捷方式" class="headerlink" title="Groove 键盘快捷方式"></a>Groove 键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + P</td>
<td>播放或暂停</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>跳到下一曲</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>重新播放当前歌曲或跳到上一曲</td>
</tr>
<tr>
<td>F9</td>
<td>调高音量</td>
</tr>
<tr>
<td>F8</td>
<td>调低音量</td>
</tr>
<tr>
<td>F7</td>
<td>静音</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>选择项目并进入选择模式</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>全选</td>
</tr>
<tr>
<td>Delete</td>
<td>删除选定项</td>
</tr>
<tr>
<td>Ctrl + Shift + P</td>
<td>播放选定项</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>打开或关闭“重复播放”</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>打开或关闭“无序播放”</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>搜索</td>
</tr>
</tbody></table>
<h3 id="“地图”键盘快捷方式"><a href="#“地图”键盘快捷方式" class="headerlink" title="“地图”键盘快捷方式"></a>“地图”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>箭头键</td>
<td>按任意方向平移地图</td>
</tr>
<tr>
<td>Ctrl + 加号或减号键（+ 或 -）</td>
<td>放大或缩小</td>
</tr>
<tr>
<td>Ctrl + 向左键或向右键</td>
<td>旋转</td>
</tr>
<tr>
<td>Ctrl + 向上键或向下键</td>
<td>倾斜</td>
</tr>
<tr>
<td>+ 或 - 键</td>
<td>在 3D 城市视图中放大或缩小</td>
</tr>
<tr>
<td>Page Up 或 Page Down</td>
<td>在 3D 城市视图中推远或拉近</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>在鸟瞰图和道路视图之间切换地图视图</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>在你的当前位置上居中放置地图</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>获取路线</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>搜索</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>最小化活动选项卡</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>打印</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>显示或隐藏路况</td>
</tr>
<tr>
<td>Backspace</td>
<td>返回</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>共享</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>将焦点移动到地图</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>关闭活动选项卡</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>转到下一个选项卡</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>转到上一个选项卡</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>显示或隐藏“Streetside”</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制到剪贴板</td>
</tr>
</tbody></table>
<h3 id="“电影和电视”键盘快捷方式"><a href="#“电影和电视”键盘快捷方式" class="headerlink" title="“电影和电视”键盘快捷方式"></a>“电影和电视”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Enter</td>
<td>全屏播放</td>
</tr>
<tr>
<td>Esc</td>
<td>退出全屏</td>
</tr>
<tr>
<td>Enter</td>
<td>选择焦点中的内容</td>
</tr>
<tr>
<td>空格键或Ctrl + P</td>
<td>播放或暂停（当视频处于焦点中时）</td>
</tr>
<tr>
<td>Alt + 向左键或Windows 徽标键 + Backspace</td>
<td>返回</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>打开或关闭“重复播放”</td>
</tr>
<tr>
<td>F7</td>
<td>静音</td>
</tr>
<tr>
<td>F8</td>
<td>调低音量</td>
</tr>
<tr>
<td>F9</td>
<td>调高音量</td>
</tr>
</tbody></table>
<h3 id="“画图”键盘快捷方式"><a href="#“画图”键盘快捷方式" class="headerlink" title="“画图”键盘快捷方式"></a>“画图”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>F11</td>
<td>以全屏模式查看图片</td>
</tr>
<tr>
<td>F12</td>
<td>将此图片另存为新文件</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>选择整个图片</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>将所选文本改为粗体</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>将选择内容复制到剪贴板</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>打开“属性” 对话框</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>显示或隐藏网格线</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>将所选文本改为斜体</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>创建新图片</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>打开现有图片</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>打印图片</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>显示或隐藏标尺</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>将更改保存到图片</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>为所选文本添加下划线</td>
</tr>
<tr>
<td>Ctrl + V</td>
<td>从剪贴板粘贴选择内容</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>打开“调整大小和扭曲”对话框</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切选择内容</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>恢复更改</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销更改</td>
</tr>
<tr>
<td>Ctrl + 加号 (+)</td>
<td>将画笔、直线或形状轮廓的宽度增加一个像素</td>
</tr>
<tr>
<td>Ctrl + 减号 (-)</td>
<td>将画笔、直线或形状轮廓的宽度减少一个像素</td>
</tr>
<tr>
<td>Ctrl + Page Up</td>
<td>放大</td>
</tr>
<tr>
<td>Ctrl + Page Down</td>
<td>缩小</td>
</tr>
<tr>
<td>Alt + F4</td>
<td>关闭图片及其“画图”窗口</td>
</tr>
<tr>
<td>向右键</td>
<td>将选择内容或活动形状向右移动一个像素</td>
</tr>
<tr>
<td>向左键</td>
<td>将选择内容或活动形状向左移动一个像素</td>
</tr>
<tr>
<td>向下键</td>
<td>将选择内容或活动形状向下移动一个像素</td>
</tr>
<tr>
<td>向上键</td>
<td>将选择内容或活动形状向上移动一个像素</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>显示上下文菜单</td>
</tr>
</tbody></table>
<h3 id="“画图-3D”键盘快捷方式"><a href="#“画图-3D”键盘快捷方式" class="headerlink" title="“画图 3D”键盘快捷方式"></a>“画图 3D”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + 0 或 NumberPad0</td>
<td>重置缩放</td>
</tr>
<tr>
<td>Ctrl + 3</td>
<td>切换视图</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>选择工作区中的所有 3D 项目；重复命令切换到选择所有 2D 项目</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>将所选文本改为粗体</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制所选项目</td>
</tr>
<tr>
<td>Ctrl + Insert</td>
<td>复制所选项目</td>
</tr>
<tr>
<td>Ctrl + Shift + C</td>
<td>捕获屏幕截图</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>显示画布属性</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示或隐藏 3D 视角</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>组合对象</td>
</tr>
<tr>
<td>Ctrl + Shift + G</td>
<td>取消组合对象</td>
</tr>
<tr>
<td>I</td>
<td>打开取色器</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>将所选文本改为斜体</td>
</tr>
<tr>
<td>M</td>
<td>最小化或展开侧边菜单</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>新建图片或文件</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>打开现有图片或文件</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>2D 打印</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>保存</td>
</tr>
<tr>
<td>Ctrl + Shift + S</td>
<td>另存为</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>为所选文本添加下划线</td>
</tr>
<tr>
<td>Ctrl + V</td>
<td>粘贴选定项</td>
</tr>
<tr>
<td>Shift + Insert</td>
<td>粘贴选定项</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>选择画布</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>显示或隐藏画布</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切选定项</td>
</tr>
<tr>
<td>Shift + Delete</td>
<td>剪切选定项</td>
</tr>
<tr>
<td>Ctrl + Shift + X</td>
<td>2D 裁剪</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>恢复操作</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤消操作</td>
</tr>
<tr>
<td>Escape</td>
<td>停止或离开当前任务</td>
</tr>
<tr>
<td>Home</td>
<td>重置视图</td>
</tr>
<tr>
<td>PgUp</td>
<td>放大</td>
</tr>
<tr>
<td>Ctrl + PgUp</td>
<td>放大</td>
</tr>
<tr>
<td>PgDn</td>
<td>缩小</td>
</tr>
<tr>
<td>Ctrl + PgDn</td>
<td>缩小</td>
</tr>
<tr>
<td>Ctrl + 鼠标滚轮</td>
<td>放大或缩小</td>
</tr>
<tr>
<td>Ctrl + 向左键</td>
<td>向左环绕</td>
</tr>
<tr>
<td>Ctrl + 向右键</td>
<td>向右环绕</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>向上环绕</td>
</tr>
<tr>
<td>Ctrl + Down</td>
<td>向下环绕</td>
</tr>
<tr>
<td>Alt + 向左键</td>
<td>向左平移</td>
</tr>
<tr>
<td>Alt + 向右键</td>
<td>向右平移</td>
</tr>
<tr>
<td>Alt + 向上键</td>
<td>向上平移</td>
</tr>
<tr>
<td>Alt + 向下键</td>
<td>向下平移</td>
</tr>
<tr>
<td>Ctrl + 减号 (-) 或 [</td>
<td>减小画笔大小</td>
</tr>
<tr>
<td>Ctrl + 加号 (+) 或 ]</td>
<td>增大画笔大小</td>
</tr>
<tr>
<td>向右键</td>
<td>将选择内容或活动形状向右移动一个像素</td>
</tr>
<tr>
<td>向左键</td>
<td>将选择内容或活动形状向左移动一个像素</td>
</tr>
<tr>
<td>向下键</td>
<td>将选择内容或活动形状向下移动一个像素</td>
</tr>
<tr>
<td>向上键</td>
<td>将选择内容或活动形状向上移动一个像素</td>
</tr>
<tr>
<td>Alt + F4</td>
<td>关闭程序</td>
</tr>
<tr>
<td>F6</td>
<td>循环浏览窗口中或桌面上的屏幕元素</td>
</tr>
<tr>
<td>F10</td>
<td>激活应用中的菜单栏</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>显示上下文菜单</td>
</tr>
<tr>
<td>F11</td>
<td>以全屏模式查看图片</td>
</tr>
<tr>
<td>F12</td>
<td>将此图片另存为新文件</td>
</tr>
</tbody></table>
<h3 id="“照片”键盘快捷方式"><a href="#“照片”键盘快捷方式" class="headerlink" title="“照片”键盘快捷方式"></a>“照片”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>空格键（在“集锦”中）</td>
<td>选择项目并进入选择模式</td>
</tr>
<tr>
<td>Enter（从选择模式）</td>
<td>在处于选择模式下时选择项目</td>
</tr>
<tr>
<td>空格键（查看照片）</td>
<td>显示或隐藏命令</td>
</tr>
<tr>
<td>空格键（查看视频）</td>
<td>播放或暂停视频</td>
</tr>
<tr>
<td>箭头键（在集锦中）</td>
<td>向上、向下、向左或向右滚动</td>
</tr>
<tr>
<td>左箭头或右箭头键（位于单个项目或幻灯片放映上）</td>
<td>显示下一个或上一个项目</td>
</tr>
<tr>
<td>箭头键（位于缩放的照片上）</td>
<td>在照片内移动</td>
</tr>
<tr>
<td>Ctrl + 加号或减号（+ 或 -）</td>
<td>放大或缩小（查看照片时）</td>
</tr>
<tr>
<td>Ctrl + 0</td>
<td>重置照片的缩放</td>
</tr>
<tr>
<td>Esc</td>
<td>返回到上一个屏幕</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>保存</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>打印</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制</td>
</tr>
<tr>
<td>Ctrl + R（查看或编辑）</td>
<td>旋转照片</td>
</tr>
<tr>
<td>E（查看照片）</td>
<td>增强照片效果</td>
</tr>
<tr>
<td>Ctrl + Z（编辑）</td>
<td>撤销更改</td>
</tr>
<tr>
<td>Ctrl + Y（编辑）</td>
<td>恢复更改</td>
</tr>
<tr>
<td>Ctrl + &#x2F;（编辑）</td>
<td>查看原件</td>
</tr>
<tr>
<td>Shift + 箭头键</td>
<td>调整裁剪或选择性对焦区域的大小</td>
</tr>
<tr>
<td>Ctrl + 箭头键</td>
<td>移动裁剪或选择性对焦区域</td>
</tr>
<tr>
<td>F5（查看项目）</td>
<td>开始幻灯片放映</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>查看文件信息</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>设置为锁屏界面</td>
</tr>
<tr>
<td>Ctrl + N（在“相册”视图中）</td>
<td>创建新相册</td>
</tr>
<tr>
<td>Ctrl + R（在“相册”视图中）</td>
<td>删除相册</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>将选定项添加到相册</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>从相册中删除选定项</td>
</tr>
</tbody></table>
<h3 id="“录音机”键盘快捷方式"><a href="#“录音机”键盘快捷方式" class="headerlink" title="“录音机”键盘快捷方式"></a>“录音机”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + R</td>
<td>开始新录音</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>添加新标记到录音</td>
</tr>
<tr>
<td>Delete</td>
<td>删除选定录音</td>
</tr>
<tr>
<td>空格键</td>
<td>播放或暂停</td>
</tr>
<tr>
<td>Backspace</td>
<td>返回</td>
</tr>
<tr>
<td>F2</td>
<td>重命名录音</td>
</tr>
<tr>
<td>向右键或向左键</td>
<td>在播放录音时快进或快退</td>
</tr>
<tr>
<td>Shift + 向右键或向左键</td>
<td>加速快进或快退</td>
</tr>
<tr>
<td>Home</td>
<td>跳转到录音开头</td>
</tr>
<tr>
<td>End</td>
<td>跳转到录音末尾</td>
</tr>
</tbody></table>
<h3 id="“写字板”键盘快捷方式"><a href="#“写字板”键盘快捷方式" class="headerlink" title="“写字板”键盘快捷方式"></a>“写字板”键盘快捷方式</h3><table>
<thead>
<tr>
<th>按此键</th>
<th>执行此操作</th>
</tr>
</thead>
<tbody><tr>
<td>F3</td>
<td>在“查找”对话框中搜索文本的下一个实例</td>
</tr>
<tr>
<td>F12</td>
<td>将此文档另存为新文件</td>
</tr>
<tr>
<td>Ctrl + 1</td>
<td>设置单倍行距</td>
</tr>
<tr>
<td>Ctrl + 2</td>
<td>设置双倍行距</td>
</tr>
<tr>
<td>Ctrl + 5</td>
<td>将行距设置为 1.5</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>全选</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>将所选文本改为粗体</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>将选择内容复制到剪贴板</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>插入 Microsoft 绘图</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>向中心对齐文本</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>在文档中搜索文本</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>在文档中替换文本</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>将所选文本改为斜体</td>
</tr>
<tr>
<td>Ctrl + J</td>
<td>两端对齐文本</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>向左对齐文本</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>创建新文档</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>打开现有文档</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>打印文档</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>向右对齐文本</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>将更改保存到文档</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>为所选文本添加下划线</td>
</tr>
<tr>
<td>Ctrl + V</td>
<td>从剪贴板粘贴选择内容</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切选择内容</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>恢复更改</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销更改</td>
</tr>
<tr>
<td>Ctrl + 等于号 (&#x3D;)</td>
<td>使所选文本成为下标</td>
</tr>
<tr>
<td>Ctrl + Shift + 等于号 (&#x3D;)</td>
<td>使所选文本成为上标</td>
</tr>
<tr>
<td>Ctrl + Shift + 大于号 (&gt;)</td>
<td>增加字体大小</td>
</tr>
<tr>
<td>Ctrl + Shift + 小于号 (&lt;)</td>
<td>减小字体大小</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>将字符更改为全部使用大写字母</td>
</tr>
<tr>
<td>Ctrl + Shift + L</td>
<td>更改项目符号样式</td>
</tr>
<tr>
<td>Ctrl + 向左键</td>
<td>将光标向左移动一个字</td>
</tr>
<tr>
<td>Ctrl + 向右键</td>
<td>将光标向右移动一个字</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>将光标移动到上一行</td>
</tr>
<tr>
<td>Ctrl + 向下键</td>
<td>将光标移动到下一行</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>移动到文档的开头</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>移动到文档的末尾</td>
</tr>
<tr>
<td>Ctrl + Page Up</td>
<td>向上移动一个页面</td>
</tr>
<tr>
<td>Ctrl + Page Down</td>
<td>向下移动一个页面</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除下一个字</td>
</tr>
<tr>
<td>Alt + F4</td>
<td>关闭“写字板”</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>显示上下文菜单</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a href="https://support.microsoft.com/zh-cn/help/12445/windows-keyboard-shortcuts">微软-Windows 中的键盘快捷方式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/79380394">知乎-Windows快捷键大全</a></p>
<blockquote class="blockquote-center">
<p>世界上只有两种物质：高效率和低效率；世界上只有两种人：高效率的人和低效率的人。</p>
<p>—— 萧伯纳</p>

</blockquote>



]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年我订阅的Telegram频道</title>
    <url>/posts/20469.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429224148.png"></p>
<p>分享一些我订阅的 Telegram 频道 ，本文持续更新</p>
<span id="more"></span>





<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><h3 id="每周一书"><a href="#每周一书" class="headerlink" title="每周一书"></a>每周一书</h3><p>小声读书 👨🏻‍💻</p>
<p>人类的悲喜并不互通，但读书是走向共同理解的捷径。🖐</p>
<p>订阅地址：<a href="https://t.me/weekly_books">https://t.me/weekly_books</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429170345.png"></p>
<h3 id="zread-推-什么书值得读"><a href="#zread-推-什么书值得读" class="headerlink" title="zread (推) - 什么书值得读"></a>zread (推) - 什么书值得读</h3><p>可下载书籍、在线阅读书籍以及推送至 kindle 。爱好阅读的你不容错过。</p>
<blockquote>
<p>或许你正在寻觅，<br>那一隅祥和。<br>或许你正在等待，<br>那心之静谧。</p>
</blockquote>
<p>订阅地址：<a href="https://t.me/zreadpush">https://t.me/zreadpush</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429165825.png"></p>
<h3 id="读书-1"><a href="#读书-1" class="headerlink" title="读书"></a>读书</h3><p>爱好读书者的频道，收集了豆瓣成员投票选出的最佳书评，经济观察报，新京报等书评</p>
<p>订阅地址：<a href="https://t.me/douban001">https://t.me/douban001</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429171323.png"></p>
<h3 id="好书分享频道"><a href="#好书分享频道" class="headerlink" title="好书分享频道"></a>好书分享频道</h3><p>不定期分享收集的好书好资料。<br>学习，是一辈子的大事。</p>
<p>订阅地址： <a href="https://t.me/haoshufenxiang">https://t.me/haoshufenxiang</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429171642.png"></p>
<h3 id="我的小书屋"><a href="#我的小书屋" class="headerlink" title="我的小书屋"></a>我的小书屋</h3><p>我的小书屋更新频道</p>
<p>订阅地址：<a href="https://t.me/mebookupdate">https://t.me/mebookupdate</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429185502.png"></p>
<h3 id="电子书-Kindle-mobi-epub-azw3"><a href="#电子书-Kindle-mobi-epub-azw3" class="headerlink" title="电子书|Kindle|mobi|epub|azw3"></a>电子书|Kindle|mobi|epub|azw3</h3><p>分享一些电子书以及搜书技巧</p>
<p>订阅地址： <a href="https://t.me/dzsgx">https://t.me/dzsgx</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429193712.png"></p>
<h3 id="Kindle-电子书精品降价"><a href="#Kindle-电子书精品降价" class="headerlink" title="Kindle 电子书精品降价"></a>Kindle 电子书精品降价</h3><p>本频道专注于分享 kindle 电子书降价信息。</p>
<p>订阅地址： <a href="https://t.me/kindlePrice">https://t.me/kindlePrice</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429194726.png"></p>
<h3 id="英语外刊推送"><a href="#英语外刊推送" class="headerlink" title="英语外刊推送"></a>英语外刊推送</h3><p>1.主要推送周刊月刊，及优秀英语资源<br>2.推送外刊主要都是评论性文章，不像报纸一样具有时效性，因此过去的期刊也值得阅读。<br>3.外刊文章观点还请批判的看待。</p>
<p>订阅地址： <a href="https://t.me/ENmagazine_push">https://t.me/ENmagazine_push</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629210653.png"></p>
<h3 id="推书频道-Kindle-Mate"><a href="#推书频道-Kindle-Mate" class="headerlink" title="推书频道 Kindle Mate"></a>推书频道 Kindle Mate</h3><p>“It is what you read when you don’t have to that determines what you will be when you can’t help it- Oscar Wilde.”</p>
<p>订阅地址： <a href="https://t.me/kindlemate">https://t.me/kindlemate</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629210846.png"></p>
<h3 id="机械工业出版社资源"><a href="#机械工业出版社资源" class="headerlink" title="机械工业出版社资源"></a>机械工业出版社资源</h3><p>今年的春节比过去很多年都要漫长，在家宅着无聊的话也不要浪费时间了，多学点知识和技能总是有用的。最近几天来，除了一些在线课程之外，维普、知网、清华大学出版社等机构纷纷也免费开放，今天机械工业出版社也宣布开放6000多本电子书了。(实际只有4500本左右)<br>订阅地址： <a href="https://t.me/bookusefor1">https://t.me/bookusefor1</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629211234.png"></p>
<br />

<h2 id="信息咨询"><a href="#信息咨询" class="headerlink" title="信息咨询"></a>信息咨询</h2><h3 id="杂货屋频道"><a href="#杂货屋频道" class="headerlink" title="杂货屋频道"></a>杂货屋频道</h3><p>1、本频道是杂货屋博客的附属订阅频道，旨在分享各种技术博客内容；<br>2、本频道订阅了近400个技术博客，每天自动推送各种内容信息！</p>
<p>3、为了不影响各博客的流量，本频道只订阅主题信息，不推送原文，详细内容请前往原地址查看。</p>
<p>订阅地址： <a href="https://t.me/agintme">https://t.me/agintme</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429164943.png"></p>
<h3 id="少数派sspai"><a href="#少数派sspai" class="headerlink" title="少数派sspai"></a>少数派sspai</h3><p>少数派 (sspai.com) 官方频道，少数派致力于更好地运用数字产品或科学方法，帮助用户提升工作效率和生活品质.</p>
<p>订阅地址： <a href="https://t.me/sspai">https://t.me/sspai</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429165427.png"></p>
<h3 id="Newlearnerの自留地"><a href="#Newlearnerの自留地" class="headerlink" title="Newlearnerの自留地"></a>Newlearnerの自留地</h3><p>不定期推送IT相关资讯</p>
<p>订阅地址： <a href="https://t.me/NewlearnerChannel">https://t.me/NewlearnerChannel</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429174119.png"></p>
<h3 id="黑洞资源笔记"><a href="#黑洞资源笔记" class="headerlink" title="黑洞资源笔记"></a>黑洞资源笔记</h3><p>公开频道日常推送互联网资讯，学习网站(主要)等</p>
<p>订阅地址：<a href="https://t.me/tieliu">https://t.me/tieliu</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429175420.png"></p>
<h3 id="zrj766的频道"><a href="#zrj766的频道" class="headerlink" title="zrj766的频道"></a>zrj766的频道</h3><p>聚合了一些互联网的资讯</p>
<p>订阅地址： <a href="https://t.me/zrj96">https://t.me/zrj96</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429172507.png"></p>
<h3 id="极客公园"><a href="#极客公园" class="headerlink" title="极客公园"></a>极客公园</h3><p>极客公园聚焦互联网领域，跟踪最新的科技新闻动态，关注极具创新精神的科技产品。目前涵盖前沿科技、游戏、手机评测、硬件测评、出行方式、共享经济、人工智能等全方位的科技生活内容。现有前沿社、挖App、深度报道、极客养成指南等多个内容栏目。</p>
<p>订阅地址： <a href="https://t.me/geekpark001">https://t.me/geekpark001</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429180545.png"></p>
<h3 id="60秒读懂世界"><a href="#60秒读懂世界" class="headerlink" title="60秒读懂世界"></a>60秒读懂世界</h3><p>来自60秒读懂世界公众号</p>
<p>订阅地址： <a href="https://t.me/SharedResources">https://t.me/SharedResources</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429181503.png"></p>
<h3 id="一休儿的笔记"><a href="#一休儿的笔记" class="headerlink" title="一休儿的笔记"></a>一休儿的笔记</h3><p>一个博主的哲学频道</p>
<p>订阅地址：<a href="https://t.me/yixiuer">https://t.me/yixiuer</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429182425.png"></p>
<h3 id="高校Info"><a href="#高校Info" class="headerlink" title="高校Info"></a>高校Info</h3><p>提供各高校的频道及群聊入口，以及推送重要消息。</p>
<p>订阅地址：<a href="https://t.me/univinfo">https://t.me/univinfo</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429192943.png"></p>
<h3 id="jialezi-channel"><a href="#jialezi-channel" class="headerlink" title="jialezi_channel"></a>jialezi_channel</h3><p>jialezi博客的频道，推送一些信息咨询</p>
<p>订阅地址： <a href="https://t.me/jialezi66">https://t.me/jialezi66</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429194031.png"></p>
<h3 id="IPN-播客网络"><a href="#IPN-播客网络" class="headerlink" title="IPN 播客网络"></a>IPN 播客网络</h3><p>一天世界的播客更新</p>
<p>订阅地址： <a href="https://t.me/ipnpodcast">https://t.me/ipnpodcast</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429194500.png"></p>
<h3 id="🎏「-彼岸情报🔎！」见闻社"><a href="#🎏「-彼岸情报🔎！」见闻社" class="headerlink" title="🎏「 彼岸情报🔎！」见闻社"></a>🎏「 彼岸情报🔎！」见闻社</h3><p>云之彼端，约定之地。<br>互联网优质羊毛资源共享集社。</p>
<p>订阅地址： <a href="https://t.me/BaccanoSoul">https://t.me/BaccanoSoul</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429230354.png"></p>
<h3 id="yuefeng的碎碎念"><a href="#yuefeng的碎碎念" class="headerlink" title="yuefeng的碎碎念"></a>yuefeng的碎碎念</h3><p>频道保持低频率更新, 确保推送为优质信息, 节约大家时间, 提高订阅效率.</p>
<p>本频道:</p>
<ol>
<li>Python&#x2F;golang&#x2F;nodejs 编程, </li>
<li>开源项目，开源理念</li>
<li>linux服务器租赁&#x2F;维护</li>
<li>DevOps, serverless</li>
<li>docker&amp;k8s&amp;CNCF </li>
<li>instantbox 等开源项目开发进程</li>
<li>各种技术课程</li>
</ol>
<p>订阅地址：<a href="https://t.me/yuefengssn">https://t.me/yuefengssn</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/ShareX_20200506_152344_1437_842_Telegram.png"></p>
<h3 id="一些干货"><a href="#一些干货" class="headerlink" title="一些干货"></a>一些干货</h3><p>信息咨询，一些有趣的新闻等</p>
<p>订阅地址： <a href="https://t.me/youganhuo">https://t.me/youganhuo</a> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629200745.png"></p>
<h3 id="信息流瀑布-🤩"><a href="#信息流瀑布-🤩" class="headerlink" title="信息流瀑布 🤩"></a>信息流瀑布 🤩</h3><p>佳作阅读 影视资源 视频新闻 技能干货 软件应用</p>
<p>左岸读书、每日一文、十点读书、腾讯大家、知乎、百度知道、好奇心日报、电影美剧日剧韩剧、🙃 B站 Bilibili、😂YouTube、少数派、殁漂遥、小众软件、爱范儿、新闻媒体</p>
<p>订阅地址： <a href="https://t.me/nfeeds">https://t.me/nfeeds</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629201503.png"></p>
<h3 id="豆瓣知乎简书微信公众号💐"><a href="#豆瓣知乎简书微信公众号💐" class="headerlink" title="豆瓣知乎简书微信公众号💐"></a>豆瓣知乎简书微信公众号💐</h3><p>阅读，爱上书。<br>豆瓣 知乎 简书 左岸读书 腾讯大家 百度知道 我的小书屋   壹心理 十点读书  界面 三联生活周刊 南都周刊 连岳 韩寒一个 腾讯今日话题 新世相、微信公众号</p>
<p>订阅地址：<a href="https://t.me/dbzhjs">https://t.me/dbzhjs</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629201913.png"></p>
<h3 id="蛋挞报"><a href="#蛋挞报" class="headerlink" title="蛋挞报"></a>蛋挞报</h3><p>本频道不定期推送值得一读的文章，更新不会太频繁，亦无意占用各位过多时间。须知好文章最忌望文生义，如碰巧遇见自己感兴趣的话题，烦请读者耐心读过再作评断。</p>
<p>订阅地址： <a href="https://t.me/pincongessence">https://t.me/pincongessence</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629202248.png"></p>
<h3 id="微信搬运工"><a href="#微信搬运工" class="headerlink" title="微信搬运工"></a>微信搬运工</h3><p>本频道两个目的，1. 丰富电报上的中文内容（不可否认还是有很多非政治的优质内容在微信公众号里），2. 有些微信的内容分享了之后就和谐了，本频道可以做个备份。试运营中，欢迎订阅。</p>
<p>订阅地址： <a href="https://t.me/WeChatEssence">https://t.me/WeChatEssence</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629202435.png"></p>
<br />



<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="反斗软件更新"><a href="#反斗软件更新" class="headerlink" title="反斗软件更新"></a>反斗软件更新</h3><p>这里有反斗软件和反斗限免的文章更新</p>
<p>订阅地址: <a href="https://t.me/apprcn">https://t.me/apprcn</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429171855.png"></p>
<h3 id="52破解信息"><a href="#52破解信息" class="headerlink" title="52破解信息"></a>52破解信息</h3><p>同步52破解论坛的一些精品软件帖子</p>
<p>订阅地址： <a href="https://t.me/wuaipojie">https://t.me/wuaipojie</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429220731.png"></p>
<h3 id="RSSHub-布告栏"><a href="#RSSHub-布告栏" class="headerlink" title="RSSHub 布告栏"></a>RSSHub 布告栏</h3><p>RSS是个好东西，本频道内容将包含：</p>
<ul>
<li><p>RSSHub 核心更新</p>
</li>
<li><p>RSSHub 路由更新</p>
</li>
<li><p>RSSHub Radar 插件更新</p>
</li>
<li><p>rsshub.app 服务相关</p>
</li>
<li><p>RSSHub 新动向</p>
<p>订阅地址: <a href="https://t.me/awesomeRSSHub">https://t.me/awesomeRSSHub</a></p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429172707.png"></p>
<h3 id="资源分享平台-每日自动更新"><a href="#资源分享平台-每日自动更新" class="headerlink" title="资源分享平台@每日自动更新"></a>资源分享平台@每日自动更新</h3><p>每日自动推送相关活动&#x2F;技术&#x2F;软件&#x2F;新闻&#x2F;资讯&#x2F;羊毛&#x2F;VPS&#x2F;VPN</p>
<p>订阅地址： <a href="https://t.me/infosaodaye">https://t.me/infosaodaye</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429172218.png"></p>
<h3 id="精品软件分享（破解版）"><a href="#精品软件分享（破解版）" class="headerlink" title="精品软件分享（破解版）"></a>精品软件分享（破解版）</h3><p>分享一些破解软件</p>
<p>订阅地址： <a href="https://t.me/pj_cn">https://t.me/pj_cn</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429181713.png"></p>
<h3 id="🔥破解软件分享频道"><a href="#🔥破解软件分享频道" class="headerlink" title="🔥破解软件分享频道"></a>🔥破解软件分享频道</h3><p>提供各类电脑 安卓端 绿化 破解软件 </p>
<p>订阅地址： <a href="https://t.me/QQ877752030">https://t.me/QQ877752030</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429185310.png"></p>
<h3 id="TGgeek-TG极客-🆃🅶🅶🅴🅴🅺-Telegram-Geek"><a href="#TGgeek-TG极客-🆃🅶🅶🅴🅴🅺-Telegram-Geek" class="headerlink" title="TGgeek | TG极客 🆃🅶🅶🅴🅴🅺 | Telegram Geek"></a>TGgeek | TG极客 🆃🅶🅶🅴🅴🅺 | Telegram Geek</h3><p>Telegram 使用技巧、重要资讯、常见问答、中文汉化、版本更新等信息。</p>
<p>订阅地址： <a href="https://t.me/TGgeek">https://t.me/TGgeek</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429181933.png"></p>
<h3 id="🔥-教程-🔥"><a href="#🔥-教程-🔥" class="headerlink" title="🔥 教程 🔥"></a>🔥 教程 🔥</h3><p>各种教程 🔥 资源收集自网络，电子书，破解软件。</p>
<p>订阅地址： <a href="https://t.me/jiaocheng">https://t.me/jiaocheng</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429180323.png"></p>
<h3 id="胡萝卜周博客"><a href="#胡萝卜周博客" class="headerlink" title="胡萝卜周博客"></a>胡萝卜周博客</h3><p>胡萝卜周博客的频道，推送一些破解软件</p>
<p>订阅地址： <a href="https://t.me/carrotchoublog">https://t.me/carrotchoublog</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429190846.png"></p>
<h3 id="Xiaomi-Firmware-Updater"><a href="#Xiaomi-Firmware-Updater" class="headerlink" title="Xiaomi Firmware Updater"></a>Xiaomi Firmware Updater</h3><p>推送小米 ROM 更新的情况，可进去其网站下载</p>
<p>订阅地址： <a href="https://t.me/XiaomiFirmwareUpdater">https://t.me/XiaomiFirmwareUpdater</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429191014.png"></p>
<h3 id="🅻ihaiba资源福利分享🍭"><a href="#🅻ihaiba资源福利分享🍭" class="headerlink" title="🅻ihaiba资源福利分享🍭"></a>🅻ihaiba资源福利分享🍭</h3><p>分享一些课程等资源</p>
<p>订阅地址： <a href="https://t.me/lihaiba">https://t.me/lihaiba</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429191538.png"></p>
<h3 id="老师傅资源bar"><a href="#老师傅资源bar" class="headerlink" title="老师傅资源bar"></a>老师傅资源bar</h3><p>考研、考证、建筑、会计、教育等网络优质资源分享，计算机资源、付费课程分享</p>
<p>订阅地址： <a href="https://t.me/lsfbar1">https://t.me/lsfbar1</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429191953.png"></p>
<h3 id="懒得勤快官方频道"><a href="#懒得勤快官方频道" class="headerlink" title="懒得勤快官方频道"></a>懒得勤快官方频道</h3><p>懒得勤快官方频道，更新一些破解软件</p>
<p>订阅地址: <a href="https://t.me/ldqk2">https://t.me/ldqk2</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429192628.png"></p>
<h3 id="资源社"><a href="#资源社" class="headerlink" title="资源社"></a>资源社</h3><p>分享一些信息咨询、软件、电影等</p>
<p>订阅地址： <a href="https://t.me/zyshe">https://t.me/zyshe</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429193315.png"></p>
<h3 id="最新破解软件资源共享"><a href="#最新破解软件资源共享" class="headerlink" title="最新破解软件资源共享"></a>最新破解软件资源共享</h3><p>软件资源大全分享（包含破解版）</p>
<p>订阅地址： <a href="https://t.me/dxsoft">https://t.me/dxsoft</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429194938.png"></p>
<h3 id="Zapro-Notice"><a href="#Zapro-Notice" class="headerlink" title="Zapro Notice"></a>Zapro Notice</h3><p>资源软件共享</p>
<p>订阅地址 <a href="https://t.me/tmioeTG">https://t.me/tmioeTG</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629200247.png"></p>
<br />

<h2 id="影视-云盘"><a href="#影视-云盘" class="headerlink" title="影视&#x2F;云盘"></a>影视&#x2F;云盘</h2><h3 id="帮找资源"><a href="#帮找资源" class="headerlink" title="帮找资源"></a>帮找资源</h3><p>分享一些影视资源</p>
<p>订阅地址： <a href="https://t.me/lovesource">https://t.me/lovesource</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429173153.png"></p>
<h3 id="Google-Drive-资源免费资源共享"><a href="#Google-Drive-资源免费资源共享" class="headerlink" title="Google Drive 资源免费资源共享"></a>Google Drive 资源免费资源共享</h3><p>这里有各种 Google Drive 资源，包括大电影，小电影，电子书，无损音乐等。                                 </p>
<p>订阅地址： <a href="https://t.me/gdmfzygx">https://t.me/gdmfzygx</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429174631.png"></p>
<h3 id="dotplayer订阅列表"><a href="#dotplayer订阅列表" class="headerlink" title="dotplayer订阅列表"></a>dotplayer订阅列表</h3><p>提供一些 m3u8 的直播源，，这样就可以使用 Potplayer 看电视啦。</p>
<p>订阅地址： <a href="https://t.me/dotplayer">https://t.me/dotplayer</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429180727.png"></p>
<h3 id="Sync资源更新（只发key）"><a href="#Sync资源更新（只发key）" class="headerlink" title="Sync资源更新（只发key）"></a>Sync资源更新（只发key）</h3><p>分享一下影视资源，使用 Resilio Sync 同步下载。 </p>
<p>订阅地址： <a href="https://t.me/shenkey">https://t.me/shenkey</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200429192235.png"></p>
<h3 id="天翼云盘资源分享频道"><a href="#天翼云盘资源分享频道" class="headerlink" title="天翼云盘资源分享频道"></a>天翼云盘资源分享频道</h3><p>天翼云资源分享</p>
<p>订阅地址： <a href="https://t.me/tyypshare">https://t.me/tyypshare</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200629203950.png"></p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><blockquote>
<p>更新日志：</p>
<p>20200629增加： Zapro Notice 、一些干货、豆瓣知乎简书微信公众号💐、信息流瀑布 🤩、蛋挞报、微信搬运工、天翼云盘资源分享频道、英语外刊推送、机械工业出版社资源、推书频道 Kindle Mate</p>
</blockquote>
<br />

<br />

<br />

<blockquote class="blockquote-center">
<p>人生忽如寄，莫辜负茶汤和好天气。</p>
<p>​                                     ——汪曾祺</p>

</blockquote>

<br />

<br />

<br />

<br />

<br />


]]></content>
      <categories>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>善用佳软</tag>
        <tag>推荐</tag>
        <tag>那些年系列</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 word 中粘贴出现找不到 MathPage.wll 文件的错误</title>
    <url>/posts/57547.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403100620.png"></p>
<p>MathType 是一款功能很强大的数学公式编辑器,但是因为不明原因,有时在 word 中复制粘贴时会出现找不到MathPage.wll 文件的错误窗口提示，导致粘贴失效。</p>
<span id="more"></span>





<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403094938.png"></p>
 <br />

<br />

<h2 id="确保路径被office信任"><a href="#确保路径被office信任" class="headerlink" title="确保路径被office信任"></a>确保路径被office信任</h2><p>依次打开word-&gt;文件-&gt;选项-&gt;信任中心-&gt;信任中心设置-&gt;添加新位置</p>
<p><code>C:\Program Files\Microsoft Office\root\Office16\STARTUP</code></p>
 <br />

 <br />

<h2 id="复制-MathPage-wll"><a href="#复制-MathPage-wll" class="headerlink" title="复制 MathPage.wll"></a>复制 MathPage.wll</h2><p>在 <code>C:\Program Files (x86)\MathType\MathPage\64\MathPage.wll </code> 路径下找到 MathPage.wll ，复制到 <code>C:\Program Files\Microsoft Office\root\Office16</code> 文件夹中</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403093157.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403093440.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403093632.png"></p>
 <br />

 <br />

<h2 id="复制-MathType-Commands-2016-dotm"><a href="#复制-MathType-Commands-2016-dotm" class="headerlink" title="复制 MathType Commands 2016.dotm"></a>复制 MathType Commands 2016.dotm</h2><p>在 <code>C:\Program Files (x86)\MathType\Office Support\64</code> 路径下复制  MathType Commands 2016.dotm 文件到 <code>C:\Program Files\Microsoft Office\root\Office16\STARTUP</code> </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403094027.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403094140.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2020/20200403094221.png"></p>
<p>打开word ，一切恢复正常。😁</p>
<br />

<br />

<br />

<br />



<blockquote class="blockquote-center">
<p>一定要爱着点什么，恰似草木对光阴的钟情。</p>
<p> ——《人间草木》</p>

</blockquote>

<br />

<br />

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 2019激活码/序列号🎰</title>
    <url>/posts/d0ed2dd.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/image_bed/2011911/1401_compressed.jpg" alt=" "></p>
<p>宇宙第一IDE Visual Studio 2019 &#x2F;2017 专业版&#x2F;企业版激活码</p>
<span id="more"></span>

<h2 id="VS2019专业版企业版密钥"><a href="#VS2019专业版企业版密钥" class="headerlink" title="VS2019专业版企业版密钥"></a>VS2019专业版企业版密钥</h2><p>Visual Studio 2019 专业版：<code>NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y</code></p>
<p>Visual Studio 2019 企业版：<code>BF8Y8-GN2QH-T84XB-QVY3B-RC4DF </code></p>
<h2 id="VS2017专业版企业版密钥"><a href="#VS2017专业版企业版密钥" class="headerlink" title="VS2017专业版企业版密钥"></a>VS2017专业版企业版密钥</h2><p>Visual Studio 2017企业版 ：<code>NJVYC-BMHX2-G77MM-4XJMR-6Q8QF</code><br>Visual Studio 2017 专业版：<code>KBJFW-NXHK6-W4WJM-CRMQB-G3CDH</code></p>
<blockquote>
<p>vs2019专业版和vs2017项目兼容,可以同时安装，建议商业项目使用正版。</p>
<p>激活码来源于网络</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>分享</tag>
        <tag>Windows</tag>
        <tag>Visual Studio</tag>
        <tag>激活码</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载GoogleDrive后不显示共享文件夹/与我共享</title>
    <url>/posts/39158.html</url>
    <content><![CDATA[<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510173146.png"></p>
<p>解决挂载 Google Drive 后不显示共享文件夹。</p>
<span id="more"></span>





<p>挂载 Google Drive 和 OneDrive 差不多，只是需要注意一下“网络环境” 。</p>
<p>说明: 挂载前可以在终端输入以下命令为终端开启代理环境，不然后面验证的时候可能出错，哪怕你已经 PAC 或者 全局代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>键入以上命令后，请<del>开始你的表演</del>开始配置 Google Drive ，相信你会很顺利的。</p>
<p>可参考上篇文章配置，<a href="https://www.lifeee.top/posts/14654.html"><strong>Windows平台下使用 Rclone 挂载 OneDrive 为本地硬盘</strong></a>  。第四步输入要配置的网盘类型时选择Google Drive 。</p>
<br/>

<br/>

<h2 id="显示共享文件夹-Share-with-me"><a href="#显示共享文件夹-Share-with-me" class="headerlink" title="显示共享文件夹 Share with me"></a>显示共享文件夹 Share with me</h2><p>当你在浏览器打开过别人共享的链接后，会在与我共享（Share with me）中显示别人共享的文件夹。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510170441.png"></p>
<br/>

<p>但是 若你按照我上一篇文章 <a href="https://www.lifeee.top/posts/14654.html"><strong>Windows平台下使用 Rclone 挂载 OneDrive 为本地硬盘</strong></a> 操作的话，会发现别人共享的文件夹是没有显示出来的。应该是在配置的过程中忘记开启 Share with me 了。又懒又机智的我打开了 rclone.conf 文件加入了一行代码，然后就显示 Share with me 的文件了。</p>
<div class="note warning"><p>rclone.conf 的路径为：<br><code>C:\Users\你的用户名\.config\rclone</code></p>
</div>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510171206.png"></p>
<p>加入的代码为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shared_with_me = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510171407.png"></p>
<br/>

<br/>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>挂载前文件很少：</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510165800.png"></p>
<p>挂载后文件超级多，一页 Rclone Browser 都显示不下了。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/MyPicture/img20200510171539.png"></p>
<br />

<br/>





<blockquote class="blockquote-center">
<p>家人闲坐，灯火可亲。</p>
<p>——汪曾祺 《冬天》 </p>

</blockquote>



<br/>

<br/>

<br/>

<br/>]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
        <category>善用佳软</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>问题</tag>
        <tag>云盘</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第39期</title>
    <url>/posts/16879.html</url>
    <content><![CDATA[<p>欢迎阅读第39期技术资讯！欢迎阅读本期技术资讯！ <strong>工具推荐</strong>方面方面，我们介绍了UI Notes - 真实产品 UI 设计灵感库可以探索 UI 设计的最新趋势；AI编程助手：Fitten Code，可提供代码自动补全、注释生成、智能bug查找和自动生成单元测试等功能；算法可视化面板编辑器，旨在教用户如何使用一个算法可视化工具来增强对算法执行过程的理解；Pixiv第三方桌面客户端。<strong>宝藏信息</strong>方面，分享了播客广场发现更多感兴趣的播客，本地知识库问答系统，以及TikTok Notes 图文社交平台。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404172314679.jpg" alt="封面图 西溪湿地四月·2024"></p>
<span id="more"></span>



<br />

<p>欢迎来到第39期 ！😄</p>
<p>期待您通过RSS订阅本博客：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650852618&idx=1&sn=aa6bd07ce7e35c18050842b84dd3c1da&scene=58&subscene=0">Android 线程池周期性任务踩坑探究</a>: 作者分享了在开发性能监控功能时，如何使用线程池来执行定时任务，以及在使用<code>ScheduledExecutorService</code>时遇到的一些问题。作者首先介绍了使用<code>Handler</code>进行定时任务调度的代码示例，然后讨论了使用<code>ScheduledExecutorService</code>来支持多个监控任务的定时执行。</p>
<p>作者遇到了一个问题，即在某些用户的设备上，性能采集任务的执行时间异常，导致任务在短时间内被执行了数百次。通过分析<code>ScheduledThreadPoolExecutor</code>的源码，作者发现<code>scheduleAtFixedRate</code>方法可能会导致任务执行间隔异常，如果任务的执行时间超过了设定的间隔时间。</p>
<p>为了解决这个问题，作者建议使用<code>scheduleWithFixedDelay</code>方法来代替<code>scheduleAtFixedRate</code>，并且记录任务实际的执行间隔，如果间隔超过阈值，则可以选择丢弃本次采样结果或进行数据校准。</p>
</li>
<li><p><a href="https://juejin.cn/post/7356535808930938918">如何应对Android面试官 -&gt; ActivityManagerService 是怎么启动的？  </a>：文章首先介绍了Android系统的启动过程，然后深入探讨了ActivityManagerService（AMS）的定义、作用和重要性。AMS是Android系统中一个关键的系统服务，负责管理应用程序的生命周期、进程调度和资源管理等。文章通过分析AMS的启动流程，包括创建系统上下文、启动引导服务、初始化AMS服务等关键步骤，详细说明了AMS是如何在Android系统中被启动和初始化的。此外，文章还提到了AMS与其他系统服务如WindowManagerService和Installer的交互，以及AMS在系统服务中的地位和作用。</p>
</li>
<li><p><a href="https://juejin.cn/column/7355302255409922087">Spring源码 - 好像在哪儿见过的专栏  </a>：专栏中包含了多篇文章，每篇文章都针对Spring Boot的不同方面进行了深入的源码分析。</p>
<ol>
<li><strong>Spring Boot源码分析一：启动流程</strong><ul>
<li>作为系列的第一篇文章，作者对Spring Boot项目的启动流程进行了全面的分析。</li>
<li>介绍了Spring Boot启动的基本概念和流程。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析二：启动流程</strong><ul>
<li>该篇文章是对Spring Boot启动流程的又一次深入分析。</li>
<li>重点讨论了<code>spring.factories</code>文件的读取和解析。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析三：启动流程</strong><ul>
<li>文章聚焦于Spring Boot启动流程中的<code>createSpringFactoriesInstances</code>方法。</li>
<li>讨论了如何通过构造方法读取<code>spring.factories</code>文件。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析四：启动流程</strong><ul>
<li>继续探讨Spring Boot项目的启动流程。</li>
<li>分析了创建监听器<code>SpringFactoriesInstances</code>的过程。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析五：启动流程</strong><ul>
<li>深入分析了Spring Boot项目的启动流程。</li>
<li>特别关注了事件类型<code>resolveDefaultEventType</code>的传入参数类型。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析六：解析启动args参数</strong><ul>
<li>文章介绍了如何解析Spring Boot启动时的命令行参数。</li>
<li>讨论了<code>run</code>方法中的<code>DefaultApplicationArguments</code>对象的作用。</li>
</ul>
</li>
<li><strong>Spring Boot源码分析七：prepareEnvironment</strong><ul>
<li>分析了<code>prepareEnvironment</code>方法，该方法负责创建和配置环境变量，通常为<code>SERVLET</code>环境。</li>
<li>探讨了<code>getOrCreateEnvironment</code>的实现，以及<code>ApplicationServletEnvironment</code>的创建过程。</li>
</ul>
</li>
</ol>
</li>
<li><p><a href="https://juejin.cn/post/7357922389415723017">AndroidStuido 使用 Bookmarks 和 TODO 提高开发效率 </a>：这篇文章向读者展示了Android Studio中两个非常有用的工具：Bookmarks和TODO。Bookmarks允许开发者在代码中添加自定义标签以便快速定位，而TODO则帮助开发者追踪代码中的待办事项。文章通过具体的示例和操作步骤，详细解释了如何在实际开发中利用这两个工具来优化工作流程。同时，作者还探讨了TODO和Bookmarks的不同使用场景，指出TODO适合团队协作，而Bookmarks更适合个人开发。文章最后建议将这两个工具结合使用，以进一步提高开发效率。</p>
</li>
</ul>
<br />

<br />


<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="UI-Notes-真实产品-UI-设计灵感库"><a href="#UI-Notes-真实产品-UI-设计灵感库" class="headerlink" title="UI Notes - 真实产品 UI 设计灵感库"></a><a href="https://uinotes.com/">UI Notes - 真实产品 UI 设计灵感库</a></h2><p><a href="https://uinotes.com/">UI Notes</a> 收集了大量线上优秀 App 的完整 UI 截图，只有落地设计没有飞机稿你可以在这里探索 UI 设计的最新趋势、浏览竞品的产品设计、快速找到工作中需要的灵感。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404152322808.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404152323874.png"></p>
<p>在线网址：<a href="https://uinotes.com/">https://uinotes.com/</a></p>
<br />

<h2 id="AI编程助手：Fitten-Code"><a href="#AI编程助手：Fitten-Code" class="headerlink" title="AI编程助手：Fitten Code"></a>AI编程助手：<a href="https://code.fittentech.com/">Fitten Code</a></h2><p><a href="https://code.fittentech.com/">Fitten Code</a>是一个基于AI的编程助手，它提供代码自动补全、注释生成、智能bug查找和自动生成单元测试等功能。该工具支持超过80种主流编程语言，并且兼容包括VS Code、PyCharm、IntelliJ和Visual Studio在内的多个IDE。Fitten Code的特点是高准确率、快速响应和丰富的代码补全量，显著提升了不同开发场景下的工作效率。用户可以通过在注释中描述需求，让Fitten Code生成符合要求的代码，减少手动编写的时间和精力。此外，Fitten Code还提供了插件版本，方便用户在他们喜欢的代码编辑器中使用。</p>
<p>特性：</p>
<ul>
<li><p>代码自动补全：Fitten Code 能够自动为您的代码补充缺失的部分，节省您宝贵的开发时间。</p>
</li>
<li><p>注释生成代码：Fitten code 基于AI大模型对代码进行语义级翻译，支持多种编程语言互译。</p>
</li>
<li><p>自动添加注释：Fitten Code 能够根据您的代码自动生成相关注释，为您的代码提供清晰易懂的解释和文档。</p>
</li>
<li><p>智能bug查找，解释代码，自动生成单元测试的功能，根据代码自动产生相应的测试用例等</p>
</li>
</ul>
<p>网站介绍：<a href="https://code.fittentech.com/">https://code.fittentech.com/</a></p>
<br />

<h2 id="算法可视化面板编辑器"><a href="#算法可视化面板编辑器" class="headerlink" title="算法可视化面板编辑器"></a>算法可视化面板编辑器</h2><p><a href="https://labuladong.online/algo-visualize/">labuladong的算法可视化</a>这个页面由“labuladong”发布，旨在教用户如何使用一个算法可视化工具来增强对算法执行过程的理解。 </p>
<p>基本用法</p>
<ul>
<li>控制按钮和滑动条：位于顶部，用于控制代码的逐步执行。</li>
<li>代码面板：位于左侧，当前执行到的代码行会高亮显示，支持点击代码行跳转到指定位置。</li>
<li>编辑功能：点击顶部的“编辑”按钮后，代码面板变成编辑器，允许直接修改代码并运行。</li>
</ul>
<p>最常用的技巧</p>
<ul>
<li>利用点击代码行跳转至特定位置的功能，类似于IDE中的“运行到光标位置”。</li>
</ul>
<p>可视化区域</p>
<ul>
<li>右侧：用于显示变量、数据结构、堆栈信息、递归数等。</li>
<li>左下角：Log Console，增强版的<code>console.log</code>，自动根据递归深度缩进输出。</li>
<li>右下角：悬浮按钮，提供刷新面板、全屏显示、显示&#x2F;隐藏Log Console等功能。</li>
</ul>
<p>数据结构的可视化</p>
<ul>
<li>支持数组、链表、二叉树、哈希表、哈希集合等数据结构的可视化。</li>
<li>介绍了如何在面板中创建和操作这些数据结构。</li>
</ul>
<p>变量隐藏和作用域提升</p>
<ul>
<li>使用<code>@visualize global</code>将变量提升至全局作用域。</li>
<li>使用<code>@visualize hide</code>隐藏不需要显示的变量。</li>
</ul>
<p>递归过程的可视化</p>
<ul>
<li>介绍了如何使用<code>@visualize status</code>、<code>@visualize choose</code>和<code>@visualize unchoose</code>注释来控制递归树的可视化。</li>
</ul>
<p>使用<code>@visualize</code>的注意事项</p>
<ul>
<li>定义函数时的语法要求。</li>
<li>注释必须写在函数定义的上一行。</li>
</ul>
<p>实操练习</p>
<ul>
<li>提供了一系列实操练习，包括二叉树的遍历、递归树的生长、穷举结果的快速获取、理解自顶向下&#x2F;自底向上思维模式等。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404172233334.png" alt="image-20240417223308046"></p>
<p><strong>使用教程（必读）</strong>：<a href="https://labuladong.online/algo/intro/visualize/">https://labuladong.online/algo/intro/visualize/</a></p>
<p>在线网站：<a href="https://labuladong.online/algo-visualize/">https://labuladong.online/algo-visualize/</a> </p>
<br />

<h2 id="Pixeval-基于-NET-8和WinUI-3的Pixiv第三方桌面客户端"><a href="#Pixeval-基于-NET-8和WinUI-3的Pixiv第三方桌面客户端" class="headerlink" title="Pixeval: 基于.NET 8和WinUI 3的Pixiv第三方桌面客户端"></a>Pixeval: 基于.NET 8和WinUI 3的Pixiv第三方桌面客户端</h2><p>GitHub上的Pixeval项目是一个基于.NET 8和WinUI 3的开源Pixiv第三方桌面客户端，提供多语言支持，仅兼容Windows 10。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404162226385.png"></p>
<p>下载方式： <a href="https://github.com/dylech30th/Pixeval/releases/latest">https://github.com/dylech30th/Pixeval/releases/latest</a></p>
<p>作者介绍：<a href="https://sora.ink/archives/391">https://sora.ink/archives/391</a></p>
<p>开源地址：<a href="https://github.com/Pixeval/Pixeval">https://github.com/Pixeval/Pixeval</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="播客广场-：发现更多感兴趣的播客"><a href="#播客广场-：发现更多感兴趣的播客" class="headerlink" title="播客广场  ：发现更多感兴趣的播客"></a><a href="https://www.pcspy.net/">播客广场 </a> ：发现更多感兴趣的播客</h2><p><a href="https://www.pcspy.net/">播客广场 </a> 是一个在线网站，旨在通过话题来发现播客，而不是传统上通过播客频道来探索。作者介绍可以查看 <a href="https://sspai.com/post/87991">https://sspai.com/post/87991</a>  。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404162242704.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404162243848.png"></p>
<p>在线网站：<a href="https://www.pcspy.net/">https://www.pcspy.net/</a></p>
<br />

<h2 id="本地知识库问答系统，可断网安装使用：-Question-and-Answer-based-on-Anything"><a href="#本地知识库问答系统，可断网安装使用：-Question-and-Answer-based-on-Anything" class="headerlink" title="本地知识库问答系统，可断网安装使用：  Question and Answer based on Anything"></a>本地知识库问答系统，可断网安装使用：  Question and Answer based on Anything</h2><p><strong>QAnything</strong> (<strong>Q</strong>uestion and <strong>A</strong>nswer based on <strong>Anything</strong>) 是致力于支持任意格式文件或数据库的本地知识库问答系统，可断网安装使用。</p>
<p>您的任何格式的本地文件都可以往里扔，即可获得准确、快速、靠谱的问答体验。</p>
<p>目前已支持格式: **PDF(pdf)<strong>，</strong>Word(docx)<strong>，</strong>PPT(pptx)<strong>，</strong>XLS(xlsx)<strong>，</strong>Markdown(md)<strong>，</strong>电子邮件(eml)<strong>，</strong>TXT(txt)<strong>，</strong>图片(jpg，jpeg，png)<strong>，</strong>CSV(csv)<strong>，</strong>网页链接(html)**，更多格式，敬请期待…</p>
<p><strong>特点</strong></p>
<ul>
<li>数据安全，支持全程拔网线安装使用。</li>
<li>支持跨语种问答，中英文问答随意切换，无所谓文件是什么语种。</li>
<li>支持海量数据问答，两阶段向量排序，解决了大规模数据检索退化的问题，数据越多，效果越好。</li>
<li>高性能生产级系统，可直接部署企业应用。</li>
<li>易用性，无需繁琐的配置，一键安装部署，拿来就用。</li>
<li>支持选择多知识库问答。</li>
</ul>
<p><strong>架构</strong></p>
<p><img data-src="https://s2.loli.net/2024/04/17/i6dlsnNJCRO3r7u.png"></p>
<ul>
<li><a href="https://qanything.ai/">🏄 在线试用QAnything</a></li>
<li><a href="https://read.youdao.com/">📚 在线试用有道速读</a></li>
<li><a href="https://github.com/netease-youdao/BCEmbedding">🛠️ 想只使用BCEmbedding(embedding &amp; rerank)</a></li>
<li><a href="https://github.com/netease-youdao/QAnything/blob/master/FAQ_zh.md">📖 常见问题</a></li>
<li><a href="https://github.com/netease-youdao/QAnything/blob/master/README_zh.md#%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">安装方式</a></li>
</ul>
<p>开源地址：<a href="https://github.com/netease-youdao/QAnything/">https://github.com/netease-youdao/QAnything/</a> </p>
<br />

<h2 id="TikTok-Notes-图文社交平台正式推出"><a href="#TikTok-Notes-图文社交平台正式推出" class="headerlink" title="TikTok Notes 图文社交平台正式推出"></a>TikTok Notes 图文社交平台正式推出</h2><p>经过数周的传闻和猜测，TikTok Notes 终于在部分国家&#x2F;地区推出。该应用将通过图文内容与 Instagram 竞争。与之不同的是 TikTok Notes 的首页推荐使用网格列表，使用户能够同时浏览多个帖子。应用介绍中写到：“TikTok Notes 是一个生活方式平台，提供有关人们生活的信息丰富的图文内容，您可以在其中看到人们分享他们的旅行技巧、日常食谱等。”</p>
<p><img data-src="https://s2.loli.net/2024/04/17/No5mp4AQeUKaBzf.png"></p>
<p>信息来源：<a href="https://t.me/xhqcankao/9629">风向旗参考快讯 https://t.me/xhqcankao/9629</a></p>
<p>下载地址：<a href="https://play.google.com/store/apps/details?id=com.ss.android.ugc.spark&gl=ca">Play 商店</a>  、<a href="https://apps.apple.com/ca/app/tiktok-notes/id6476737806">App Store</a> </p>
<br />

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://www.qbitai.com/2024/04/134329.html?utm_source=pocket_reader">WPS 365全新发布 开启企业一站式AI办公</a>: 金山办公发布了WPS 365，一个集成了文档编辑、AI能力和协作功能的一站式办公平台，旨在提升企业生产力。</p>
</li>
<li><p><a href="https://www.mycaijing.com/article/detail/518815?source_id=40&share_from=weixin">被竞业之后，把工资加倍还给前公司的人</a>：文章通过多个案例，详细描述了员工在签署竞业限制协议后，因加入竞争对手公司而遭到前雇主起诉并要求赔偿的情况。这些员工包括应届生、基层员工以及高级技术人员，他们面临的赔偿金额从几万元到上千万元不等。文章指出，随着互联网行业竞争加剧，竞业限制协议的应用越来越广泛，甚至扩展到非核心岗位的员工。这种做法不仅给员工带来了经济负担，还对他们的职业生涯和精神健康造成了严重影响。文章还提到，一些公司将竞业限制的执行和追诉作为公司内部的绩效考核，这种做法在法律上可能存在争议，但在实际操作中却给员工带来了实实在在的压力。</p>
</li>
<li><p><a href="https://www.latepost.com/news/dj_detail?id=2227">晚点独家丨抖音生活服务一季度销售额超 1000 亿，但未缩小与美团差距  </a>：文章指出，抖音生活服务在2023年第一季度的核销前销售额超过了1000亿元，同比增长超过100%，但与美团到店业务的销售额相比，市场份额并未发生显著变化。抖音生活服务依靠其庞大的流量和低价补贴迅速扩大了业务规模，但面临着流量和补贴的局限性。为此，抖音开始调整策略，包括高层轮岗、收缩酒旅业务、并入外卖运力运营团队等，以集中资源到店业务上。</p>
</li>
<li><p><a href="https://www.latepost.com/news/dj_detail?id=2220">从考公、写周报到下厨指南，晚点评测 18 个大模型 </a>：文章报道了一系列针对大模型的测试，包括中文理解、公务员考试题目解答、数学题解答、编程能力、新闻写作和生活助手等场景。在中文理解方面，中国大模型普遍表现更好，尤其是在公务员考试题目上。数学题解答方面，大模型们通常能够给出正确答案，但在更复杂的数学问题上表现不一。编程能力测试中，大模型在Python方面表现出色，但在新兴的Go语言上则存在不足。新闻写作方面，大模型能够帮助工作流程，但在创造性分析方面仍有待提高。生活助手场景中，大模型在情绪抚慰和解读保险条款上表现各异，而在洗标识别和做菜规划上则存在明显不足。最后，文章指出，尽管大模型在多个领域取得了进步，但与人类相比仍有差距，且行业对大模型的期待也在不断提高。</p>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于    <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第41期</title>
    <url>/posts/57689.html</url>
    <content><![CDATA[<p>欢迎阅读第41期技术资讯！ <strong>工具推荐方面</strong>，我们介绍了剪切助手，一个高颜值、操作简便的剪切板管理工具，支持快速分享、数据云同步以及跨平台使用；ProxyPin一款基于Flutter开发的开源免费抓包工具，支持Windows、Mac、Android、IOS、Linux 全平台系统；哔哩哔哩插件大全；海螺AI，由 MiniMax 开发的综合AI助手，可以生成各种创意文本格式、进行网络搜索、解决图片相关难题、进行语音通话、生成文档摘要、进行休闲对话。鸿蒙hap查看器，一个跨平台的鸿蒙hap查看器，方便开发者在电脑上预览hap的信息，并提供一键安装到设备等功能；Video-subtitle-remover，一款基于AI技术，将视频中的硬字幕去除的软件GeekDesk，一款小巧、美观的桌面快速启动管理工具，集成了 Everything 搜索功能，适用Windows平台。<strong>宝藏信息方面</strong>，分享CodeLocator，一个包含 Android SDK 与 Android Studio 插件的 Android 工具集，可以帮助开发者提高开发效率；fluent_ui ，使用 Flutter 设计漂亮的原生 Windows 应用程序。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405062234740.png"></p>
<span id="more"></span>



<br />

<p>欢迎来到第41期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://www.infoq.cn/article/yNcE04ykpAlHTcoAdum6">如何将技术债务纳入路线图_软件工程 _InfoQ </a>：文章首先描述了技术债务对软件系统的影响，以及它如何影响公司的基础设施和运营。作者提出了一个关键问题：如何确保技术项目获得足够的关注并被优先处理。 接着，文章介绍了优先级排序过程，包括如何将产品经理的想法和输入整合成提案，并通过Constable事实曲线（Truth Curve）来评估这些想法的价值。文章强调了将技术债务与业务目标对齐的重要性，并提出了转换语言的方法，即将工程任务的优先级和时间表与业务目标联系起来。 文章还讨论了技术债务的不同方面，包括客户可见的特性和幕后工作，如工具链、测试和法规遵从性。作者建议使用服务水平目标（SLO）来连接技术指标与业务价值，并利用数据来证明技术项目的必要性和成果。 最后，文章建议在技术债务解决方案完成后，要庆祝成就，并传达其对业务的积极影响，以此作为未来技术项目的有力支持。</li>
<li><a href="https://mp.weixin.qq.com/s/InAzeSa-2YeV2oo6gnykhg">Flutter 之 HTTP3&#x2F;QUIC 和 Cronet 你了解过吗？</a>： 文章首先解释了HTTP3&#x2F;QUIC协议的出现是为了解决现有网络协议在移动环境下的不足，如TCP在网络环境变化时无法保持连接状态的问题。QUIC协议运行在UDP之上，提供了连接迁移（connection migration）的能力，允许在网络环境变化（如从Wi-Fi切换到5G）时保持连接状态，从而提高用户体验。QUIC还集成了TLS加密，减少了HTTPS请求所需的时间，并且优化了多路复用字节流，解决了TCP的队头阻塞问题。 接着，文章介绍了Cronet，这是Chromium网络栈的实现，支持TCP和QUIC协议。Cronet能够根据服务端的支持情况自动选择使用QUIC协议，从而提高网络请求的效率。在Flutter应用中，可以通过<code>cronet_http</code>包和<code>dio</code>库的<code>cronet_adapter</code>来使用Cronet。文章还提到了使用Cronet的不同方式，包括依赖Google Play服务和嵌入式Cronet。 最后，文章鼓励开发者尝试使用HTTP&#x2F;3和QUIC，因为这些技术已经得到了云服务商的支持，并且可能已经在一些项目中被使用。</li>
<li><a href="https://mp.weixin.qq.com/s/6Ci6dqynTg1IfAuvYQUj1g">花里胡哨，如何在 Flutter 中制作多种颜色的 TextField </a>: 文章展示了如何通过自定义 <code>TextEditingController</code> 来实现一个支持多种颜色文本的 <code>TextField</code>，以及如何利用 <code>flutter_highlighting</code> 包进行代码高亮显示。</li>
<li><a href="https://mp.weixin.qq.com/s/fymCUTyO-yMA2L-b67rjtg">Flutter Keys：你的终极指南，让 widget 世界更快乐  </a>:  文章详细介绍了Flutter框架中五种不同类型的Key：UniqueKey、ValueKey、ObjectKey、PageStorageKey和GlobalKey。每种Key都有其独特的用途和潜在的优缺点。UniqueKey用于确保小部件的唯一性，ValueKey基于特定值识别小部件，ObjectKey根据对象的标识区分对象，PageStorageKey用于保留滚动位置和状态信息，而GlobalKey提供全局访问和交互性。文章强调了正确使用Key的重要性，并提供了最佳实践建议，以避免不必要的性能问题和内存泄漏。</li>
<li><a href="https://mp.weixin.qq.com/s/MzUTA_yS5zV3KbgeDSCBlQ">用BuildSrc管理Android依赖版本已经过时了？Catalogs才是版本答案？  </a>：文章首先介绍了Android项目中常见的三种依赖版本管理方案：config.gradle、buildSrc和version Catalogs。作者指出，目前社区中Catalogs方案受到较多青睐，因为它提供了更好的代码提示和版本升级提示。 接着，文章分析了使用BuildSrc方案的弊端，包括编译时间可能较长、可能存在Gradle版本冲突等问题。然后，作者详细介绍了Catalogs方案的实现和使用，展示了如何通过Catalogs定义依赖版本、库、插件等，并在项目中应用这些定义。 文章还讨论了Catalogs方案在中大型项目和组件化开发中的应用，以及如何通过自定义Gradle文件的方式，然后在各组件中引入对应的依赖来实现集中管理和封装。 最后，作者总结了三种方案的优缺点，并推荐了对于不同规模项目适用的方案。作者认为，对于新项目或老项目改造，Catalogs方案更为推荐，因为它在代码导航和版本管理方面表现更优。</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="剪切助手-遥遥领先的复制粘贴效率工具"><a href="#剪切助手-遥遥领先的复制粘贴效率工具" class="headerlink" title="剪切助手 - 遥遥领先的复制粘贴效率工具"></a><a href="https://jianqiezhushou.com/">剪切助手 - 遥遥领先的复制粘贴效率工具</a></h2><p><a href="https://jianqiezhushou.com/">剪切助手</a> 是一个高颜值、操作简便的剪切板管理工具，支持快速分享、数据云同步以及跨平台使用(支持Windows 和 MacOS)。</p>
<p>特效：</p>
<ul>
<li><strong>高颜值</strong>：界面简洁美观，提供良好的用户体验。</li>
<li><strong>快速分享</strong>：用户可以一键分享他们复制的内容，方便与他人协作。</li>
<li><strong>数据云同步</strong>：支持多设备间的数据传输，确保数据安全，防止丢失。</li>
<li><strong>跨平台</strong>：可以在Windows和MacOS操作系统上免费使用。</li>
</ul>
<p>这个工具适合需要频繁使用剪切板并在不同设备间同步数据的用户，它通过简化剪切板的管理，帮助用户节省时间并提高工作效率。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404232234643.png"></p>
<p>下载地址：<a href="https://jianqiezhushou.com/">https://jianqiezhushou.com/</a></p>
<br />



<h2 id="跨平台开源免费抓包工具-ProxyPin"><a href="#跨平台开源免费抓包工具-ProxyPin" class="headerlink" title="跨平台开源免费抓包工具 ProxyPin"></a>跨平台开源免费抓包工具 <a href="https://github.com/wanghongenpin/network_proxy_flutter">ProxyPin</a></h2><p> <a href="https://github.com/wanghongenpin/network_proxy_flutter">ProxyPin</a> 是一款基于Flutter开发的开源免费抓包工具，支持Windows、Mac、Android、IOS、Linux 全平台系统。</p>
<p><strong>特性</strong></p>
<ul>
<li>手机扫码连接: 不用手动配置Wifi代理，包括配置同步。所有终端都可以互相扫码连接转发流量。</li>
<li>域名过滤: 只拦截您所需要的流量，不拦截其他流量，避免干扰其他应用。</li>
<li>请求重写: 支持重定向，支持替换请求或响应报文，也可以根据增则修改请求或或响应。</li>
<li>请求屏蔽: 支持根据URL屏蔽请求，不让请求发送到服务器。</li>
<li>脚本: 支持编写JavaScript脚本来处理请求或响应。</li>
<li>搜索：根据关键词响应类型多种条件搜索请求</li>
<li>其他：收藏、历史记录、工具箱等</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403072233010.png"></p>
<p>开源地址：<a href="https://github.com/wanghongenpin/network_proxy_flutter">https://github.com/wanghongenpin/network_proxy_flutter</a></p>
<br />



<h2 id="网页哔哩哔哩插件大全"><a href="#网页哔哩哔哩插件大全" class="headerlink" title="网页哔哩哔哩插件大全"></a>网页哔哩哔哩插件大全</h2><p>BiliPlus<br><a href="https://github.com/0xlau/biliplus">https://github.com/0xlau/biliplus</a></p>
<p>BiliScope<br><a href="https://github.com/gaogaotiantian/biliscope">https://github.com/gaogaotiantian/biliscope</a></p>
<p>BewlyBewly<br><a href="https://github.com/hakadao/BewlyBewly">https://github.com/hakadao/BewlyBewly</a></p>
<p>pakku：哔哩哔哩弹幕过滤器<br><a href="https://github.com/xmcp/pakku.js">https://github.com/xmcp/pakku.js</a></p>
<p>Bilibili-Evolved<br><a href="https://github.com/the1812/Bilibili-Evolved">https://github.com/the1812/Bilibili-Evolved</a></p>
<p>bilibili-app-recommend<br><a href="https://greasyfork.org/zh-CN/scripts/443530-bilibili-app-recommend">https://greasyfork.org/zh-CN/scripts/443530-bilibili-app-recommend</a></p>
<p>首页推荐<br><a href="https://github.com/indefined/UserScripts">https://github.com/indefined/UserScripts</a></p>
<p>抽奖取关<br><a href="https://greasyfork.org/zh-CN/scripts/387046">https://greasyfork.org/zh-CN/scripts/387046</a></p>
<p>Bilibili 按标签、标题、时长、UP主屏蔽视频<br><a href="https://greasyfork.org/zh-CN/scripts/481629">https://greasyfork.org/zh-CN/scripts/481629</a></p>
<p>b站屏蔽增强器<br><a href="https://greasyfork.org/zh-CN/scripts/461382-b%E7%AB%99%E5%B1%8F%E8%94%BD%E5%A2%9E%E5%BC%BA%E5%99%A8">https://greasyfork.org/zh-CN/scripts/461382-b%E7%AB%99%E5%B1%8F%E8%94%BD%E5%A2%9E%E5%BC%BA%E5%99%A8</a></p>
<p>来自：<a href="https://www.bilibili.com/video/BV15t421P7Dt?vd_source=1e1aa0f06f98286544f4193f7bfd4bdc">【b站还能装插件？三分钟让你的b站像开外挂一样好用！】</a></p>
<br />

<h2 id="海螺AI-类似与Kimi-chat"><a href="#海螺AI-类似与Kimi-chat" class="headerlink" title="海螺AI (类似与Kimi chat)"></a>海螺AI (类似与Kimi chat)</h2><p>海螺AI 是由 MiniMax 开发的综合AI助手，旨在提高工作效率并为用户提供各种任务的多功能工具。它包含以下功能，可满足各种需求：</p>
<ul>
<li><strong>创意文本生成：</strong> 海螺AI 可以帮助生成各种创意文本格式，例如诗歌、代码、脚本、音乐作品、电子邮件和信件，满足用户的写作和创作需求。</li>
<li><strong>网络搜索：</strong> 利用其互联网连接，海螺AI 使用户无需离开应用程序即可执行网络搜索，快速获取信息和知识。</li>
<li><strong>图片问题解决：</strong> 通过利用图像识别功能，海螺AI 可以解决与图片相关的难题。用户只需拍摄查询图片，海螺AI 即可提供相关信息或解决方案。</li>
<li><strong>语音通话：</strong> 海螺AI 提供语音通话功能，使用户可以直接通过应用程序拨打电话，无需单独的电话拨号器。</li>
<li><strong>文档摘要：</strong> 对于冗长的文档，海螺AI 可以提取关键点并生成摘要，帮助用户有效地掌握内容的要点。</li>
<li><strong>休闲对话：</strong> 海螺AI 可以进行休闲对话，提供陪伴和开放式对话平台。</li>
</ul>
<p><strong>输入 github 项目链接也能总结，kimi似乎不行。</strong></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202404252137269.png"></p>
<br />

<h2 id="一个跨平台的鸿蒙hap查看器，方便开发者在电脑上预览hap的信息，并提供一键安装到设备等功能"><a href="#一个跨平台的鸿蒙hap查看器，方便开发者在电脑上预览hap的信息，并提供一键安装到设备等功能" class="headerlink" title="一个跨平台的鸿蒙hap查看器，方便开发者在电脑上预览hap的信息，并提供一键安装到设备等功能"></a>一个跨平台的鸿蒙hap查看器，方便开发者在电脑上预览hap的信息，并提供一键安装到设备等功能</h2><p>鸿蒙hap查看器，支持解析 OpenHarmony(开源鸿蒙)、HarmonyOS(鸿蒙)、HarmonyOS NEXT(鸿蒙星河版) API9+(Stage模型)的应用安装包。</p>
<ul>
<li>电脑版（跨平台）：<a href="https://gitee.com/westinyang/hap-viewer">westinyang&#x2F;hap-viewer</a></li>
<li>手机版（Android）：<a href="https://gitee.com/westinyang/hap-viewer-android">westinyang&#x2F;hap-viewer-android</a></li>
<li><strong>网页版（响应式）</strong>：<a href="https://gitee.com/westinyang/hap-viewer-web">westinyang&#x2F;hap-viewer-web</a></li>
</ul>
<p>衍生项目：</p>
<ul>
<li><a href="https://gitee.com/ericple/hapv-cli">hapv-cli</a> <code>命令行版的hap查看器，目前由@ericple维护</code> HAPV-CLI <code>命令行版的hap查看器，目前由@ericple维护</code> 系列</li>
<li><a href="https://github.com/F7YM/HapViewer-iOS">HapViewer-iOS</a> <code>iOS快捷指令版的hap查看器，目前由@F7YM维护</code> HapViewer-iOS的 <code>iOS快捷指令版的hap查看器，目前由@F7YM维护</code></li>
</ul>
<p>开源地址：<a href="https://github.com/westinyang/hap-viewer">https://github.com/westinyang/hap-viewer</a></p>
<br />



<h2 id="基于AI的图片-视频硬字幕去除、文本水印去除-Video-subtitle-remover-VSR"><a href="#基于AI的图片-视频硬字幕去除、文本水印去除-Video-subtitle-remover-VSR" class="headerlink" title="基于AI的图片&#x2F;视频硬字幕去除、文本水印去除 Video-subtitle-remover (VSR)"></a>基于AI的图片&#x2F;视频硬字幕去除、文本水印去除 <a href="https://github.com/YaoFANGUK/video-subtitle-remover">Video-subtitle-remover (VSR)</a></h2><p><a href="https://github.com/YaoFANGUK/video-subtitle-remover">Video-subtitle-remover (VSR)</a> 是一款基于AI技术，将视频中的硬字幕去除的软件。 主要实现了以下功能：</p>
<ul>
<li><strong>无损分辨率</strong>将视频中的硬字幕去除，生成去除字幕后的文件</li>
<li>通过超强AI算法模型，对去除字幕文本的区域进行填充（非相邻像素填充与马赛克去除）</li>
<li>支持自定义字幕位置，仅去除定义位置中的字幕（传入位置）</li>
<li>支持全视频自动去除所有文本（不传入位置）</li>
<li>支持多选图片批量去除水印文本</li>
</ul>
<p><a href="https://github.com/YaoFANGUK/video-subtitle-remover/raw/main/design/demo.png"><img data-src="https://github.com/YaoFANGUK/video-subtitle-remover/raw/main/design/demo.png"></a></p>
<p>开源地址：<a href="https://github.com/YaoFANGUK/video-subtitle-remover">https://github.com/YaoFANGUK/video-subtitle-remover</a></p>
<br />

<h2 id="小巧、美观的桌面快速启动工具-GeekDesk-Windows平台"><a href="#小巧、美观的桌面快速启动工具-GeekDesk-Windows平台" class="headerlink" title="小巧、美观的桌面快速启动工具 GeekDesk [Windows平台]"></a>小巧、美观的桌面快速启动工具 <a href="https://github.com/BookerLiu/GeekDesk">GeekDesk</a> [Windows平台]</h2><p><a href="https://github.com/BookerLiu/GeekDesk">GeekDesk</a> 是一款小巧、美观的桌面快速启动管理工具，集成了 Everything 搜索功能，适用Windows平台。</p>
<p>特性：</p>
<ul>
<li>全局热键 一键呼出 鼠标跟随</li>
<li>自定义壁纸</li>
<li>毛玻璃等界面效果</li>
<li>自定义菜单图标</li>
<li>定时提醒 永不忘记</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403072259180.png"></p>
<p>开源地址：<a href="https://github.com/BookerLiu/GeekDesk">https://github.com/BookerLiu/GeekDesk</a> </p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="CodeLocator：Android开发利器"><a href="#CodeLocator：Android开发利器" class="headerlink" title="CodeLocator：Android开发利器"></a>CodeLocator：Android开发利器</h2><p>CodeLocator 是字节跳动开源的一个包含 Android SDK 与 Android Studio 插件的 Android 工具集，可以帮助开发者提高开发效率。</p>
<p>CodeLocator 功能丰富，涵盖 UI 相关、调试、性能优化等多个方面。</p>
<p><strong>UI 相关功能</strong></p>
<ul>
<li>查看当前界面的 View 层级、属性、尺寸和间距等信息</li>
<li>实时修改 View 属性</li>
<li>跳转到对应 Activity、Fragment 和 XML 布局文件</li>
<li>快速启动 Charles 代理</li>
<li>显示布局边界、触摸位置、过渡绘制等</li>
</ul>
<p><strong>调试功能</strong></p>
<ul>
<li>定位当前响应触摸事件的 View</li>
<li>获取当前 View 绑定的数据</li>
<li>获取当前 View 对应的绘制内容</li>
</ul>
<p><strong>性能优化功能</strong></p>
<ul>
<li>查看应用所有 Fragment 的信息</li>
<li>查看自定义的 App 运行时信息</li>
<li>查看当前应用的文件信息</li>
</ul>
<p>开源地址：<a href="https://github.com/bytedance/CodeLocator">https://github.com/bytedance/CodeLocator</a></p>
<br />

<h2 id="fluent-ui-使用-Flutter-设计漂亮的原生-Windows-应用程序"><a href="#fluent-ui-使用-Flutter-设计漂亮的原生-Windows-应用程序" class="headerlink" title="fluent_ui  : 使用 Flutter 设计漂亮的原生 Windows 应用程序"></a><a href="https://pub.dev/packages/fluent_ui">fluent_ui  </a>: 使用 Flutter 设计漂亮的原生 Windows 应用程序</h2><p><a href="https://pub.dev/packages/fluent_ui">fluent_ui  </a> 可以使用 Flutter 设计漂亮的原生 Windows 应用程序，遵循Fluent UI指南。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403082322851.png"></p>
<p>包地址： <a href="https://pub.dev/packages/fluent_ui">https://pub.dev/packages/fluent_ui</a></p>
<p>开源地址：<a href="https://github.com/bdlukaa/fluent_ui">https://github.com/bdlukaa/fluent_ui</a></p>
<br />

<br />

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><p><a href="https://36kr.com/newsflashes/2764074616126466">国信证券：银行一季度业绩可能是近几年的底部区域。</a></p>
</li>
<li><p><a href="https://www.jiemian.com/article/11138204.html">报告：2060年韩国死亡人口将达出生人口近5倍</a></p>
</li>
<li><p><a href="https://h5-ol.sns.sohu.com/hy-moyukik-h5/daily-news/1787388635054633002?sf_my=copylink&cid=027050285105835163904&uid=1115497">因电动汽车激增，今年全球汽油需求增速将减半。</a></p>
</li>
<li><p><a href="https://api3.cls.cn/share/article/1668244?os=web&sv=&app=CailianpressWeb">比特币突破65000美元 以太坊突破3200美元 </a>。</p>
</li>
<li><p><a href="https://www.ithome.com/0/766/059.htm">YouTube推出“跳转至精彩部分”实验性功能：AI预测用户想看内容，跳转视频最佳部分</a>：YouTube面向所有Premium订阅者推出由AI驱动的“跳转至精彩部分”（Jump Ahead）功能。目前该功能仅能在美区的YouTube安卓应用程序上使用，并且仅适用于英语视频。“跳转至精彩部分”通过结合用户数和AI来预测用户可能想看的内容，可直接跳转至视频的最佳部分。YouTube从三月份开始测试此功能，之前仅对美国的部分Premium用户开放，现在所有YouTube Premium会员都可以通过youtube.com&#x2F;new尝试此功能。</p>
</li>
<li><p><a href="https://www.ithome.com/0/766/334.htm">携程：客服可在 2025 年春节期间回乡办公一个半月 </a>：携程集团宣布，客服团队全面推行春节回乡办公政策，各客服团队可根据实际需求，实施该政策。以 2025 年春节为例，员工可申请 2024 年 12 月 29 日至 2025 年 2 月 15 日回乡办公。也就是说，<strong>携程客服可在明年春节前提前一个月返乡，在春节后两周返回公司，携程的混合办公将在春节期间延长至一个半月的时间</strong>。</p>
</li>
<li><p><a href="https://www.jiemian.com/article/11133794.html">苹果启动史上最大规模股票回购，库克称中国是全球竞争最激烈的市场 </a></p>
</li>
<li><p><a href="https://www.latepost.com/news/dj_detail?id=2259">晚点独家丨阿里 618 取消预售，重启淘宝网页版  </a>：淘天集团在2024年618大促中做出重要调整，取消预售并优化PC网页版，以提升用户体验。这些改变反映了公司战略的转变，即从追求短期数据转向尊重用户选择。尽管面临挑战，但这些调整是公司为了长期发展和用户满意度所做出的努力。</p>
</li>
</ul>
<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于    <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第43期</title>
    <url>/posts/22872.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一系列实用工具和资源：Bruno，一款开源API管理客户端，支持Git友好操作和纯文本标记语言；夸克搜，一个专注于夸克网盘资源的搜索引擎；FRE123动漫搜索引擎，提供在线动漫资源搜索；在线生成二维码油猴脚本，方便用户生成页面地址二维码；C-Light，一个AI图像处理工具，通过智能打光技术增强图片效果。此外，我们还介绍了沉浸式线性代数学习资源，以及流畅阅读浏览器翻译插件，支持多语言翻译和双语模式。这些工具和资源旨在提升您的工作效率和学习体验，助您在技术领域更进一步。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405262249756.jpg"></p>
<span id="more"></span>



<br />

<p>欢迎来到第43期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://juejin.cn/post/7335067315452428297">Flutter 2024 路线规划，更多可期待的功能正在路上</a>： 文章概述了Flutter在2024年的开发路线图，重点介绍了Impeller引擎的发展、Material 3的支持、跨平台视图、隐私标准适配、Dart与其他语言的交互、Web和桌面端的改进，以及Dart宏编程的引入。</li>
<li><a href="https://mp.weixin.qq.com/s/-jsSQvGodOLmN6eseR8RNg?utm_source=pocket_saves">程序员如何提升个人技术影响力｜得物技术 </a>:  文章主要指导程序员如何通过一系列具体的方法和步骤来提升个人在技术领域的影响力。作者从技术大会主编的角度出发，分享了如何通过不断学习和实践，以及通过Github项目贡献、撰写技术文章、进行演讲和出版书籍等方式来构建和扩大技术影响力。文章强调了持续学习和输出的重要性，并提供了一些实用的建议和技巧，如如何准备技术文章、如何提升演讲技巧以及如何出版书籍等。</li>
<li><a href="https://juejin.cn/post/7327686547808927778">聊聊鸿蒙HarmonyOS NEXT 的技术细节</a>：文章探讨了华为鸿蒙操作系统的技术细节，特别是其微内核架构、OS结构、方舟编译器以及鸿蒙应用开发的三种方式。</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="Bruno-：API-管理请求客户端"><a href="#Bruno-：API-管理请求客户端" class="headerlink" title="Bruno ：API 管理请求客户端"></a>Bruno ：API 管理请求客户端</h2><p> <a href="https://www.usebruno.com/">Bruno</a> 是一款快速、Git 友好的开源 API 客户端，旨在彻底改变 Postman、Insomnia 和其他类似工具所代表的现状。<br>Bruno 会将收藏直接存储在文件系统的文件夹中。其使用纯文本标记语言 Bru 来保存有关 API 请求的信息。</p>
<p><img data-src="https://www.usebruno.com/images/landing-2.png"></p>
<p>开源地址：<a href="https://github.com/usebruno/bruno">https://github.com/usebruno/bruno</a></p>
<h2 id="夸克搜-在线搜索夸克网盘资源"><a href="#夸克搜-在线搜索夸克网盘资源" class="headerlink" title="夸克搜 在线搜索夸克网盘资源"></a>夸克搜 在线搜索夸克网盘资源</h2><p>“夸克搜”是一个专注于夸克网盘的搜索引擎，它允许用户搜索存储在夸克网盘上的资源。网页提供了一些热门资源的展示，包括动漫、影视等，并有分类榜单和最近更新的内容。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405222315528.png" alt="image-20240522231528274"></p>
<p>在线地址：<a href="https://www.quark.so/">https://www.quark.so/</a></p>
<h2 id="FRE123-动漫搜索引擎"><a href="#FRE123-动漫搜索引擎" class="headerlink" title="FRE123 动漫搜索引擎"></a>FRE123 动漫搜索引擎</h2><p>FRE123 动漫搜索引擎专注于在线搜索动漫资源。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405222320567.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405222321827.png"></p>
<p>在线地址：<a href="https://www.fre321.com/anime/s">https://www.fre321.com/anime/s</a></p>
<br />



<h2 id="在线生成二维码（油猴脚本）"><a href="#在线生成二维码（油猴脚本）" class="headerlink" title="在线生成二维码（油猴脚本）"></a>在线生成二维码（油猴脚本）</h2><p>在页面左下角添加一个图标，点击后生成当前页面地址二维码</p>
<p>安装地址： <a href="https://greasyfork.org/en/scripts/473640-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E6%A0%87">https://greasyfork.org/en/scripts/473640-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E6%A0%87</a></p>
<br />



<h2 id="AI智能打光：C-Light"><a href="#AI智能打光：C-Light" class="headerlink" title="AI智能打光：C-Light"></a>AI智能打光：C-Light</h2><p>C-Light是一个AI图像处理工具，它通过智能打光技术来增强图片的视觉效果。用户可以上传图片，选择光源位置，并输入提示词，AI会根据这些信息生成具有优质光影效果的图片。此工具还能实现图片与背景的无缝融合，并提供多种场景的解决方案。</p>
<p>在线体验①：<a href="https://www.appmiu.com/go/c88m">https://huggingface.co/spaces/lllyasviel/IC-Light</a><br>在线体验②：<a href="https://www.appmiu.com/go/nu5e">https://colab.research.google.com/drive/1-pXSpTH-zNhaAKFmMvh-xj7Zp9781L2f?usp=sharing</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="沉浸式线性代数-immersivemath"><a href="#沉浸式线性代数-immersivemath" class="headerlink" title="沉浸式线性代数 immersivemath"></a>沉浸式线性代数 immersivemath</h2><p>《<a href="https://immersivemath.com/ila/learnmore.html?utm_source=pocket_saves">immersivemath: Immersive Linear Algebra</a>》是一本旨在通过沉浸式学习体验教授线性代数的书籍。它涵盖了从基础的向量操作到更高级的数学概念，如点积、向量积和高斯消元法等。通过这本书，读者可以系统地学习和理解线性代数的各个方面。</p>
<p><a href="https://immersivemath.com/ila/ch01_introduction/ch01.html">Chapter 1: Introduction 第 1 章：简介</a></p>
<p>How to navigate, notation, and a recap of some math that we think you already know.<br>如何导航、符号以及一些我们认为你已经知道的数学知识的回顾。</p>
<p><a href="https://immersivemath.com/ila/ch02_vectors/ch02.html">Chapter 2: Vectors 第 2 章：向量</a></p>
<p>The concept of a vector is introduced, and we learn how to add and subtract vectors, and more.<br>介绍向量的概念，学习向量的加减法等。</p>
<p><a href="https://immersivemath.com/ila/ch03_dotproduct/ch03.html">Chapter 3: The Dot Product 第 3 章：点积</a></p>
<p>A powerful tool that takes two vectors and produces a scalar.<br>一个强大的工具，它能将两个向量相加并产生一个标量。</p>
<p><a href="https://immersivemath.com/ila/ch04_vectorproduct/ch04.html">Chapter 4: The Vector Product 第 4 章：矢量积</a></p>
<p>In three-dimensional spaces you can produce a vector from two other vectors using this tool.<br>在三维空间中，你可以用这个工具从另外两个向量生成一个向量。</p>
<p><a href="https://immersivemath.com/ila/ch05_gausselim/ch05.html">Chapter 5: Gaussian Elimination 第 5 章：高斯消元</a></p>
<p>A way to solve systems of linear equations.<br>求解线性方程组的一种方法。</p>
<p><a href="https://immersivemath.com/ila/ch06_matrices/ch06.html">Chapter 6: The Matrix 第 6 章：矩阵</a></p>
<p>Enter the matrix. 输入矩阵。</p>
<p><a href="https://immersivemath.com/ila/ch07_determinants/ch07.html">Chapter 7: Determinants 第 7 章：行列式</a></p>
<p>A fundamental property of square matrices.<br>方阵的基本性质。</p>
<p><a href="https://immersivemath.com/ila/ch08_rank/ch08.html">Chapter 8: Rank 第8章：秩</a></p>
<p>Discover the behaviour of matrices.<br>探索矩阵的行为。</p>
<p><a href="https://immersivemath.com/ila/ch09_linear_mappings/ch09.html">Chapter 9: Linear Mappings 第 9 章：线性映射</a></p>
<p>Learn to harness the power of linearity…<br>学习利用线性的力量…</p>
<p><a href="https://immersivemath.com/ila/ch10_eigen/ch10.html">Chapter 10: Eigenvalues and Eigenvectors 第10章：特征值和特征向量</a></p>
<p>This chapter has a value in itself.<br>这一章本身就很有价值。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405222257140.png"></p>
<p>在线地址： <a href="https://immersivemath.com/ila/index.html">https://immersivemath.com/ila/index.html</a></p>
<br />

 

<h2 id="流畅阅读：浏览器翻译插件"><a href="#流畅阅读：浏览器翻译插件" class="headerlink" title="流畅阅读：浏览器翻译插件"></a>流畅阅读：浏览器翻译插件</h2><p>流畅阅读是一款高效的浏览器翻译插件，可以将网页上的文字翻译成任何语言，方便、快捷、直观，支持人工智能引擎。 </p>
<p>流畅阅读支持「仅译文模式」和「双语模式」，为所有人提供可选的翻译模式。</p>
<p><a href="https://github.com/Bistutu/FluentRead/blob/main/misc/sample-git-1.gif"><img data-src="https://github.com/Bistutu/FluentRead/raw/main/misc/sample-git-1.gif" alt="sample-git-1.gif" style="zoom:67%;" /></a></p>
<p><a href="https://github.com/Bistutu/FluentRead/blob/main/misc/sample-git-4.gif"><img data-src="https://github.com/Bistutu/FluentRead/raw/main/misc/sample-git-4.gif" alt="sample-git-4.gif" style="zoom:67%;" /></a></p>
<p><a href="https://github.com/Bistutu/FluentRead/blob/main/misc/screenshot-3.png"><img data-src="https://github.com/Bistutu/FluentRead/raw/main/misc/screenshot-3.png" alt="sample-git-1.gif" style="zoom:67%;" /></a></p>
<p>安装指南：</p>
<blockquote>
<p>插件已经上架各大浏览器的应用商店，可以点击下方链接进行安装：</p>
</blockquote>
<ul>
<li><strong>Chrome 浏览器</strong>：<a href="https://chromewebstore.google.com/detail/%E6%B5%81%E7%95%85%E9%98%85%E8%AF%BB/djnlaiohfaaifbibleebjggkghlmcpcj?hl=zh-CN&authuser=0">点击安装</a>、<a href="https://www.crxsoso.com/webstore/detail/djnlaiohfaaifbibleebjggkghlmcpcj">备用链接</a></li>
<li><strong>Edge 浏览器</strong>：<a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B5%81%E7%95%85%E9%98%85%E8%AF%BB/kakgmllfpjldjhcnkghpplmlbnmcoflp?hl=zh-CN">点击安装</a></li>
<li><strong>Firefox（火狐）浏览器</strong>：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/%E6%B5%81%E7%95%85%E9%98%85%E8%AF%BB/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search">点击安装</a></li>
<li><strong>其他浏览器，尝试</strong>：<a href="https://www.crxsoso.com/webstore/detail/djnlaiohfaaifbibleebjggkghlmcpcj">点击安装</a></li>
</ul>
<p>开源地址：<a href="https://github.com/Bistutu/FluentRead">https://github.com/Bistutu/FluentRead</a></p>
<br />

<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于    <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第45期</title>
    <url>/posts/53592.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如最懂程序员的新一代 AI 搜索引擎 Devv、文本生成语音模型 ChatTTS 及其 UI 项目、视频翻译配音工具 PYVIDEOTRANS。此外，还介绍了美图开源任务队列 LMSTFY 和动手学深度学习资源。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406052246720.jpg" alt="https://www.pexels.com/zh-cn/photo/348706/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第45期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://juejin.cn/post/7316202809383321609">这是你们项目中WebView的样子吗？</a>：文章探讨了项目中WebView的使用规范和功能，包括可监控性、与前端的交互、安全问题以及WebView的封装思路。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/XMWbBcGUbGh61Vv8-Lz8NA">盘点 Google I&#x2F;O 2024 的 Android 领域关键进展 </a>:  </p>
<p>文章的主要内容和进展包括：</p>
<ul>
<li><strong>AI编程助手</strong>：Gemini正式纳入产品家族，帮助提高代码质量和开发效率。</li>
<li><strong>生成式AI应用</strong>：提供云端和设备端的大模型能力，助力开发新型应用。</li>
<li><strong>不同屏幕尺寸适配</strong>：通过Compose自适应布局API，简化多设备适配。</li>
<li><strong>桌面小部件</strong>：Jetpack Glance框架更新，提供新设计规范和UI组件库。</li>
<li><strong>跨设备类型开发</strong>：Jetpack Compose更新，支持更广泛的Android设备生态系统。</li>
<li><strong>WearOS &amp; 可穿戴</strong>：Wear OS 5预览版发布，带来电池续航和表盘格式改进。</li>
<li><strong>Android for Car</strong>：Android Auto和Android Automotive OS进展，推动车机系统智能化。</li>
<li><strong>Android TV</strong>：Android TV OS增长迅速，推出Android 14 for TV和Compose for TV。</li>
<li><strong>Google Home API</strong>：基于Matter，简化家用产品开发，提供更丰富的家庭自动化体验。</li>
<li><strong>Kotlin Multiplatform</strong>：Jetpack库迁移到KMP，推荐开发者共享跨平台业务逻辑。</li>
<li><strong>Jetpack Compose</strong>：宣布新版本更新，增强跨设备适配和UI组件。</li>
<li><strong>Android Studio</strong>：发布新版本，引入Gemini功能和UI自动化测试插件。</li>
<li><strong>Google Play</strong>：分享最新进展，帮助开发者打造高质量用户体验和优化收入。</li>
<li><strong>Checks</strong>：提供应用隐私合规检查服务，帮助遵守隐私法规。</li>
<li><strong>Android 15</strong>：发布第二个测试版，注重提高生产效率、电池性能和应用流畅性。</li>
</ul>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/VjcU3s6YcyR5jr3tndov2g">Android vold (卷管理) 传记 </a>: 文章以自述和对话的方式详细介绍了Android系统中vold的作用、如何监听外部存储设备的热插拔事件、管理卷的方式以及为应用创建目录的能力。</p>
<p>文章的主要内容和要点包括：</p>
<ul>
<li><strong>vold简介</strong>：vold是volume daemon的缩写，负责管理所有卷，包括加密解密CE和DE类型的目录，以及对存储设备或卷进行挂载、卸载、格式化等操作。</li>
<li><strong>vold的作用</strong>：为app提供存储服务，管理卷信息，并与StorageManagerService通信，使应用能够访问外部存储。</li>
<li><strong>卷管理</strong>：介绍了vold如何收集和管理外部存储设备卷和虚拟卷，以及如何通过NetlinkManager和VolumeManager类来处理uevent事件。</li>
<li><strong>挂载userdata分区</strong>：解释了vold如何挂载userdata分区到&#x2F;data目录，以及fstab文件的作用。</li>
<li><strong>解密CE和DE类型目录</strong>：简要提及了vold如何解密这些目录，具体内容在其他文章中介绍。</li>
<li><strong>为app创建data和obb目录</strong>：vold利用其root权限为应用在外部存储下创建具有正确权限的data和obb目录。</li>
</ul>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="最懂程序员的新一代-AI-搜索引擎"><a href="#最懂程序员的新一代-AI-搜索引擎" class="headerlink" title="最懂程序员的新一代 AI 搜索引擎"></a>最懂程序员的新一代 AI 搜索引擎</h2><p>Devv 支持直接连接 GitHub 仓库，进行搜索、提问、生成代码 , 非常适合程序员。  </p>
<p>快速模式:基于 Devv 构建的 AI 搜索引擎，快速获取编程问题的答案、文档以及代码片段。</p>
<p>Agent 模式：为复杂的开发问题提供 Agent 驱动的解决方案，涵盖问题搜索、代码生成、Debug 等场景。</p>
<p>GitHub 模式：连接指定的公开或私有 GitHub 仓库，实现针对特定代码库的搜索、问答以及代码生成。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406032333551.png"></p>
<p>地址：<a href="https://devv.ai/">https://devv.ai/</a></p>
<h2 id="ChatTTS：文本生成语音"><a href="#ChatTTS：文本生成语音" class="headerlink" title="ChatTTS：文本生成语音"></a>ChatTTS：文本生成语音</h2><p>ChatTTS 是专为 LLM 助手等对话场景设计的文本到语音模型。它支持中英文两种语言。我们的模型经过 100,000+ 小时的中英文训练。HuggingFace 上的开源版本是不含 SFT 的 40,000 小时预训练模型。</p>
<p><strong>亮点</strong></p>
<ol>
<li><strong>对话式 TTS</strong>: ChatTTS针对对话式任务进行了优化，实现了自然流畅的语音合成，同时支持多说话人。</li>
<li><strong>细粒度控制</strong>: 该模型能够预测和控制细粒度的韵律特征，包括笑声、停顿和插入词等。</li>
<li><strong>更好的韵律</strong>: ChatTTS在韵律方面超越了大部分开源TTS模型。同时提供预训练模型，支持进一步的研究。</li>
</ol>
<p>对于模型的具体介绍, 可以参考B站的 <strong><a href="https://www.bilibili.com/video/BV1zn4y1o7iV">宣传视频</a></strong></p>
<p>开源地址：<a href="https://github.com/2noise/chattts?tab=readme-ov-file">https://github.com/2noise/chattts</a></p>
<p>官网：<a href="https://2noise.com/">https://2noise.com/</a></p>
<h2 id="ChatTTS-ui"><a href="#ChatTTS-ui" class="headerlink" title="ChatTTS-ui"></a>ChatTTS-ui</h2><p><code>ChatTTS-ui</code> 是一个开源项目，主要用于文本到语音转换（Text-to-Speech, TTS）。该项目的主要功能是将输入的文本转换为语音输出，可能用于各种需要语音合成功能的应用场景，如聊天机器人、语音助手等。<br>提供了网页中使用 ChatTTS 合成语音及 API 接口服务，支持 Windows、Linux、macOS 部署。其中 Windows 用户可直接下载安装包，一键安装开箱即用。</p>
<p>从项目的名称和文件结构来看，<code>ChatTTS-ui</code> 提供了一个用户界面（UI），使用户可以方便地输入文本并获得语音输出。项目的核心功能可能包括文本处理、语音合成以及用户界面的设计和实现。</p>
<p>主要功能</p>
<ol>
<li><strong>文本到语音转换</strong>：将输入的文本转换为语音输出。</li>
<li><strong>用户界面</strong>：提供一个直观的界面，用户可以在其中输入文本并播放生成的语音。</li>
<li><strong>开源社区支持</strong>：项目在 GitHub 上开源，用户和开发者可以贡献代码、报告问题和提出改进建议。</li>
</ol>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406042259781.png"></p>
<p>开源地址：<a href="https://github.com/jianchang512/ChatTTS-ui">https://github.com/jianchang512/ChatTTS-ui</a></p>
<h2 id="pyVideoTrans视频翻译配音"><a href="#pyVideoTrans视频翻译配音" class="headerlink" title="pyVideoTrans视频翻译配音"></a>pyVideoTrans视频翻译配音</h2><p>一键实现语音识别-&gt;字幕翻译-&gt;配音 &#x3D; 带字幕和配音的新视频。</p>
<p>特性：</p>
<p>💥自动视频翻译</p>
<p>集成faster-whisper模型&#x2F;并支持自定义huggingface模型<br>同时集成批量语音转字幕、批量字幕翻译、批量配音小工具</p>
<p>🤠多种配音和翻译渠道</p>
<p>配音:edgeTTS|AzureTTS|OpenAiTTS|Elevenlabs|clone-voice|GPT-SoVITS<br>翻译:Google|ChatGPT|DeepL|Gemini|Mircosoft|百度|腾讯|本地模型</p>
<p>🤖可完全离线</p>
<p>翻译渠道替换为本地模型,配音渠道替换为clone-voice,即可实现完全本地离线视频翻译</p>
<p>🚀免费+开源</p>
<p>代码GitHub公开可审查，免费无功能限制，无隐藏收费<br>开源协议GPL-v3</p>
<p>官网：<a href="https://pyvideotrans.com/">https://pyvideotrans.com/</a></p>
<p>下载地址：<a href="https://pyvideotrans.com/downpackage.html">https://pyvideotrans.com/downpackage.html</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="美图开源任务队列-lmstfy"><a href="#美图开源任务队列-lmstfy" class="headerlink" title="美图开源任务队列 lmstfy"></a>美图开源任务队列 lmstfy</h2><p> 具有 REST API 的任务队列 基于 redis 存储，使用 golang 开发，资源占用少，轻量级，并且经受美图线上环境大流量验证多年，较适合用来做延迟队列。</p>
<p><img data-src="https://raw.githubusercontent.com/bitleak/lmstfy/master/doc/lmstfy-internal.png"></p>
<p>开源地址：<a href="https://github.com/bitleak/lmstfy">https://github.com/bitleak/lmstfy</a></p>
<h2 id="动手学深度学习"><a href="#动手学深度学习" class="headerlink" title="动手学深度学习"></a>动手学深度学习</h2><p>《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被70多个国家的500多所大学用于教学。</p>
<p>特性：</p>
<ol>
<li><p>所有人均可在网上免费获取；</p>
</li>
<li><p>提供足够的技术深度，从而帮助读者实际成为深度学习应用科学家：既理解数学原理，又能够实现并不断改进方法；</p>
</li>
<li><p>包含可运行的代码，为读者展示如何在实际中解决问题。这样不仅直接将数学公式对应成实际代码，而且可以修改代码、观察结果并及时获取经验；</p>
</li>
<li><p>允许我们和整个社区不断快速迭代内容，从而紧跟仍在高速发展的深度学习领域；</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406042315100.png"></p>
</li>
</ol>
<p>开源地址：<a href="https://github.com/d2l-ai/d2l-zh">https://github.com/d2l-ai/d2l-zh</a></p>
<p>在线网站：<a href="http://zh.d2l.ai/">http://zh.d2l.ai/</a></p>
<br />

 

<h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><ul>
<li><a href="https://www.36kr.com/p/2806457318700419">ChatGPT遭遇近8小时大规模宕机 </a></li>
<li><a href="https://www.ithome.com/0/772/968.htm">快手推出团购配送到家服务</a></li>
<li><a href="https://www.sohu.com/a/783674113_239259">微信推出锁屏录音功能</a></li>
<li><a href="https://www.ithome.com/0/773/039.htm">高铁新增“优选一等座”票价介于商务座和一等座之间</a></li>
<li><a href="https://36kr.com/newsflashes/2805335795381632">途牛2024年一季度净收入同比增71%</a></li>
</ul>
<br />

<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于 <a href="https://www.lifeee.top/posts/22872.html">https://www.lifeee.top/posts/22872.html</a>  </p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第47期</title>
    <url>/posts/26969.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如基于FunASR高准确率语音识别模型的智能视频剪辑工具、潮点AI工具导航网站、AI Girlfriends。此外，还介绍了影猫推荐、相似网站搜索   <a href="https://www.similarsites.com/">Similarsites</a>、食用手册。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406152226878.jpg" alt="https://pixabay.com/photos/lugu-lake-boat-lake-blue-horizon-8679121/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第47期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://gityuan.com/2019/09/07/flutter_run/?utm_source=pocket_shared">源码解读Flutter run机制 - Gityuan博客 | 袁辉辉的技术博客</a>： 文章详细介绍了Flutter run命令的使用方法和背后的机制。首先，它解释了如何通过IDE或命令行运行Flutter应用，并区分了debug、profile和release模式。接着，文章详细解读了flutter run命令的参数，包括如何指定目标平台、输出目录、是否启用服务鉴权等。此外，文章还探讨了如何使用gradle构建APK，并通过adb命令安装和启动应用。最后，文章通过源码分析，揭示了Flutter run命令在Android和iOS设备上的具体实现细节，包括前端编译、AOT编译、构建bundle等关键步骤。</p>
</li>
<li><p><a href="https://juejin.cn/post/7381767811679502346">Flutter局部刷新三剑客</a>： 文章介绍了Flutter中实现局部刷新的三个工具：ChangeNotifier、ValueNotifier和ValueListenableBuilder，帮助开发者提高页面性能。</p>
</li>
<li><p><a href="http://w4lle.com/2021/01/15/flutter-ui-layout/?utm_source=pocket_shared">Flutter UI 渲染浅析（五）Layout | w4lle’s Notes</a>： 深入探讨了Render Tree的构建以及Layout阶段。</p>
<p>作者首先回顾了<code>RenderObject</code>的角色和重要性，它是Render Tree的构成节点，负责布局和绘制。文章解释了并非所有Element都持有RenderObject的引用，只有特定的<code>RenderObjectWidget</code>及其对应的<code>RenderObjectElement</code>会创建RenderObject。</p>
<p>文章提到<code>RenderObject</code>继承自<code>AbstractNode</code>，这使得它成为树状结构的一部分，并具备了节点的基本操作。<code>RenderObject</code>还混入了<code>HitTestTarget</code>，用以提供事件处理能力。作者还指出<code>RenderObject</code>定义了通用的布局和绘制协议，但没有具体定义坐标系统或布局协议的细节。</p>
<p>最后，文章提到了<code>Layer</code>，它也是<code>AbstractNode</code>的子类，将在下一篇文章中分析。整体而言，文章为读者提供了对Flutter框架中UI渲染流程的深入理解，特别是Render Tree的构建和布局机制。</p>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="基于FunASR高准确率语音识别模型的智能视频剪辑工具"><a href="#基于FunASR高准确率语音识别模型的智能视频剪辑工具" class="headerlink" title="基于FunASR高准确率语音识别模型的智能视频剪辑工具"></a>基于FunASR高准确率语音识别模型的智能视频剪辑工具</h2><p>FunClip 是一款自动化视频剪辑工具，通过调用阿里巴巴通义实验室开源的FunASR Paraformer系列模型进行视频的语音识别，随后用户可以自由选择识别结果中的片段，点击裁剪按钮即可获取对应片段的视频（快速体验）。</p>
<p>在上述基本功能的基础上，FunClip有以下特色：</p>
<p>FunClip集成了阿里巴巴开源的工业级模型Paraformer-Large，是当前识别效果最优的开源中文ASR模型之一，Modelscope下载量1300w+次，并且能够一体化的准确预测时间戳。</p>
<p>FunClip集成了SeACo-Paraformer的热词定制化功能，在ASR过程中可以指定一些实体词、人名等作为热词，提升识别效果。</p>
<p>FunClip集成了CAM++说话人识别模型，用户可以将自动识别出的说话人ID作为裁剪目标，将某一说话人的段落裁剪出来。</p>
<p>通过Gradio交互实现上述功能，安装简单使用方便，并且可以在服务端搭建服务通过浏览器使用。</p>
<p>FunClip支持多段自由剪辑，并且会自动返回全视频SRT字幕、目标段落SRT字幕，使用简单方便。</p>
<p>安装及使用方法可以查看： 使用FunClip进行视频剪辑</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202403282310265.png"></p>
<p>开源地址：<a href="https://github.com/alibaba-damo-academy/FunClip">https://github.com/alibaba-damo-academy/FunClip</a></p>
<br />

<h2 id="又一个AI导航网站：潮点AI工具导航网站"><a href="#又一个AI导航网站：潮点AI工具导航网站" class="headerlink" title="又一个AI导航网站：潮点AI工具导航网站"></a>又一个AI导航网站：潮点AI工具导航网站</h2><p><a href="https://aichaodian.com/">潮点AI工具导航网站</a>提供了一个广泛的AI工具和资源目录，覆盖了从AI对话互动、图像处理、视频工具、音频工具、设计工具、写作工具到办公工具等多个领域。此外，还包括了语言翻译、内容检测、提示指令、训练模型、学习网站、开发框架、编程工具等类别的链接。网站旨在帮助用户快速找到所需的AI服务和资源，无论是专业人士还是对AI感兴趣的学习者。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182334088.png"></p>
<p>在线地址：<a href="https://aichaodian.com/">https://aichaodian.com/</a></p>
<br />

<h2 id="AI-Girlfriends"><a href="#AI-Girlfriends" class="headerlink" title="AI Girlfriends"></a>AI Girlfriends</h2><p><a href="https://aigirlfriends.ai/">AI Girlfriends</a> 是一个创新的虚拟伴侣平台，它通过结合尖端技术和现实世界的影响力，为用户提供沉浸式的AI聊天机器人伴侣体验。该平台与知名影响者合作，无论是寻求虚拟伴侣关系、数字友谊还是AI关系，这里都是理想的目的地。关键特点包括无缝对话、具有重要记忆功能的AI、独家图片以及语音文本功能，这些功能共同创造了一个超越文字的视觉和洞察力盛宴，提供了一个更加沉浸和吸引人的体验。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182338611.png"></p>
<p>在线地址：<a href="https://aigirlfriends.ai/">https://aigirlfriends.ai/</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="影猫推荐"><a href="#影猫推荐" class="headerlink" title="影猫推荐"></a>影猫推荐</h2><p><a href="">影猫推荐</a>（MVCAT）是一个多功能的影视推荐平台，提供包括每日推荐、热门作品、标签分类、日历、地图、海报、必看作品、人物解说等多种影视相关内容。电影分类很详细，还有随机推荐的电影。</p>
<p>网站还设有书屋和好物推荐栏目，以及背景音乐服务。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182328165.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182329331.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182329915.png"></p>
<p>地址： <a href="https://www.mvcat.com/">https://www.mvcat.com/</a> </p>
<br />

<h2 id="相似网站搜索-Similarsites"><a href="#相似网站搜索-Similarsites" class="headerlink" title="相似网站搜索   Similarsites"></a>相似网站搜索   <a href="https://www.similarsites.com/">Similarsites</a></h2><p><a href="https://www.similarsites.com/">SimilarSites</a> 是一个在线工具，它允许用户通过浏览器扩展发现与他们喜爱的网站类似的其他网站。SimilarSites 也提供了一个浏览器扩展，用户可以通过它来探索与他们当前访问的网站类似的其他网站。这个工具对于寻找特定主题或类型的替代网站非常有用。用户可以免费下载这个扩展，它支持即时查找类似网站，并且已经获得了一些用户的积极评价，他们认为这个扩展易于使用且功能强大。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182340422.png"></p>
<p>在线网站： <a href="https://www.similarsites.com/">https://www.similarsites.com/</a></p>
<br />

<h2 id="食用手册-菜谱指南"><a href="#食用手册-菜谱指南" class="headerlink" title="食用手册: 菜谱指南"></a>食用手册: 菜谱指南</h2><p><a href="https://cook.yunyoujun.cn/">食用手册</a>提供了一个简单直观的界面，使用户可以通过选择各种食材和厨具来探索可能的菜谱组合。网站列出了多种蔬菜、肉类、主食选项以及不同类型的厨具，如烤箱、空气炸锅、微波炉和多功能锅。用户的选择将决定他们可以看到的菜谱，从而帮助他们创新自己的烹饪方式或找到新的烹饪灵感。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182347770.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406182348650.png"></p>
<p>在线网站：<a href="https://cook.yunyoujun.cn/">https://cook.yunyoujun.cn/</a></p>
<br />

<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于  <a href="https://www.lifeee.top/posts/53592.html">https://www.lifeee.top/posts/53592.html</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第49期</title>
    <url>/posts/33115.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如可视化神经网络 Netron 、用于 Web 的表情符号选择器 HTML 组件、Notion 简体中文版帮助文档、 ZeroTermux  Android 终端。此外，还介绍了、全历史、大厂项目复盘。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407072325290.png" alt="image-20240707232504020"></p>
<span id="more"></span>



<br />

<p>欢迎来到第49期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="可视化神经网络-Netron"><a href="#可视化神经网络-Netron" class="headerlink" title="可视化神经网络 Netron"></a>可视化神经网络 Netron</h2><p><strong>🌐 Netron 简介</strong> Netron 是一款可视化神经网络、深度学习和机器学习模型的工具。它支持多种模型格式，包括ONNX、TensorFlow的SavedModel、Keras、Core ML、PyTorch的TorchScript等。用户可以通过Netron来检查模型的层、权重和激活，以及进行模型的调试和优化。</p>
<ul>
<li><strong>💻 Netron 功能特性</strong>：<ul>
<li>查看模型结构和参数</li>
<li>探索模型层级</li>
<li>分析模型权重和激活值</li>
<li>导出模型为其他格式</li>
<li>将模型部署到其他平台</li>
</ul>
</li>
<li><strong>📥 Netron 下载</strong> Netron 提供 Windows、macOS 和 Linux 版本。您可以从以下链接下载：<ul>
<li>官方网站：<a href="https://netron.app/">https://netron.app/</a></li>
<li>GitHub 仓库：<a href="https://github.com/lutzroeder/netron/releases">https://github.com/lutzroeder/netron/releases</a></li>
</ul>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202405062314931.png" alt="image-20240506231425657"></p>
<p>开源地址：<a href="https://github.com/lutzroeder/netron">https://github.com/lutzroeder/netron</a></p>
<h2 id="用于-Web-的表情符号选择器-HTML-组件"><a href="#用于-Web-的表情符号选择器-HTML-组件" class="headerlink" title="用于 Web 的表情符号选择器 HTML 组件"></a>用于 Web 的表情符号选择器 HTML 组件</h2><p>EmojiMart 是一款可定制的网页端表情符号选择器组件。它提供以下功能：</p>
<ul>
<li><p>搜索表情符号</p>
</li>
<li><p>指定要使用的表情符号集</p>
</li>
<li><p>使用自定义表情符号</p>
</li>
<li><p>支持多种语言</p>
</li>
</ul>
<p>EmojiMart 可以轻松集成到 React 应用程序中，并提供多种自定义选项，使其成为开发人员和设计师的理想选择。</p>
<p>以下是 EmojiMart 的一些主要功能：</p>
<ul>
<li><strong>丰富的表情符号选择:</strong> EmojiMart 提供了大量的表情符号，涵盖各种类别，例如动物、食物、人物、活动等。</li>
<li><strong>强大的搜索功能:</strong> 用户可以使用关键字或表情符号本身来搜索所需的符号。</li>
<li><strong>可定制的皮肤:</strong> EmojiMart 提供多种皮肤供用户选择，以匹配他们的应用程序或网站的主题。</li>
<li><strong>支持多种语言:</strong> EmojiMart 支持多种语言，包括英语、法语、西班牙语、德语、中文等。</li>
</ul>
<p>如果您正在寻找一款功能强大且易于使用的表情符号选择器组件，那么 EmojiMart 是一个不错的选择。</p>
<p><img data-src="https://user-images.githubusercontent.com/436043/163686169-766ef715-89b5-4ada-88d7-672623713bc0.png"></p>
<p>开源地址：<a href="https://github.com/missive/emoji-mart">https://github.com/missive/emoji-mart</a></p>
<h2 id="Notion-简体中文版帮助文档"><a href="#Notion-简体中文版帮助文档" class="headerlink" title="Notion 简体中文版帮助文档"></a>Notion 简体中文版帮助文档</h2><ul>
<li>Notion是一个一体化的工作空间，用于笔记、任务、维基和数据库管理。</li>
<li>该页面由theBlock团队提供中文翻译，目的是帮助中文用户更好地使用Notion，提高工作效率和生活品质。</li>
<li>由于官方中文版可能尚未推出，这个翻译项目旨在填补这一空缺。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202406062127252.png"></p>
<p>在线地址：<a href="https://craigary.notion.site/d6faf79a18254f289f6e0d3c271c3e92?v=cdad32cc321643fba10c67a3f4851334">https://craigary.notion.site/d6faf79a18254f289f6e0d3c271c3e92?v=cdad32cc321643fba10c67a3f4851334</a></p>
<h2 id="ZeroTermux-：-Android-终端"><a href="#ZeroTermux-：-Android-终端" class="headerlink" title="ZeroTermux ： Android 终端"></a><strong><a href="https://github.com/hanxinhao000/ZeroTermux">ZeroTermux</a></strong> ： Android 终端</h2><p><a href="https://github.com/hanxinhao000/ZeroTermux">ZeroTermux</a>项目是指一个与Android设备上的终端仿真器（Termux）相关的项目。Termux是一个流行的Android应用程序，它提供了一个丰富的命令行环境，允许用户在Android设备上执行Linux命令和脚本。</p>
<blockquote>
<p>ZeroTermux基于Termux进行修改，内置一键切换apt&#x2F;pkg软件源、一键备份恢复等多种便捷功能</p>
</blockquote>
<table>
<thead>
<tr>
<th><img data-src="https://raw.githubusercontent.com/hanxinhao000/ZeroTermux/main/img/Screenshot_20210701-120322.jpg"></th>
<th><img data-src="https://raw.githubusercontent.com/hanxinhao000/ZeroTermux/main/img/Screenshot_20210620-091454.jpg"></th>
</tr>
</thead>
</table>
<p>开源地址：<a href="https://github.com/hanxinhao000/ZeroTermux">https://github.com/hanxinhao000/ZeroTermux</a></p>
<p>下载地址：<a href="https://od.ixcmstudio.cn/repository/main/ZeroTermux/">https://od.ixcmstudio.cn/repository/main/ZeroTermux/</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="设计导航"><a href="#设计导航" class="headerlink" title="设计导航"></a>设计导航</h2><p>设计导航网站精心挑选并分类整理了一系列设计相关的网站链接，旨在为设计师和创意工作者提供便捷的资源访问。网站内容包括但不限于常用搜索引擎、图片资源、设计素材、音乐、影视、购物、旅游、社区和实用工具等多个分类。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407022320439.png"></p>
<p>在线地址：<a href="https://hao.shejidaren.com/index.html">https://hao.shejidaren.com/index.html</a></p>
<h2 id="全历史"><a href="#全历史" class="headerlink" title="全历史"></a>全历史</h2><p>全历史网站是一个集历史知识学习、研究和探索于一体的平台，通过AI技术为用户提供了一个丰富、互动性强的历史知识学习环境。无论是历史爱好者还是教育工作者，都能从中获得宝贵的知识和灵感。通过全历史网站，用户可以更深入地了解历史，拓宽知识视野。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407022326002.png"></p>
<p>在线地址：<a href="https://static.allhistory.com/">https://static.allhistory.com/</a></p>
<h2 id="大厂项目复盘"><a href="#大厂项目复盘" class="headerlink" title="大厂项目复盘"></a>大厂项目复盘</h2><p>文章提供了阿里巴巴集团在不同业务领域的产品设计和营销策略的深入复盘。内容涉及淘宝、盒马、饿了么、钉钉等品牌的项目案例，展示了如何通过设计提升用户体验、引导用户行为、打造有温度的营销活动以及探索未来工作的新方式。每个案例都揭示了背后的设计理念、创新点和取得的成效。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407022330230.png"></p>
<p>在线地址：<a href="https://www.yuque.com/wikidesign/ykf0s9">https://www.yuque.com/wikidesign/ykf0s9</a></p>
<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于 <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第51期</title>
    <url>/posts/49675.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如Rodel Downloader AI模型下载工具、Apache Superset 数据可视化平台 、Ladybird - 一个真正独立的Web浏览器。此外，还介绍了在VSCode里离线使用语雀编辑器 以及优化React性能的一个虚拟DOM。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407172208096.jpg" alt="https://www.pexels.com/zh-cn/photo/19074550/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第51期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/zBfvjq3gry2zsMoMir6oZA">看见 Java </a>： 文章介绍了作者在学习Java原理时的一些体会和工具使用技巧，目的是帮助读者更深入地理解Java语言的底层实现。作者分享了以下几个工具和方法：</p>
<ol>
<li><strong>javap</strong>：使用<code>javap</code>命令查看Java字节码，通过IDEA插件<code>jclasslib</code>分析字节码。</li>
<li><strong>strace</strong>：使用<code>strace</code>命令查看程序运行过程中的系统调用，以理解Java BIO&#x2F;NIO的底层原理。</li>
<li><strong>hsdis+jitwatch</strong>：结合使用<code>hsdis</code>和<code>jitwatch</code>工具查看Java代码对应的机器码（汇编）。</li>
<li><strong>openJDK</strong>：通过阅读OpenJDK源码了解Java native方法的底层实现。</li>
<li><strong>JOL（Java Object Layout）</strong>：使用JOL工具查看Java对象在内存中的布局。</li>
<li><strong>fastthread</strong>：使用<code>fastthread</code>工具将JVM线程快照可视化。</li>
<li><strong>JProfile</strong>：使用<code>JProfile</code>工具监控JVM运行时状态，分析性能瓶颈。</li>
</ol>
<p>文章强调了通过这些工具进行实践的重要性，认为这可以帮助读者获得比阅读博客或书籍更深入的理解。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">你管这破玩意叫 IO 多路复用？  </a>： 文章首先介绍了传统的阻塞IO模型，并指出其在处理并发连接时的弊端。为了解决阻塞问题，提出了非阻塞IO的概念，并通过多线程的方式进行改进。然而，这种方式并没有真正解决IO阻塞的问题，只是通过多线程让主线程不阻塞。</p>
<p>接着，文章详细解释了IO多路复用的几种技术：select、poll和epoll。select是最早的多路复用技术，它可以监控多个文件描述符的读写状态，但存在一些限制和性能问题。poll在select的基础上改进，去除了文件描述符数量的限制。而epoll则是最终的解决方案，它通过更高效的内核机制，解决了select和poll的不足。</p>
<p>文章还通过伪代码和流程图，详细解释了这些技术的具体实现和工作原理。最后，作者强调了IO多路复用技术的重要性，并指出这些技术的发展是操作系统不断适应高并发需求的结果。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/GlUNe7cZy0_VAatJMD7UgQ">害，毕业三年了！ </a>： 文章是一位大学毕业生回顾自己三年大学生活的心路历程，分享了从大一开始的课外活动、技术学习，到大四求职和职业规划的经验和感悟。文章最后，作者给出了几点建议，包括确定方向、自学、逃课策略、恋爱观、健康管理、绩点看法和保持非功利性态度。作者强调，尽管学校一般，但通过积极行动和少抱怨，也能取得职业上的成功。</p>
</li>
</ul>
<h2 id="Spring-源码阅读"><a href="#Spring-源码阅读" class="headerlink" title="Spring 源码阅读"></a>Spring 源码阅读</h2><p>涵盖了 Spring 框架的核心概念和关键功能，包括控制反转（IOC）容器的使用，面向切面编程（AOP）的原理与实践，事务管理的方式与实现，Spring MVC 的流程与控制器工作机制，以及 Spring 中数据访问、安全、Boot 自动配置等方面的深入研究。此外，它还包含了 Spring 事件机制的应用、高级主题如缓存抽象和响应式编程，以及对 Spring 源码的编程风格与设计模式的深入探讨。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407142253607.png"></p>
<p>开源地址：<a href="https://github.com/xuchengsheng/spring-reading">https://github.com/xuchengsheng/spring-reading</a></p>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="Rodel-Downloader-AI模型下载工具"><a href="#Rodel-Downloader-AI模型下载工具" class="headerlink" title="Rodel Downloader AI模型下载工具"></a>Rodel Downloader AI模型下载工具</h2><p><a href="">Rodel Downloader</a>是一个windows 平台的AI模型下载工具，旨在帮助用户稳定可靠地从 <a href="https://huggingface.co/">Hugging Face</a>，<a href="https://www.modelscope.cn/">Model Scope</a> 和 <a href="https://civitai.com/">Civitai</a> 等网站稳定且可靠地下载AI模型文件。该工具提供了命令行界面（CLI）和图形用户界面（APP）两种使用模式，以满足不同用户的需求。</p>
<p><strong>主要特性包括：</strong></p>
<ul>
<li><p>支持命令行和图形用户界面。</p>
</li>
<li><p>内置Aria2下载管理器，支持断点续传、下载进度显示和多文件下载。</p>
</li>
<li><p>支持自定义下载目录和选择性下载文件。</p>
</li>
<li><p>提供了简单的本地化支持（英语和简体中文）。</p>
</li>
<li><p>需要Windows 10 19041及以上版本支持图形用户界面。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407172146983.png"></p>
</li>
</ul>
<p>开源地址：<a href="https://github.com/Richasy/Rodel.Downloader">https://github.com/Richasy/Rodel.Downloader</a></p>
<h2 id="Apache-Superset-数据可视化平台"><a href="#Apache-Superset-数据可视化平台" class="headerlink" title="Apache Superset 数据可视化平台"></a>Apache Superset 数据可视化平台</h2><p>Apache Superset  是一个数据可视化和数据探索平台，具有快速构建图表、强大的SQL编辑器、语义层、支持多种数据库、丰富的可视化效果、缓存层、可扩展的安全角色和认证选项以及API等功能。</p>
<ul>
<li>主要特点：<ul>
<li>支持多种数据库，包括Presto、Trino、Athena等，并有更全面的支持数据库列表及配置说明。</li>
<li>提供无代码界面快速构建图表，强大的基于Web的SQL编辑器进行高级查询。</li>
<li>具有轻量级语义层，可快速定义自定义维度和指标。</li>
<li>提供多种美观的可视化效果，包括从简单的条形图到地理空间可视化。</li>
<li>拥有轻量级、可配置的缓存层，以减轻数据库负载。</li>
<li>高度可扩展的安全角色和身份验证选项。</li>
<li>提供API进行程序化定制。</li>
<li>采用云原生架构，专为扩展而设计。</li>
</ul>
</li>
</ul>
<p> <img data-src="https://camo.githubusercontent.com/40801e020bdee75b1550d7664e43329b35d8a46dd5e175541ae4be8f0f96c81d/68747470733a2f2f73757065727365742e6170616368652e6f72672f696d672f73637265656e73686f74732f67616c6c6572792e6a7067"></p>
<p>开源地址： <a href="https://github.com/apache/superset">https://github.com/apache/superset</a></p>
<h2 id="Ladybird-一个真正独立的Web浏览器"><a href="#Ladybird-一个真正独立的Web浏览器" class="headerlink" title="Ladybird - 一个真正独立的Web浏览器"></a>Ladybird - 一个真正独立的Web浏览器</h2><p> Ladybird是一个从零开始构建的全新Web浏览器和引擎项目，由非盈利组织支持。它采用Web标准优先的方法，旨在提供高性能、稳定性和安全性的现代Web渲染。起初作为SerenityOS项目的HTML查看器，Ladybird已经发展成为支持Linux、macOS和其他类Unix系统的跨平台浏览器。</p>
<p>Ladybird目前正处于密集开发阶段，计划在2026年初发布Alpha版本，主要面向开发者和早期采用者。该项目有几个独特之处：它是完全独立的，不使用其他浏览器的代码；它专注于Web浏览器开发，没有商业化；并且它不接受任何形式的用户货币化。</p>
<p>官网： <a href="https://ladybird.org/">https://ladybird.org/</a></p>
<p>开源地址：<a href="https://github.com/LadybirdBrowser/ladybird">https://github.com/LadybirdBrowser/ladybird</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="在VSCode里离线使用语雀编辑器"><a href="#在VSCode里离线使用语雀编辑器" class="headerlink" title="在VSCode里离线使用语雀编辑器 "></a><a href="https://www.yuque.com/epeiuss/hyghh/akp1bz3preq1kozw">在VSCode里离线使用语雀编辑器 </a></h2><p>在VSCode里通过一款插件可以离线使用语雀编辑器,支持多种语法和主题,并且与云上语雀的兼容性很好。该插件功能丰富,用户可以自定义显示工具栏等设置,同时还支持将Lakebook文件本地导入和批量导入。此外,通过该插件编写的Lakebook文件也可以直接导入至语雀知识库中。</p>
<p><strong>特点</strong></p>
<ul>
<li>该插件在VSCode中实现了离线使用语雀编辑器的功能,支持多种语法和主题。</li>
<li>插件支持自定义显示工具栏、标题和大纲等设置,用户可以根据需要进行调整。</li>
<li>该插件支持将Lakebook文件本地导入,并且导入的Lakebook文件可以直接兼容语雀知识库。</li>
<li>该插件还支持批量导入Lakebook文件,可以一次性导入多个文件。</li>
<li>通过该插件编写的Lakebook文件可以直接复制粘贴到语雀中,格式保持完整兼容。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407172201782.png"></p>
<p>插件地址：<a href="https://marketplace.visualstudio.com/items?itemName=hugehardzhang.lake-editor&ssr=false#overview">lake-editor - Visual Studio Marketplace</a></p>
<p>教程地址： <a href="https://www.yuque.com/epeiuss/hyghh/akp1bz3preq1kozw">https://www.yuque.com/epeiuss/hyghh/akp1bz3preq1kozw</a> 以及 <a href="https://www.yuque.com/aijake/lf13z0/qbleyc">https://www.yuque.com/aijake/lf13z0/qbleyc</a></p>
<h2 id="优化React性能"><a href="#优化React性能" class="headerlink" title="优化React性能"></a>优化React性能</h2><p>Million.js是一个与React兼容的优化编译器，旨在通过减少比较（diffing）的开销来加快组件的渲染和协调过程。它通过跳过传统的diffing步骤，直接更新DOM节点，从而显著提高React应用的性能。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202407172216290.png"></p>
<p>官网：<a href="https://million.dev/">https://million.dev/</a></p>
<p>开源地址：<a href="https://github.com/aidenybai/million">https://github.com/aidenybai/million</a></p>
<br />

<br />

<p>🎉 本文同步更新于 <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第53期</title>
    <url>/posts/61924.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如开源剪切板管理器EcoPaste 、开源多端图像托管平台管理工具 PicList  、Notion的离线替代品Eidos。此外，还介绍了 Windows 开源沙盒软件 Sandboxie Plus以及开源产品图标库 QingIcon。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202408022300536.jpg" alt="https://www.pexels.com/zh-cn/photo/21760959/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第53期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/4zCj_li4C-8VQer7s3Pkrg">Kotlin 技术月报 | 2024 年 7 月  </a> ：  </p>
<p>最新动态：</p>
<ul>
<li>Kotlin 2.0.10-RC 版本的发布，这是一个错误修复版本。</li>
<li>Xcode-Kotlin 2.0 发布，提供了在 Xcode 中直接调试 Kotlin 代码的能力。</li>
</ul>
<p>精选博客：</p>
<ul>
<li>介绍腾讯视频使用 KMP 技术改造基础组件的实践。</li>
<li>Kotlin 协程的本质和内部分享整理。</li>
<li>通过 Kotlin 编译器插件 KCP 实现 val 声明变量的常量优化。</li>
</ul>
<p>精选视频：</p>
<ul>
<li>Kotlin 炉边漫谈 Podcast #17，腾讯 QQ 团队分享自研的 KMP 框架。</li>
</ul>
<p>社区活动：</p>
<ul>
<li>KotlinConf Global 2024 上海分享会的回放，包括 KMP 相关技术和实践分享。</li>
</ul>
</li>
<li><p><a href="https://juejin.cn/post/7266745788536832015">复盘接手 Flutter 生态中顶级热门的 dio 库的几个月，我们做了什么？ </a>：文章详细回顾了作者作为主要推动者之一，参与接手和维护 Flutter 生态中的顶级 HTTP 库 dio 的过程。从 dio 库的背景介绍，到因缺乏维护而经历的挑战和社区分叉，再到作者和团队如何通过硬分叉、社区沟通和原作者的最终认可，成功地将 dio 库的维护权转移到新的团队，并发布了新版本。文章还分享了作者在开源项目维护过程中的个人得失、经验教训和感想。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/l-ZXvvOg7LyM-psdPXTDow">7个Android Studio使用技巧 </a> ：这篇文章提供了七个Android Studio的使用技巧，旨在帮助开发者提高生产力和简化开发流程。技巧包括：</p>
<ol>
<li><strong>使用Logcat拍摄屏幕截图和录制屏幕</strong>：介绍了如何在Logcat窗口中快速截取设备屏幕和录制视频。</li>
<li><strong>学习和使用快捷键</strong>：强调了学习快捷键的重要性，并推荐了Key Promoter X插件来帮助记忆快捷键。</li>
<li><strong>禁用运行窗口切换</strong>：说明了如何防止Android Studio在应用部署后自动切换到Run窗口。</li>
<li><strong>在每次应用程序运行时自动显示Logcat</strong>：描述了如何设置Android Studio以在应用部署时自动显示并清除Logcat日志。</li>
<li><strong>使用内置的Git客户端</strong>：介绍了Android Studio内置的Git客户端及其高级功能，如合并冲突解决和搁置更改。</li>
<li><strong>ADB Idea插件</strong>：推荐了一个增加ADB功能的插件，简化了执行设备操作的过程。</li>
<li><strong>学习调试器</strong>：强调了掌握Android Studio调试器的重要性，并提供了开始调试的两种方法。</li>
</ol>
</li>
<li><p><a href="https://juejin.cn/post/7397292988672868367">主线程结束了，子线程是否可以正常运行</a>：  </p>
<p>文章通过一个面试问题引入主题，探讨了Java中主线程结束后子线程是否能继续运行的问题。</p>
<p><strong>用户线程（User Thread）</strong>：如果子线程是用户线程且未被设置为守护线程，它们不依赖于创建它们的线程，因此主线程的结束不会影响用户线程的执行。</p>
<p><strong>守护线程（Daemon Thread）</strong>：设计用于执行后台任务，如垃圾回收。如果所有用户线程结束，且JVM中没有其他用户线程，守护线程也会自动结束，JVM随之退出。文章通过代码示例展示了用户线程和守护线程在主线程结束后的行为。</p>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="开源剪切板管理器EcoPaste"><a href="#开源剪切板管理器EcoPaste" class="headerlink" title="开源剪切板管理器EcoPaste"></a>开源剪切板管理器EcoPaste</h2><p><a href="https://github.com/ayangweb/EcoPaste/?tab=readme-ov-file">EcoPaste</a> 是一款适用于 MacOS 和 Windows 平台的强大开源剪贴板管理器。它采用 Tauri 构建,轻量级且精致,消耗最少资源,提供统一的跨平台用户体验。该应用程序拥有诸多功能,如后台操作、智能分组、最爱收藏、内置搜索、离线图像 OCR、增强上下文菜单、高度可定制以及自动更新等。它还支持数据备份和迁移,确保数据的持续可用性。</p>
<p>特性：</p>
<ul>
<li><p><strong>轻量小巧，多平台用</strong>：</p>
<p>使用 Tauri 构建，应用更加小巧精致，资源占用极少，同时完美适配 Windows 和 MacOS 平台，保证多平台一致的用户体验。</p>
</li>
<li><p><strong>常驻后台，快捷唤醒</strong>：</p>
<p>应用常驻后台运行，通过自定义快捷键一键唤醒，帮助用户快速调用剪贴板内容，极大地提高工作效率。</p>
</li>
<li><p><strong>本地存储，数据安全</strong>：</p>
<p>所有剪贴板内容均在本地存储，确保数据隐私和安全，不会有任何数据泄漏风险。</p>
</li>
<li><p><strong>智能管理，类型分组</strong>：</p>
<p>支持纯文本、富文本、HTML、图片和文件类型，并自动根据剪贴板内容类型进行分组管理，方便用户高效查找和使用。</p>
</li>
<li><p><strong>收藏功能，快速访问</strong>：</p>
<p>支持收藏剪贴板内容，方便快速访问和管理重要信息。无论是工作中的关键数据还是日常生活中的常用信息，都可以轻松收藏和查看。</p>
</li>
<li><p><strong>内置搜索，轻松查找</strong>：</p>
<p>内置搜索功能，帮助用户快速找到任何剪贴板上的内容，无论是文本、图片（OCR文本搜索）还是文件，所有内容都可以一目了然。</p>
</li>
<li><p><strong>图片OCR，离线识别</strong>：</p>
<p>内置系统 OCR 功能，支持文本和二维码识别，通过右键菜单快速复制识别到的 OCR 内容，实现离线识别，使用更便捷。</p>
</li>
<li><p><strong>右键菜单，操作便捷</strong>：</p>
<p>提供丰富的右键菜单选项，用户可以快速进行各种操作，极大地提高了使用便捷性。</p>
</li>
<li><p><strong>自由定制，个性体验</strong>：</p>
<p>提供详细的配置选项，用户可以自由设置和调整应用效果，打造个性化的使用体验，满足不同场景和需求。</p>
</li>
<li><p><strong>自动更新，保持最新</strong>：</p>
<p>软件支持自动更新和手动检查更新功能，确保用户始终使用最新版本，享受最优质的使用体验。</p>
</li>
<li><p><strong>数据备份，轻松迁移</strong>：</p>
<p>支持导出和导入配置及剪贴板内容，便于数据备份与迁移到不同平台，保证数据的持续可用性。</p>
</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202408022208952.png"></p>
<p>开源地址： <a href="https://github.com/ayangweb/EcoPaste/">https://github.com/ayangweb/EcoPaste/</a></p>
<br />

<h2 id="开源多端图像托管平台管理工具-PicList"><a href="#开源多端图像托管平台管理工具-PicList" class="headerlink" title="开源多端图像托管平台管理工具 PicList"></a>开源多端图像托管平台管理工具 PicList</h2><p>PicList 是一种高效的云存储和图像托管平台管理工具。在PicGo的基础上，对其进行了深度修改和增强。它不仅保留了 PicGo 的所有功能，而且还添加了许多新功能。例如，相册现在支持同步删除云中的文件。内置图像托管选项已扩展为包括 WebDav、本地图像托管和 SFTP。此外，PicList 还引入了全面的云存储管理功能，包括云目录查看、文件搜索、批量上传、下载和文件删除、复制各种格式的链接以及预览图片、Markdown、文本和视频。此外，它还拥有更强大的专辑功能以及许多其他改进和增强功能。支持windows、Mac、linux平台。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202408022210641.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202408022210039.png"></p>
<p>开源地址：<a href="https://github.com/Kuingsmile/PicList">https://github.com/Kuingsmile/PicList</a></p>
<br />

<h2 id="Notion的离线替代品Eidos"><a href="#Notion的离线替代品Eidos" class="headerlink" title="Notion的离线替代品Eidos"></a>Notion的离线替代品Eidos</h2><p>Eidos是一个可扩展的框架，用于在一个地方管理个人数据的一生，是Notion的离线替代品。</p>
<p>项目特点</p>
<ul>
<li><strong>纯PWA</strong>：作为一个渐进式Web应用程序(PWA)，Eidos 完全在浏览器内运行，无需Web服务器。</li>
<li><strong>离线支持</strong>：即使没有互联网连接，您也可以访问数据，数据存储在本地，提供极快的性能。</li>
<li><strong>AI功能</strong>：与LLM深度集成，提供翻译、摘要和与数据交互的AI能力，甚至支持离线使用。</li>
<li><strong>可扩展性</strong>：通过各种扩展定制Eidos以满足您的需求，包括Prompt扩展、用户定义函数(UDF)、脚本编写等。</li>
<li><strong>开发者友好</strong>：提供API和SDK，以及对SQLite标准化的支持。</li>
</ul>
<p><img data-src="https://github.com/mayneyao/eidos/blob/dev/public/show/table-and-doc.webp"></p>
<p>开源地址：<a href="https://github.com/mayneyao/eidos">https://github.com/mayneyao/eidos</a></p>
<p>官网：<a href="https://eidos.space/">https://eidos.space/</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Windows-开源沙盒软件-Sandboxie-Plus"><a href="#Windows-开源沙盒软件-Sandboxie-Plus" class="headerlink" title="Windows 开源沙盒软件 Sandboxie Plus"></a>Windows 开源沙盒软件 Sandboxie Plus</h2><p>Sandboxie Plus是Sandboxie软件的一个社区分支，它在Sandboxie开源后由David Xanatos继续开发。这个项目为32位和64位的Windows NT操作系统提供了一个隔离环境，允许用户运行应用程序而不会对系统造成永久更改。Sandboxie Plus和Classic两个版本共享相同的核心组件，但Plus版本提供了一个基于Qt的现代用户界面和许多新功能，如快照管理、维护模式、隐私模式沙盒等。项目还提供了详细的文档、贡献指南和安全政策，并鼓励社区贡献。</p>
<p>使用教程推荐阅读：<a href="https://sspai.com/post/88759">App+1 | 用 Sandboxie-Plus，管住「不听话」的 Windows 软件 - 少数派 </a></p>
<p>开源地址： <a href="https://github.com/sandboxie-plus/Sandboxie">https://github.com/sandboxie-plus/Sandboxie</a></p>
<br />

<h2 id="开源产品图标库-QingIcon"><a href="#开源产品图标库-QingIcon" class="headerlink" title="开源产品图标库 QingIcon"></a>开源产品图标库 QingIcon</h2><p> QingIcon是一个由QingCloud推出的B端矢量图标库，由Asorn和胡蝶设计。该图标库包含2200多个图标，适用于网页设计项目。这些图标遵循Apache 2.0许可证，允许用户在遵守许可协议的前提下自由使用。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202408022248514.png" alt="image-20240802224834391"></p>
<p>在线地址：<a href="https://qingicon.com/">https://qingicon.com/</a></p>
<p>Figma 插件：<a href="https://www.figma.com/community/plugin/1111565622161029659/figicon">https://www.figma.com/community/plugin/1111565622161029659/figicon</a></p>
<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于   <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第55期</title>
    <url>/posts/4453.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如开源剪切板管理器EcoPaste 、开源在线白板工具 Excalidraw  、开源在线白板工具 Excalidraw 。此外，还推荐了开源电子书开源在线白板工具 Excalidraw 以及Obsidian 虚拟双链插件Virtual Linker。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/imgpexels-phamnghia-1206597.jpg" alt="https://www.pexels.com/zh-cn/photo/pinepapple-1206597/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第55期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/Pzs1X0bpXUE1AzeMxyGl3g">Git 命令小抄  </a> ：  </p>
<p>文章首先介绍了 Git 的由来和它与其他版本控制工具的区别，包括分布式架构、数据完整性、高效的分支和合并、速度、内容跟踪等特性。接着，文章列出了 Git 的基本命令，涵盖了初始化和克隆、暂存和提交、分支创建和切换、合并、推送和拉取等操作。此外，还介绍了典型的开发工作流程，包括创建分支、开发和提交修改、合并改动和推送修改。最后，文章解释了冲突解决的过程，包括识别冲突、解决冲突和将冲突标记为已解决的步骤。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/I01UZboRX95XCN1Fy9T45g">如何在Flutter应用程序中查找内存泄漏？ </a>： 文章详细介绍了使用 Flutter 的 DevTools 来检测和解决 Flutter 应用程序中的内存泄漏问题。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Hhv5qwPLMs9eaNi-1xd9yg">不用一行代码查看方法耗时，这款 IDEA 插件有点酷！  </a>：</p>
</li>
</ul>
<p>  文章详细介绍了 Cool Request 插件的新功能 Trace，该功能允许用户在 IntelliJ IDEA 中统计任意方法的耗时，而无需编写代码。Trace 功能可以自动从 Controller 方法开始跟踪，支持不同深度的跟踪，并可以手动添加方法跟踪。此外，Trace 还可以选择性地跟踪 Mybatis 的执行函数，显示调用次数，并且允许用户自定义耗时颜色以高亮显示超过特定时间阈值的方法。文章还提到了 Cool Request 插件在操作环境和响应脚本处理方面的优势，如获取 token 和使用 Java 代码解析 JSON。</p>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="PDF工具箱-PDF-Guru-Anki"><a href="#PDF工具箱-PDF-Guru-Anki" class="headerlink" title="PDF工具箱 PDF Guru Anki"></a>PDF工具箱 PDF Guru Anki</h2><p> PDF Guru Anki是一款以PDF为中心的多功能办公学习工具箱软件，包含四大板块功能：PDF实用工具箱、Anki制卡神器、Anki最强辅助、视频笔记神器，软件功能众多且强大，熟练运用可以大幅提高办公和学习效率，绝对是您不可多得的效率神器。</p>
<p><img data-src="https://camo.githubusercontent.com/ead8fc6ee74c8edd50a5987c591d8685110b020a91f5afdfff5eff2993fad9b5/68747470733a2f2f6d696e696f2e6b6576696e326c692e746f702f696d6167652d6265642f77696b692f32303234303731303232313431352e706e67"></p>
<p>开源地址：   <a href="https://github.com/kevin2li/PDF-Guru">https://github.com/kevin2li/PDF-Guru</a></p>
<h2 id="开源在线白板工具-Excalidraw"><a href="#开源在线白板工具-Excalidraw" class="headerlink" title="开源在线白板工具 Excalidraw"></a>开源在线白板工具 Excalidraw</h2><p> Excalidraw 是一个开源的在线白板工具，以其手绘风格的图形设计受到用户的喜爱。它提供了简洁直观的界面和多种绘图工具，支持实时多人协作，允许用户离线使用并同步数据。此外，Excalidraw 支持将图表导出为 PNG、SVG 和 Excalidraw 格式。对于开发者，Excalidraw 还提供了 VS Code 插件，使得在代码编辑器中创建和编辑图表变得方便。文章还提供了如何在 VS Code 中使用 Excalidraw 插件的步骤，以及 Excalidraw 的使用场景和资源获取方式。</p>
<p>特性：</p>
<ul>
<li>💯 免费和开源。</li>
<li>🎨 无限的、基于画布的白板。</li>
<li>✍️ 手绘般的风格。</li>
<li>🌓 深色模式。</li>
<li>🏗️ 定制。</li>
<li>📷 图像支持。</li>
<li>😀 形状库支持。</li>
<li>👅  本地化 （i18n） 支持。</li>
<li>🖼️  导出为 PNG、SVG 和剪贴板。</li>
<li>💾 开放格式 - 将绘图导出为 <code>.excalidraw</code> json 文件。</li>
<li>⚒️ 种类繁多的工具 - 矩形、圆形、菱形、箭头、线条、自由绘制、橡皮擦……</li>
<li>➡️ 箭头绑定和标记箭头。</li>
<li>🔙 撤消&#x2F;重做。</li>
<li>🔍 缩放和平移支持</li>
</ul>
<p><img data-src="https://camo.githubusercontent.com/ddb3b5442d70e4dc28bf57c16f772be3ebe1ac3768ffbacaca3606013bf696a4/68747470733a2f2f657863616c69647261772e6e7963332e63646e2e6469676974616c6f6365616e7370616365732e636f6d2f67697468756225324670726f647563745f73686f77636173652e706e67"></p>
<p>开源地址：<a href="https://github.com/mayneyao/eidos">https://github.com/mayneyao/eidos</a></p>
<p>在线地址：<a href="https://excalidraw.com/">https://excalidraw.com/</a></p>
<h2 id="开源跨平台文件管理器Spacedrive"><a href="#开源跨平台文件管理器Spacedrive" class="headerlink" title="开源跨平台文件管理器Spacedrive"></a>开源跨平台文件管理器Spacedrive</h2><p>Spacedrive 是一个革命性的开源跨平台文件管理器，它通过虚拟分布式文件系统 (VDFS) 技术，实现了对云端服务和离线硬盘的统一管理。文章强调了 Spacedrive 的多项特点，包括使用 Rust 语言开发、注重用户隐私和数据所有权、以及提供丰富的文件管理功能。Spacedrive 支持跨平台使用，具有服务器应用、图书馆管理、加密保护、实时同步等功能。此外，文章还提供了安装指南，包括桌面应用、Docker 服务器、移动应用（即将推出）和 Homebrew 的安装方法。Spacedrive 的设计目标是提供一个统一而强大的文件管理平台，提高效率，节省空间，并确保数据安全性和隐私性。</p>
<p>特性：</p>
<ul>
<li><strong>跨平台支持</strong>：适用于 Windows、Linux 和 macOS 的桌面应用，以及即将推出的 iOS 和 Android 移动应用。</li>
<li><strong>服务器应用</strong>：通过 Docker 部署的服务器应用，带有托管 Web 界面。</li>
<li><strong>图书馆管理</strong>：创建和管理多个图书馆，整合不同设备上的文件资源。</li>
<li><strong>加密保护</strong>：支持图书馆加密，确保数据安全。</li>
<li><strong>实时同步</strong>：自动同步文件更改，确保图书馆始终是最新的。</li>
<li><strong>探索与导航</strong>：通过地点、标签、空间、相册或搜索等方式浏览文件。</li>
<li><strong>灵活布局</strong>：提供列表、网格、列视图和媒体视图等多种布局选项。</li>
<li><strong>文件预览</strong>：内置多种文件类型（如图像、视频、音频、PDF 等）的预览功能。</li>
<li><strong>位置管理</strong>：指定搜索地点，自动索引文件，并跟踪变化。</li>
<li><strong>云服务集成</strong>：支持 Google Drive、Dropbox、OneDrive、Amazon S3 等云服务的集成。</li>
<li><strong>概览统计</strong>：分析文件类别，提供详细的数据统计信息。</li>
<li><strong>标签系统</strong>：设计和附加标签，或直接从侧边栏探索已标记的文件。</li>
<li><strong>照片专辑</strong>：导入或创建相册，轻松管理你的珍贵回忆。</li>
<li><strong>Spacedrop</strong>：简单拖放即可在不同设备间传输文件。</li>
<li><strong>任务管理</strong>：监控文件操作进度，确保数据安全。</li>
<li><strong>个性化设置</strong>：支持浅色和深色主题，以及超过 250 种文件类型的图标</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img20240817003644.png"></p>
<p>官网：<a href="https://www.spacedrive.com/">https://www.spacedrive.com/</a></p>
<p>开源地址：<a href="https://github.com/spacedriveapp/spacedrive">https://github.com/spacedriveapp/spacedrive</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="高并发的哲学原理"><a href="#高并发的哲学原理" class="headerlink" title="高并发的哲学原理"></a>高并发的哲学原理</h2><p>推荐了一本名为《高并发的哲学原理》（PPHC）的开源技术书籍，涵盖了高并发架构的关键设计方法和实践。《高并发的哲学原理》（PPHC），该书由五部分组成，包括通用设计方法、计算资源高并发、网络资源高并发、数据库高并发和无限容量架构。书籍内容全面，从基础概念到高级主题，为读者提供了深入理解高并发系统设计的资源。书籍最早在作者的公众号发布，并于2023年10月完成纸质书稿并开源。读者可以通过提供的在线阅读地址或下载PDF版本来获取这本书。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/imgfile_1723562603970_330.png"></p>
<p>在线地址：<a href="https://pphc.lvwenhan.com/">https://pphc.lvwenhan.com/</a></p>
<p>开源地址： <a href="https://github.com/johnlui/PPHC?tab=readme-ov-file">https://github.com/johnlui/PPHC?tab=readme-ov-file</a></p>
<h2 id="Obsidian-虚拟双链插件Virtual-Linker"><a href="#Obsidian-虚拟双链插件Virtual-Linker" class="headerlink" title="Obsidian 虚拟双链插件Virtual Linker"></a>Obsidian 虚拟双链插件Virtual Linker</h2><p>Virtual Linker 是一款由 Valentin Schröter 开发的 Obsidian 插件，它能够自动探测笔记中的文本，并为其生成与其它笔记标题或别名匹配的虚拟链接。这些链接以特殊格式显示，提供直观的视觉提示，帮助用户迅速识别笔记间的联系。插件支持点击跳转和悬浮预览，但不会出现在图谱视图和引用计数中。用户可以通过右键将虚拟链接转换为真实链接。文章还提到了 Obsidian 核心插件中的出链面板，它可以显示当前笔记中的潜在链接，并允许用户手动确认转换。Virtual Linker 插件提供了一个更直观的正文中高亮显示潜在链接的方式。</p>
<p><img data-src="https://cdn.pkmer.cn/images/20240730204932.png!pkmer" alt="图片来自https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/virtual-linker/"></p>
<p>使用文档：<a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/virtual-linker/">https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/virtual-linker/</a></p>
<p>开源地址：<a href="https://github.com/vschroeter/obsidian-virtual-linker">https://github.com/vschroeter/obsidian-virtual-linker</a></p>
<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于   <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第57期</title>
    <url>/posts/43364.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如免费文件翻译工具 DeeplxFile  、 flutter 版的 confetti（放礼花）包、Revezone - 一款以图形为中心的思维管理工具、删除预装的 Windows 无用软件应用程序 Win11Debloat 、 ComfyUI  一款 Stable Diffusion 图形用户界面（GUI） 、AI 编程软件 Cursor 。此外，还推荐了开源数据结构与算法和开源数据结构与算法。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/pexels-padrinan-434137.jpg" alt="https://www.pexels.com/zh-cn/photo/434137/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第57期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />

<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/wD0AGHMnrhTS-721YbRTLg">你的 Flutter 项目异常太多是因为代码没有这样写 </a> ：  </p>
<p>文章首先介绍了 Git 的由来和它与其他版本控制工具的区别，包括分布式架构、数据完整性、高效的分支和合并、速度、内容跟踪等特性。接着，文章列出了 Git 的基本命令，涵盖了初始化和克隆、暂存和提交、分支创建和切换、合并、推送和拉取等操作。此外，还介绍了典型的开发工作流程，包括创建分支、开发和提交修改、合并改动和推送修改。最后，文章解释了冲突解决的过程，包括识别冲突、解决冲突和将冲突标记为已解决的步骤。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/g0FlqnCSFuA1EtpeWhKPfA">Flutter 的异常捕获</a>： 在 Flutter 应用程序开发中，异常捕获是一个重要的环节。文章首先解释了 Flutter 框架如何在 UI 构建过程中通过 <code>ComponentElement</code> 的 <code>performRebuild()</code> 方法自动捕获异常，并展示默认的异常信息提示页面。接着，文章展示了如何通过自定义 <code>ErrorWidget.builder</code> 来改变异常信息的显示方式。此外，文章还介绍了 <code>FlutterError.onError</code> 和 <code>PlatformDispatcher</code> 的全局异常捕获机制，允许开发者在 <code>main()</code> 函数中设置自定义的异常处理逻辑。最后，文章提供了一个示例代码，演示了如何结合使用这些机制来全局捕获和处理异常信息。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/jPgvhekDyZNiAzClogAe9g">安卓工程师必须了解的Gradle知识 </a> ：  文章详细介绍了 Cool Request 插件的新功能 Trace，该功能允许用户在 IntelliJ IDEA 中统计任意方法的耗时，而无需编写代码。Trace 功能可以自动从 Controller 方法开始跟踪，支持不同深度的跟踪，并可以手动添加方法跟踪。此外，Trace 还可以选择性地跟踪 Mybatis 的执行函数，显示调用次数，并且允许用户自定义耗时颜色以高亮显示超过特定时间阈值的方法。文章还提到了 Cool Request 插件在操作环境和响应脚本处理方面的优势，如获取 token 和使用 Java 代码解析 JSON。</p>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="flutter-版的-confetti（放礼花）包"><a href="#flutter-版的-confetti（放礼花）包" class="headerlink" title="flutter 版的 confetti（放礼花）包"></a>flutter 版的 confetti（放礼花）包</h2><p>在 Flutter 中轻松制作五彩纸屑动画。</p>
<p>特性：</p>
<ul>
<li>各种开箱即用的形状，如圆形、星形、正方形等。</li>
<li>许多示例演示了不同的五彩纸屑动画。</li>
<li>轻松制作您想要的形状。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/msedge_qGDaLXNx0H.png"></p>
<p>开源地址：<a href="https://github.com/cj0x39e/flutter_confetti">https://github.com/cj0x39e/flutter_confetti</a></p>
<p>在线地址： <a href="https://cj0x39e.github.io/flutter_confetti/">https://cj0x39e.github.io/flutter_confetti/</a></p>
<br />



<h2 id="Revezone-一款以图形为中心的思维管理工具"><a href="#Revezone-一款以图形为中心的思维管理工具" class="headerlink" title="Revezone - 一款以图形为中心的思维管理工具"></a>Revezone - 一款以图形为中心的思维管理工具</h2><p>Revezone 是一款以图形为中心、轻量级、本地优先的用于构建第二大脑的效率工具。</p>
<p><a href="https://camo.githubusercontent.com/ceb28a145318da3ef5fce33771a7ad29c0608b4655bc002993d391744993d019/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69342f4f31434e303168777a75426131704854744b6a4b4841455f2121363030303030303030353333352d322d7470732d323935322d313730362e706e67"><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69342f4f31434e303168777a75426131704854744b6a4b4841455f2121363030303030303030353333352d322d7470732d323935322d313730362e706e67"></a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul>
<li>在线试用版本（数据存储在浏览器中）：<a href="https://revezone.com/">https://revezone.com</a></li>
<li>桌面应用程序版本（本地数据存储）：<a href="https://github.com/revezone/revezone/releases">https://github.com/revezone/revezone/releases</a></li>
</ul>
<p>开源地址： <a href="https://github.com/revezone/revezone">https://github.com/revezone/revezone</a></p>
<br />





<h2 id="AI-编程软件-Cursor"><a href="#AI-编程软件-Cursor" class="headerlink" title="AI 编程软件 Cursor"></a>AI 编程软件 Cursor</h2><p>Cursor是一款集成了 AI 的编程软件，能够根据用户的指令自动生成代码，显著提高了编程效率和便捷性。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240827202328175.png"></p>
<p>开源地址：<a href="https://www.cursor.com/">https://www.cursor.com/</a>  </p>
<br />

<h2 id="免费文件翻译工具-DeeplxFile"><a href="#免费文件翻译工具-DeeplxFile" class="headerlink" title="免费文件翻译工具 DeeplxFile"></a>免费文件翻译工具 DeeplxFile</h2><p>DeeplxFile 是一个基于 Deeplx 提供的免费文件翻译工具，它不限制文件大小，可以帮助用户将文件内容翻译成不同的语言。</p>
<p>使用说明：</p>
<blockquote>
<p>Windows提供了编译好的exe版本, 直接双击运行即可<br>从源代码运行<br>也可以下载源代码， 然后运行 python deeplxfile.py</p>
<p>MacOS右键解压出来的文件夹，选择在文件夹打开新终端， 终端中输入<br>.&#x2F;deelxfile</p>
</blockquote>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240827193213686.png"></p>
<p>开源地址：  <a href="https://github.com/infrost/DeeplxFile">https://github.com/infrost/DeeplxFile</a></p>
<br />



<h2 id="删除预装的-Windows-无用软件应用程序：-Win11Debloat"><a href="#删除预装的-Windows-无用软件应用程序：-Win11Debloat" class="headerlink" title="删除预装的 Windows 无用软件应用程序： Win11Debloat"></a>删除预装的 Windows 无用软件应用程序： Win11Debloat</h2><p>Win11Debloat 是一个面向 Windows 系统的 PowerShell 脚本，它允许用户通过简单的操作来定制和优化他们的 Windows 环境。这个工具的主要功能包括移除预装的冗余应用程序、禁用遥测和追踪功能、消除系统界面上的广告和建议等。它提供了应用程序删除、遥测与隐私保护、搜索与界面定制、文件资源管理器调整、任务栏定制、上下文菜单调整和其他功能。Win11Debloat 支持一键式的系统优化，让用户无需手动逐一调整系统设置。文章还提供了安装指南，包括准备环境、下载运行脚本、选择模式、执行功能以及完成和清理的步骤。</p>
<blockquote>
<h3 id="快速方法"><a href="#快速方法" class="headerlink" title="快速方法"></a>快速方法</h3><p>通过PowerShell自动下载并运行脚本。</p>
<ol>
<li>以管理员身份打开 PowerShell。</li>
<li>将以下代码复制并粘贴到 PowerShell 中，按 Enter 运行脚本：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp; ([scriptblock]::Create((irm &quot;https://win11debloat.raphi.re/&quot;)))</span><br></pre></td></tr></table></figure>



<ol>
<li>等待脚本自动下载 Win11Debloat。</li>
<li>将打开一个新的 PowerShell 窗口，显示 Win11Debloat 菜单。选择默认模式或自定义模式以继续。</li>
<li>请仔细阅读并按照屏幕上的说明进行操作。</li>
</ol>
<p>该方法支持<a href="https://github.com/Raphire/Win11Debloat#parameters">参数</a>。要使用参数，只需按照上述说明运行脚本，但在末尾添加参数，并在两者之间添加空格。例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp; ([scriptblock]::Create((irm &quot;https://win11debloat.raphi.re/&quot;))) -RunDefaults -Silent</span><br></pre></td></tr></table></figure>



<h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>手动下载并运行脚本。</p>
<ol>
<li><a href="https://github.com/Raphire/Win11Debloat/archive/master.zip">下载最新版本的脚本</a>，并将 .ZIP 文件解压缩到所需位置。</li>
<li>导航到 Win11Debloat 文件夹</li>
<li>双击 <code>Run.bat</code> 文件以启动脚本。注意：如果控制台窗口立即关闭且没有任何反应，请尝试以下高级方法。</li>
<li>接受 Windows UAC 提示以管理员身份运行脚本，这是脚本运行所必需的。</li>
<li>现在将打开一个新的 PowerShell 窗口，显示 Win11Debloat 菜单。选择默认模式或自定义模式以继续。</li>
<li>请仔细阅读并按照屏幕上的说明进行操作。</li>
</ol>
</blockquote>
<p>开源地址：<a href="https://github.com/Raphire/Win11Debloat">https://github.com/Raphire/Win11Debloat</a></p>
<p>使用教程：<a href="https://mp.weixin.qq.com/s/ewrxnrXOIgodQizUEG473A">https://mp.weixin.qq.com/s/ewrxnrXOIgodQizUEG473A</a></p>
<br />



<h2 id="ComfyUI-——-一款-Stable-Diffusion-图形用户界面（GUI）"><a href="#ComfyUI-——-一款-Stable-Diffusion-图形用户界面（GUI）" class="headerlink" title="ComfyUI —— 一款 Stable Diffusion 图形用户界面（GUI）"></a>ComfyUI —— 一款 Stable Diffusion 图形用户界面（GUI）</h2><p> ComfyUI，一个允许用户创建和运行复杂 Stable Diffusion 工作流程的程序。它讨论了 ComfyUI 的功能、如何安装 ComfyUI 以及如何使用 ComfyUI。一些重要的要点是 ComfyUI 是免费和开源的，并且可以用于创建各种 Stable Diffusion 工作流程。</p>
<p>开源地址：<a href="https://github.com/comfyanonymous/ComfyUI">https://github.com/comfyanonymous/ComfyUI</a></p>
<br />

<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="开源电子书You-Don’t-Know-JS-Yet"><a href="#开源电子书You-Don’t-Know-JS-Yet" class="headerlink" title="开源电子书You Don’t Know JS Yet"></a>开源电子书You Don’t Know JS Yet</h2><p>“You-Dont-Know-JS” 是一个广受欢迎的开源电子书系列，由 Kasper Tidemann 赞助，旨在深入探讨 JavaScript 语言的各个方面。这个项目适合所有希望加深对 JavaScript 工作原理理解的开发者，不论他们是初学者还是有经验的程序员。它涵盖了作用域与闭包、this 和对象原型、类型与文法、异步与性能以及 ES6 和更新版本的语法等高级主题。通过学习这些内容，开发者可以深入理解 JavaScript 的底层逻辑，更有效地解决实际问题，并为技术面试做好准备。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/msedge_8MnTr5gq34.png"></p>
<p>开源地址： <a href="https://github.com/getify/You-Dont-Know-JS?tab=readme-ov-file">https://github.com/getify/You-Dont-Know-JS?tab=readme-ov-file</a></p>
<br />



<h2 id="开源数据结构与算法"><a href="#开源数据结构与算法" class="headerlink" title="开源数据结构与算法"></a>开源数据结构与算法</h2><p>一个包含所有 Data Structures 和 Algorithms 概念及其以多种方式实现的存储库，编程问题和 Interview 问题。该存储库的主要目的是帮助正在学习数据结构和算法或准备面试的学生。此存储库包含所有 数据结构和算法 概念及其以多种方式实现、编程问题和面试问题。该存储库的主要目的是帮助正在学习数据结构和算法或准备面试的学生。这包含来自流行编码平台的问题，包括 <a href="https://leetcode.com/">LeetCode</a>、<a href="https://www.hackerrank.com/">HackerRank</a>、<a href="https://www.codechef.com/">Codechef</a>、<a href="https://practice.geeksforgeeks.org/explore/">GeeksforGeeks</a> 等等。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240827201511670.png"></p>
<p>开源地址：<a href="https://github.com/thepranaygupta/Data-Structures-and-Algorithms">https://github.com/thepranaygupta/Data-Structures-and-Algorithms</a></p>
<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">starsight&#x2F;TechWeekly (github.com)</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第59期</title>
    <url>/posts/16742.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如腾讯自研的 Git 客户端UGit  、 开源跨平台解压软件PeaZip 、 适用于 Mac 和 Windows 的免费剪贴板管理器PasteBar 、Obsidian  Folder Note插件 、 开源的 RAG 文档聊天工具kotaemon 、 由 KG 引擎驱动的创新代理框架muAgent。此外，还推荐了Claude Dev：一款集成了Claude 3.5 Sonnet的VSCode AI编程工具和轻量又高性能的 SSH 工具IShell。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/pexels-shaimacapture-8668726.jpg" alt="https://www.pexels.com/zh-cn/photo/8668726/"></p>
<span id="more"></span>



<br />

<p>欢迎来到第59期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />



<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/5AveHl_XJi-rk8lF-rT8Fw">为什么很多程序员讨厌低代码？</a> ：  </p>
<p>低代码平台允许用户通过少量或无需编写代码来快速开发和部署系统，这在某些场景下可以显著减少开发成本和加快应用上线速度。然而，低代码平台也存在一些缺点，如可能限制开发人员的灵活性，难以适应特殊业务需求或复杂逻辑，可能隐藏实现细节导致性能问题，以及可能不提供足够的可扩展性。此外，低代码平台的黑盒特性可能导致开发不可控，学习新工具可能需要额外的时间投入，且过度依赖特定供应商可能带来风险。文章最后总结，低代码平台在简单场景下可能是一个不错的选择，但在复杂项目中可能不适用。</p>
</li>
<li><p><a href="https://juejin.cn/post/7395396352182583306">Android 15- 16kb页对齐适配大扫盲通过本文</a> ：  文章详细介绍了Android 15更新中16kb页大小的重要性和适配方法。由于Google在Android 15中引入了可配置的16kb页大小，开发者需要对应用进行适配以避免潜在的崩溃问题。文章强调了需要适配的so分为两部分：未进行16kb对齐的so和native代码中硬编码写死了4kb的部分。作者提供了环境准备指南、so边界对齐方法、系统调用异常处理，并以shadowhook为例，演示了如何进行实际适配。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1erGPA2yyqJEoHgXtVkD5A">FirstUI：打造高效跨平台移动端开发的UI框架 </a> ： 文章详细介绍了FirstUI，这是一个为移动端开发的UI框架，它支持uni-app、微信小程序、支付宝小程序等多种平台。FirstUI具备跨平台兼容、组件化设计、低耦合、易扩展和性能优化等特点，能够帮助开发者提高开发效率，降低维护成本，并提升用户体验。</p>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="腾讯自研的-Git-客户端：UGit"><a href="#腾讯自研的-Git-客户端：UGit" class="headerlink" title="腾讯自研的 Git 客户端：UGit"></a>腾讯自研的 Git 客户端：UGit</h2><p>UGit 是腾讯为内部研发环境定制的 Git 客户端，支持 macOS 和 Windows 系统。它具有以下核心特性：便捷的大文件管理，包括内置 LFS 模板和大文件分析；快速提交，允许在不更新的情况下直接完成提交；工蜂锁机制，专为游戏项目设计，解决二进制文件协作问题；支持检出子目录，加快大型仓库的克隆速度。此外，UGit 还提供基础能力如极简操作、OAuth 认证、集成工蜂功能等，以及特色能力如加速服务、客户端钩子、定时任务等。</p>
<p><strong>基础能力</strong></p>
<ul>
<li>极简操作，类似于SVN或P4的集中式版本控制工具体验，可一键提交或更新</li>
<li>OAuth，支持工蜂、Github、Coding.net平台的OAuth认证</li>
<li>集成工蜂合并请求，便捷的在客户端中进行MR评审或操作</li>
<li>集成工蜂代码审查，在UGit中进行代码审查</li>
<li>集成工蜂Issue管理，邮件式的产品体验，可便捷、快速的查看、修改或评论Issue</li>
<li>Gitflow，可视化的交互集成业界经典的Gitflow工作流实践</li>
<li>分支管理，可以查看分支生命周期、批量管理，比如可以快速批量清理无用分支</li>
<li>SSH访问工蜂，支持零配置使用SSH访问工蜂</li>
<li>提交关联，可在提交时关联工蜂Issue</li>
</ul>
<p><strong>特色能力</strong></p>
<ul>
<li>加速服务，支持Git LFS缓存加速、UE4 DDC、Unity Cache</li>
<li>支持客户端钩子（python&#x2F;shell&#x2F;batch），可使用钩子脚本定制团队工作流，如提交规范检查</li>
<li>定时任务，包括定时锁分支、定时更新（下载LFS数据&#x2F;pull&#x2F;pull -f三种策略）</li>
<li>仓库同步服务，支持Git&#x2F;SVN&#x2F;P4任意两种仓库之间互相按Commit维度进行单向或双向同步，也可进行仓库迁移</li>
<li>分支规则管理，可一键锁定符合规则的分支；</li>
<li>多仓库管理，Git Submodule的替代方案，通过可视化操作，旨在解决大型项目多仓库依赖管理问题，支持批量克隆，一键更新、拉分支、切分支等等</li>
<li>仓库分组管理，可以对仓库进行分组管理，并且分组信息会展示在仓库标签上</li>
<li>变更集分组，可对工作区变更进行分组管理，按分组进行提交</li>
<li>集成CodeAction，不用克隆仓库就可以进行代码审查</li>
<li>支持Excel Diff&amp;Merge，支持单元格内容、公式，暂不支持表格样式</li>
<li>版本标记，支持在UGit仓库历史中标记版本为好的、坏的、标星等操作，方便版本回溯或版本信息共享；</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240907225131761.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240907230901758.png"></p>
<p>居然还能当作markdown编辑器用，🐂。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240910220538588.png"></p>
<p>官网： <a href="https://ugit.qq.com/zh/">https://ugit.qq.com/zh/</a></p>
<h2 id="PeaZip-：-开源跨平台解压软件"><a href="#PeaZip-：-开源跨平台解压软件" class="headerlink" title="PeaZip ： 开源跨平台解压软件"></a>PeaZip ： 开源跨平台解压软件</h2><p>PeaZip 是一款适用于 Linux、macOS 和 Windows 的免费解压软件。</p>
<p><strong>功能特点</strong></p>
<ul>
<li><strong>支持的归档格式</strong>：支持创建和打开 7Z、ARC、Brotli BR、BZip2、GZip、PAQ、PEA、RAR(+)、自解压档案、TAR、WIM、XZ、Zstandard ZST、ZIP 文件格式，以及 ACE、BR、CAB、DMG、ISO、RAR、UDF、ZST、ZIPX 等200+种文件格式的解压。</li>
<li><strong>文件归档功能</strong>：提取、创建和转换档案文件，原始文件分割&#x2F;合并，创建跨卷（多卷）档案，支持强加密、加密密码管理器、安全数据删除（不可恢复、永久擦除）、查找重复文件、计算哈希值和多种校验和算法，导出任务为命令行脚本以自动化备份和恢复任务。</li>
<li><strong>集成到 Windows 右键菜单</strong>：PeaZip 安装程序提供与 Windows 右键上下文菜单和“发送到”菜单的完全集成，方便用户快速访问应用程序的主要功能，如添加到归档、在此提取、用 PeaZip 打开等</li>
<li><strong>支持暗色模式</strong>：在 Windows 10 及更高版本系统上，PeaZip 支持暗色模式。</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240910222558532.png"></p>
<p>开源地址：<a href="https://github.com/peazip/PeaZip">https://github.com/peazip/PeaZip</a></p>
<p>官网：<a href="https://peazip.github.io/peazip-64bit.html">https://peazip.github.io/peazip-64bit.html</a></p>
<br />

<h2 id="PasteBar-适用于-Mac-和-Windows-的免费剪贴板管理器"><a href="#PasteBar-适用于-Mac-和-Windows-的免费剪贴板管理器" class="headerlink" title="PasteBar - 适用于 Mac 和 Windows 的免费剪贴板管理器"></a>PasteBar - 适用于 Mac 和 Windows 的免费剪贴板管理器</h2><p>PasteBar，一个强大的剪切板增强工具，它允许用户无限制地保存剪切板历史，并具备丰富的自定义功能。PasteBar支持保存图片、文件路径、代码片段、模板填充等，并能执行表单自动填充、Shell命令和网络内容获取。</p>
<p>软件界面支持中文，提供教学向导帮助新用户快速上手。它具备自动分类剪贴板历史、预设区编辑、快捷键设置等功能，用户可以通过快捷键快速搜索历史内容。</p>
<p>虽然PasteBar功能强大，但界面快捷操作可能需要一定时间适应，建议将其视为“档案馆”类工具使用，并注意避免将呼出粘贴面板的快捷键设置为Ctrl+V，以免与系统粘贴操作冲突。</p>
<p><img data-src="https://private-user-images.githubusercontent.com/6027060/351044610-c3024edb-67ae-4e92-a02f-a0957fb153a2.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjU5Nzc4OTksIm5iZiI6MTcyNTk3NzU5OSwicGF0aCI6Ii82MDI3MDYwLzM1MTA0NDYxMC1jMzAyNGVkYi02N2FlLTRlOTItYTAyZi1hMDk1N2ZiMTUzYTIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTBUMTQxMzE5WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZWY3YmQ1MjJjZGRhZmE1MTY4NGQ2NzUyNjlkY2NlM2VmMWQ5OGUyMzFlZTU2MzQzZTAzZDA3OWRkZmNiZTI1NyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.oS1jpsEAQ5Zhc1oErUhfA60pjD6ez8j34vCv1MKTLfw"></p>
<p>开源地址：<a href="https://github.com/PasteBar/PasteBarApp">https://github.com/PasteBar/PasteBarApp</a></p>
<p>官网：<a href="https://www.pastebar.app/">https://www.pastebar.app/</a></p>
<br />



<h2 id="文颜：适合微信公众号、今日头条、知乎等平台的Markdown排版工具-Mac平台"><a href="#文颜：适合微信公众号、今日头条、知乎等平台的Markdown排版工具-Mac平台" class="headerlink" title="文颜：适合微信公众号、今日头条、知乎等平台的Markdown排版工具 [Mac平台]"></a>文颜：适合微信公众号、今日头条、知乎等平台的Markdown排版工具 [Mac平台]</h2><p>「文颜」是一款全自动的文章排版美化工具，专为简化您的内容发布工作而设计。它可以将Markdown格式的文章快速转换为适合微信公众号、今日头条、知乎等平台的排版格式，从而省去因平台差异带来的繁琐调整。</p>
<ul>
<li>支持发布到多平台：公众号、知乎、今日头条、掘金等</li>
<li>支持代码高亮</li>
<li>支持公式</li>
<li>支持链接转脚注</li>
<li>支持识别<code>front matter</code>语法</li>
<li>即将支持：公众号主题样式模版</li>
<li>即将支持：公众号自定义样式</li>
</ul>
<p>开源地址：<a href="https://github.com/caol64/wenyan">https://github.com/caol64/wenyan</a></p>
<p>下载地址：<a href="https://apps.apple.com/cn/app/%E6%96%87%E9%A2%9C/id6670157335?mt=12">https://apps.apple.com/cn/app/%E6%96%87%E9%A2%9C/id6670157335?mt=12</a></p>
<br />

<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Obsidian-插件：-Folder-Note-在文件夹中创建无需折叠文件夹即可访问的笔记"><a href="#Obsidian-插件：-Folder-Note-在文件夹中创建无需折叠文件夹即可访问的笔记" class="headerlink" title="Obsidian 插件： Folder Note 在文件夹中创建无需折叠文件夹即可访问的笔记"></a>Obsidian 插件： Folder Note 在文件夹中创建无需折叠文件夹即可访问的笔记</h2><p> Folder Note 是一个 Obsidian 插件，它允许用户为文件夹创建和管理笔记，使得笔记内容的组织和检索变得更加直观和高效。插件的主要特点包括显示和管理文件夹笔记、支持三种不同的文件夹笔记方法（Inside-Folder、Outside-Folder、Index-File）、自动同步文件夹和笔记名称、以及自定义初始内容。 Folder Note 插件在提升笔记管理效率和增加可视化程度方面的很有用，推荐大家尝试使用。</p>
<p>开源地址： <a href="https://github.com/LostPaul/obsidian-folder-notes">https://github.com/LostPaul/obsidian-folder-notes</a></p>
<p>国内下载地址：<a href="https://pkmer.cn/products/plugin/pluginMarket/?folder-notes">下载安装</a></p>
<p>使用教程：<a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/readme/folder-notes_readme/">https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/readme/folder-notes_readme/</a></p>
<br />

<h2 id="kotaemon：开源的-RAG-文档聊天工具"><a href="#kotaemon：开源的-RAG-文档聊天工具" class="headerlink" title="kotaemon：开源的 RAG 文档聊天工具"></a>kotaemon：开源的 RAG 文档聊天工具</h2><p>kotaemon 是一个开源的 RAG 工具，提供了干净可定制的 UI，支持与文档进行基于 RAG 的问答。它对终端用户和开发者都很友好，终端用户可以使用简洁的 UI 进行 RAG 问答，支持多种 LLM API 提供商和本地 LLM；开发者可以使用它构建自己的 RAG 管道。该项目具有多种关键特性，如支持多用户登录、组织文件、协作和分享聊天，支持多种 LLM 和嵌入模型，具有混合 RAG 管道、多模态 QA 支持、先进的引文和文档预览、支持复杂推理方法、可配置的设置 UI 和可扩展性等。</p>
<p><a href="https://huggingface.co/spaces/cin-model/kotaemon-demo">Live Demo</a> | <a href="https://github.com/Cinnamon/kotaemon">Source Code</a></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202409081627827.png"></p>
<p>开源地址：<a href="https://github.com/Cinnamon/kotaemon">https://github.com/Cinnamon/kotaemon</a></p>
<br />

<h2 id="muAgent：由-KG-引擎驱动的创新代理框架"><a href="#muAgent：由-KG-引擎驱动的创新代理框架" class="headerlink" title="muAgent：由 KG 引擎驱动的创新代理框架"></a>muAgent：由 KG 引擎驱动的创新代理框架</h2><p>全新体验的 Agent 框架，将KG从知识获取来源直接升级为Agent编排引擎！基于 LLM+ EKG（Eventic Knowledge Graph 行业知识承载）驱动，协同 MultiAgent、FunctionCall、CodeInterpreter等技术，通过画布式拖拽、轻文字编写，让大模型在人的经验指导下帮助你实现各类复杂 SOP 流程。兼容现有市面各类 Agent 框架，同时可实现复杂推理、在线协同、人工交互、知识即用四大核心差异技术功能。这套框架目前在蚂蚁集团内多个复杂DevOps场景落地验证。</p>
<p><a href="https://github.com/codefuse-ai/CodeFuse-muAgent/blob/main/docs/resources/ekg-arch-zh.webp"><img data-src="https://github.com/codefuse-ai/CodeFuse-muAgent/raw/main/docs/resources/ekg-arch-zh.webp" alt="img"></a></p>
<p>完整文档见：<a href="https://codefuse.ai/zh-CN/docs/api-docs/MuAgent/overview/multi-agent">CodeFuse-muAgent</a> 更多<a href="https://codefuse.ai/zh-CN/docs/api-docs/MuAgent/connector/customed_examples">demo</a></p>
<p><strong>关键技术</strong></p>
<ul>
<li><p><strong>图谱构建</strong>：通过虚拟团队构建、场景意图划分，让你体验在线文档VS本地文档的差别；同时，文本语义输入的节点使用方式，让你感受有注释代码VS无注释代码的差别，充分体现在线协同的优势；面向海量存量文档（通用文本、流程画板等），支持文本智能解析、一键导入</p>
</li>
<li><p><strong>图谱资产</strong>：通过场景意图、事件流程、统一工具、组织人物四部分的统一图谱设计，满足各类SOP场景所需知识承载；工具在图谱的纳入进一步提升工具选择、参数填充的准确性，人物&#x2F;智能体在图谱的纳入，让人可加入流程的推进，可灵活应用于多人文本游戏</p>
</li>
<li><p><strong>图谱推理</strong>：相比其他Agent框架纯模型推理、纯人工编排的推理模式，让大模型在人的经验&#x2F;设计指导下做事，灵活、可控，同时面向未知局面，可自由探索，同时将成功探索经验总结、图谱沉淀，面向相似问题，少走弯路；整体流程唤起支持平台对接（规则配置）、语言触发，满足各类诉求</p>
</li>
<li><p><strong>调试运行</strong>：图谱编辑完成后，可视调试，快速发现流程错误、修改优化，同时面向调试成功路径，关联配置自动沉淀，减少模型交互、模型开销，加速推理流程；此外，在线运行中，我们提供全链路可视化监控</p>
</li>
<li><p><strong>记忆管理</strong>：统一消息池设计，支持各类场景所需分门别类消息投递、订阅，隔离且互通，便于多Agent场景消息管理使用；同时面向超长上下文，支持消息检索、排序、蒸馏，提升整体问答质量</p>
</li>
<li><p><strong>操作空间</strong>：遵循Swagger协议，提供工具注册、权限管理、统一分类，方便LLM在工具调用中接入使用；提供安全可信代码执行环境，同时确保代码精准生成，满足可视绘图、数值计算、图表编辑等各类场景诉求</p>
</li>
</ul>
<p>开源地址：<a href="https://github.com/codefuse-ai/CodeFuse-muAgent">https://github.com/codefuse-ai/CodeFuse-muAgent</a></p>
<br />

<h2 id="Claude-Dev：一款集成了Claude-3-5-Sonnet的VSCode-AI编程工具"><a href="#Claude-Dev：一款集成了Claude-3-5-Sonnet的VSCode-AI编程工具" class="headerlink" title="Claude Dev：一款集成了Claude 3.5 Sonnet的VSCode AI编程工具"></a>Claude Dev：一款集成了Claude 3.5 Sonnet的VSCode AI编程工具</h2><p>Claude Dev，一款在VSCode扩展插件商店中拥有3.4K Star的AI编程工具。该工具基于Claude 3.5 Sonnet，能够自动完成代码生成、项目管理、终端命令执行等复杂编程任务。它支持集成VSCode，具备实时跟踪、智能权限管理、互动式开发辅助等功能，并通过直观的GUI界面提升用户体验。Claude Dev旨在简化传统编程流程，使开发者能够更高效地构建游戏和应用程序。</p>
<p><img data-src="https://media.githubusercontent.com/media/saoudrizwan/claude-dev/main/demo.gif"></p>
<p>开源地址：<a href="https://github.com/saoudrizwan/claude-dev">https://github.com/saoudrizwan/claude-dev</a></p>
<br />

<h2 id="轻量又高性能的-SSH-工具IShell：AI加持，快人一步"><a href="#轻量又高性能的-SSH-工具IShell：AI加持，快人一步" class="headerlink" title="轻量又高性能的 SSH 工具IShell：AI加持，快人一步"></a>轻量又高性能的 SSH 工具IShell：AI加持，快人一步</h2><p>IShell 是一款为开发者和运维人员设计的 SSH 终端工具，它通过原生开发和底层 Socket 优化提供了卓越的性能，即使在弱网环境下也能保持流畅的使用体验。IShell 支持多种加密算法以确保数据安全，并提供了云同步功能以及一个直观的仪表盘来查看服务器状态。它还支持拖拽上传文件、本地终端操作以及 AI 指令功能，后者可以帮助用户快速获取命令建议。IShell 支持 Windows、Mac 和 Linux 平台，未来还将扩展到手机端。</p>
<p>IShell基础功能永久免费使用，支持离线使用。付费可以使用AI功能。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240908164442197.png"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/202409081647814.png"></p>
<p>官网：<a href="http://www.ishell.cc/">http://www.ishell.cc/</a></p>
<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于  <a href="https://github.com/starsight/TechWeekly">starsight&#x2F;TechWeekly (github.com)</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第61期</title>
    <url>/posts/35958.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如专为 GitHub 项目创建分享图像Socialify  、开源数据库设计与可视化工具ChartDB 、 AIToolly：发现和选择最佳人AI工具 、Void：全面隐私保护的开源 AI 代码编辑器 、 Cherry Studio：支持多模型的跨平台 AI 助手。此外，还推荐了Mini-Cover：简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面和 Yaak：简洁高效的现代 API 客户端，开源替代 Postman。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240924225509534.png" alt="🍮"></p>
<span id="more"></span>



<br />

<p>欢迎来到第61期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />



<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><h3 id="像小说一样品读-Linux-0-11-核心代码"><a href="#像小说一样品读-Linux-0-11-核心代码" class="headerlink" title="像小说一样品读 Linux 0.11 核心代码"></a>像小说一样品读 Linux 0.11 核心代码</h3><p> 该项目围绕 Linux 0.11 核心代码展开，提供了深入的源码分析，以帮助读者从根本上理解操作系统的设计与实现。文章通过生动的叙述风格，将技术性极强的操作系统概念转化为易于理解的讲解，涉及内核启动、内存管理、中断处理、进程调度等核心模块的源码讲解，并对每一部分进行详细分解。文章中还包含丰富的番外篇内容，探讨了某些权威书籍的错误之处以及读者在学习过程中的困惑。该项目是一个面向技术爱好者和开发者的学习资源，尤其适合对 Linux 内核有浓厚兴趣的读者</p>
<p><a href="https://mp.weixin.qq.com/s/tvbkGLfhDq03xxM-FZ4zuA">开篇词</a></p>
<ul>
<li><strong>第一部分：进入内核前的苦力活</strong><ul>
<li><a href="https://mp.weixin.qq.com/s/LIsqRX51W7d_yw-HN-s2DA">第1回 最开始的两行代码</a></li>
<li><a href="https://mp.weixin.qq.com/s/U-txDYt0YqLh5EeFOcB4NQ">第2回 自己给自己挪个地儿</a></li>
<li><a href="https://mp.weixin.qq.com/s/90QBJ-lP_-du2qQJxNF-Fw">第3回 做好最最基础的准备工作</a></li>
<li><a href="https://mp.weixin.qq.com/s/hStc-y-sabP-KwJUDUesTw">第4回 把自己在硬盘里的其他部分也放到内存来</a></li>
<li><a href="https://mp.weixin.qq.com/s/5s_nmrWRZbA_4mkNKOQ2Cg">第5回 进入保护模式前的最后一次折腾内存</a></li>
<li><a href="https://mp.weixin.qq.com/s/p1a6QxYZyMpJF__uBSE1Kg">第6回 先解决段寄存器的历史包袱问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/S5zarr9BmLhUHAmdmeNypA">第7回 六行代码就进入了保护模式</a></li>
<li><a href="https://mp.weixin.qq.com/s/ssQKFMehxZxWT9i6mdRtXg">第8回 烦死了又要重新设置一遍 idt 和 gdt</a></li>
<li><a href="https://mp.weixin.qq.com/s/q2wU9IbX54t_GAuc9V5r7A">第9回 Intel 内存管理两板斧：分段与分页</a></li>
<li><a href="https://mp.weixin.qq.com/s/ISyaX5zPWRw_d-9zvZUPUg">第10回 进入 main 函数前的最后一跃！</a></li>
<li><a href="https://mp.weixin.qq.com/s/8bP3feeF_A13j7ysWur_JQ">第一部分总结与回顾</a></li>
</ul>
</li>
<li><strong>第二部分：大战前期的初始化工作</strong><ul>
<li><a href="https://mp.weixin.qq.com/s/kYBrMgHt7C9EmAcwJIPIxg">第11回 整个操作系统就20几行代码</a></li>
<li><a href="https://mp.weixin.qq.com/s/eoBFcgm0QrHOVi_WoS7PwA">第12回 管理内存前先划分出三个边界值</a></li>
<li><a href="https://mp.weixin.qq.com/s/_rTmjHIDCV9ADiJlfo5B3g">第13回 主内存初始化 mem_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/sFp_388qRncB-jpJeRzCGQ">第14回 中断初始化 trap_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/pIbVY1XPCktxGogc4lI1Bw">第15回 块设备请求项初始化 blk_dev_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/yIrzEWUUuZC9OsiuU_lOaw">第16回 控制台初始化 tty_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/y26MMfj8pP5PmbKDZBT5-A">第17回 时间初始化 time_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/j4FYWUSX_2gpDb_h4vEFqQ">第18回 进程调度初始化 sched_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/X8BSbf1qShS11_fzfyOhTg">第19回 缓冲区初始化 buffer_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/803C9jHxIe42i9BrNzEvPA">第20回 硬盘初始化 hd_init</a></li>
<li><a href="https://mp.weixin.qq.com/s/Hf9B1ww1wFxiUDkWb0obeQ">第二部分总结与回顾</a></li>
</ul>
</li>
<li><strong>第三部分：一个新进程的诞生</strong><ul>
<li><a href="https://mp.weixin.qq.com/s/H_OCZ2ZtGHWHge_rYKCkJw">第21回 新进程诞生全局概述</a></li>
<li><a href="https://mp.weixin.qq.com/s/AVl6R2N9d_sldkhfvC6aEw">第22回 从内核态切换到用户态</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sf9vV7RCnVDlBKXx5jXs1Q">第23回 如果让你来设计进程调度</a></li>
<li><a href="https://mp.weixin.qq.com/s/yFre8Qv_ZCtjRkTS49n6rw">第24回 从一次定时器滴答来看进程调度</a></li>
<li><a href="https://mp.weixin.qq.com/s/rYBSH_AZDwgc8knSKDSSxA">第25回 通过 fork 看一次系统调用流程</a></li>
<li><a href="https://mp.weixin.qq.com/s/8cy-xX3ekeqHelrFcYFkvw">第26回 fork 中进程基本信息的复制</a></li>
<li><a href="https://mp.weixin.qq.com/s/d2pHFSbTLb-nv2C_RfKlVA">第27回 fork 中进程内存规划的问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/V_Ryxox3iDCO994FzkSFfA">第三部分总结与回顾</a></li>
<li><a href="https://mp.weixin.qq.com/s/JzCy_4RPhy17_G6KbY3f2g">第28回 番外篇 - 我居然会认为权威书籍写错了…</a></li>
<li><a href="https://mp.weixin.qq.com/s/NFUgJ4-hIyrs1sQr8AUCvA">第29回 番外篇 - 让我们一起来写本书？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pdnmys_hGoToZN193rfnoQ">第30回 番外篇 - 写时复制就这么几行代码</a></li>
</ul>
</li>
<li><strong>第四部分：shell 程序的到来</strong><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502161&idx=1&sn=219186a1e587f40308515852d293aaf4&chksm=c2c5b3fcf5b23aead170092d4042abd54b272694cbaac3f750eb3adea584ee29653c72ad2915&scene=21#wechat_redirect">第31回 | 拿到硬盘信息</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502181&idx=1&sn=b6dcbd1d2cf930002852008a1c4e6a65&chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&scene=21#wechat_redirect">第32回 | 加载根文件系统</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502230&idx=1&sn=44e023bf0b9b37261e35a6e3722bc57f&chksm=c2c5b33bf5b23a2d10a9dd36606c497f41a1c3dced57845ce7ef12741a348fab82beba462a8a&scene=21#wechat_redirect">第33回 | 打开终端设备文件</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502269&idx=1&sn=19f6831de5bac0d8a588b80757dbb1f4&chksm=c2c5b310f5b23a0633df6a75e36f4dae515e9d9aee1fa046888573e3d60e62752612edae536a&scene=21#wechat_redirect">第34回 | 进程2的创建</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502475&idx=1&sn=4fcdbaa03bf6a1ca04db4013309c6aa3&chksm=c2c5b026f5b2393049efca68c429df5038fa0f317eea79fbd9ec2c661c3ec12b47a0701376a7&scene=21#wechat_redirect">第35回 | execve 加载并执行 shell 程序</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502511&idx=1&sn=eacddbb11dd2402c561a611f708ee045&chksm=c2c5b002f5b23914ccd645d94bdc59e0322776f71f41e6744fddeca2bfa027d12a25ec6bfc8a&scene=21#wechat_redirect">第36回 | 缺页中断</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502581&idx=1&sn=df3f2c19ce511ac24145091892f47837&chksm=c2c5b058f5b2394ee095d679071b43c23853dc86d5cfd4cc961568643110ab734f635b899984&scene=21#wechat_redirect">第37回 | shell 程序跑起来了</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502613&idx=1&sn=d7e85595323d3de138e5ac52bf8e61dd&chksm=c2c5b1b8f5b238ae8785f45bf83434839689e7e5a697026d9ebde5738f11a83c4379a16c349f&scene=21#wechat_redirect">第38回 | 操作系统启动完毕</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502498&idx=1&sn=01cf816694f74ca8437374a9aa23ab64&chksm=c2c5b00ff5b23919c43ac96a38bc8b09f42ea17f92ea933157db3e7f0c77bb876bf7d0524afa&scene=21#wechat_redirect">第39回 | 番外篇 - Linux 0.11 内核调试</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502517&idx=1&sn=d6a20fb6ad50da584ac32e60823a1834&chksm=c2c5b018f5b2390e690c465aa35d822d14a23a2b76587303e9374aca431a718e1b104569efe4&scene=21#wechat_redirect">第40回 | 番外篇 - 为什么你怎么看也看不懂</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502650&idx=1&sn=ad947d70d372a1bc46741c459fd0ef9a&chksm=c2c5b197f5b23881a5e61c5581300beb4b3f1db8cab79eabec22fd847f1cdc0e11d3a713fd9f&scene=21#wechat_redirect">第四部分总结与回顾</a></li>
</ul>
</li>
<li><strong>第五部分：从一个命令的执行看操作系统各模块的运作</strong><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502821&idx=1&sn=0ffa47028dfa013ead148f06d90fbb33&chksm=c2c5b148f5b2385e7d3f213517eb387ff85a1d94977788a2558e31194c5dcd0afb003c98ecaf&scene=21#wechat_redirect">第41回 | 番外篇 - 跳票是不可能的</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502876&idx=1&sn=2c34491abd6ea14c9c7ccc3d2d9827c1&chksm=c2c5b6b1f5b23fa7bdf9c3e2bf811b84da937d30a2c9825ceba8a57c2c3e8e157dedae0bfc8d&scene=21#wechat_redirect">第42回 | 用键盘输入一条命令</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247502944&idx=1&sn=cf2601b43a4bc3f89d7a517cbf7fd588&chksm=c2c5b6cdf5b23fdb306af852e9293bb64df019bffa3c403e6fa59b856b7bddd77a42e5fc75eb&scene=21#wechat_redirect">第43回 | shell 程序读取你的命令</a></li>
<li><a href="https://mp.weixin.qq.com/s/HFQL5d-C24DKjQbYAQfl8g">第44回 | 进程的阻塞与唤醒</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247503139&idx=1&sn=652316c29be5ba983fbb658ce58443d8&chksm=c2c5b78ef5b23e980870ff66f066a624f9a5d61bd73f550d5579e745f60335dfb489dcf977d8&scene=21#wechat_redirect">第45回 | 解析并执行 shell 命令</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247503204&idx=1&sn=e00ee5e3584a7ecfaaec47ccf63c0555&chksm=c2c5b7c9f5b23edfd17396399772549674b5233add6062c4d236d4727650b3bd97742a202967&scene=21#wechat_redirect">第46回 | 读硬盘数据全流程</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247503228&idx=1&sn=e73ea3c148ecb7a15c9ef93b36b8a5cb&chksm=c2c5b7d1f5b23ec7f92fd29e2fe179d3122ed5180fb8054a0859afa1391c5c4314cf8c05ba45&scene=21#wechat_redirect">第47回 | 读取硬盘数据的细节</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247503287&idx=1&sn=62e5c9ea5142960a4cb02e18e2a6bdb3&chksm=c2c5b71af5b23e0cfaeb5151397436f213e82ffe0673b8a841b7b557815d377ca9ae563f19d0&scene=178&cur_album_id=2123743679373688834#rd">第48回 | 信号</a></li>
<li><a href="https://mp.weixin.qq.com/s/eWrNCtkirUu-1YsetR30Kg">操作系统大完结</a></li>
<li><a href="https://mp.weixin.qq.com/s/UJ9llP9TVxruhIC9jj-Q1g">我的第一本数出版了</a></li>
</ul>
</li>
</ul>
<img data-src="https://socialify.git.ci/dibingfa/flash-linux0.11-talk/image?description=1&forks=1&language=1&name=1&owner=1&stargazers=1&theme=Light" alt="flash-linux0.11-talk" width="640" height="320" />

<p>开源地址： <a href="https://github.com/dibingfa/flash-linux0.11-talk">https://github.com/dibingfa/flash-linux0.11-talk</a></p>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="Socialify-：专为-GitHub-项目创建分享图像"><a href="#Socialify-：专为-GitHub-项目创建分享图像" class="headerlink" title="Socialify ：专为 GitHub 项目创建分享图像"></a>Socialify ：专为 GitHub 项目创建分享图像</h2><p>Socialify 是一个用于生成可分享项目图像的工具，专为 GitHub 项目设计。它允许用户自定义项目的视觉展示，支持添加项目名称、描述、徽章、图标等元素，提供多种字体和背景图案选择。生成的图像可以用于项目 README 文件、社交媒体等场景中，通过实时数据动态更新徽章，确保信息的最新性。用户可以将图像下载为 <code>.png</code>、<code>.jpeg</code> 或 <code>.webp</code> 格式，还可以通过命令行工具将图像自动上传到多个项目中。该项目适用于开发者，帮助其项目在社交平台上更好地推广和展示。</p>
<img data-src="https://socialify.git.ci/wei/socialify/image?description=1&forks=1&language=1&name=1&owner=1&pattern=Charlie%20Brown&stargazers=1&theme=Light" alt="socialify" width="640" height="320" />

<p>官网：<a href="https://github.com/wei/socialify">https://github.com/wei/socialify</a></p>
<br />



<h2 id="ChartDB：开源数据库设计与可视化工具"><a href="#ChartDB：开源数据库设计与可视化工具" class="headerlink" title="ChartDB：开源数据库设计与可视化工具"></a>ChartDB：开源数据库设计与可视化工具</h2><p>ChartDB 是一个专注于数据库结构设计和可视化的工具，支持 MySQL、PostgreSQL、SQLite、MariaDB 和 MSSQL 等主流数据库。该工具允许用户通过简单的 SQL 查询实时生成数据库的图示，并且支持导出图表以进行数据库的进一步设计或迁移。其开源性质为开发者提供了灵活性，用户可根据需求定制和扩展工具功能。使用 React 和 TypeScript 开发，ChartDB 支持现代开发流程，并且通过其直观的用户界面提升了数据库管理和设计的效率。该工具适合数据库开发者、架构师和 DevOps 工程师，帮助他们快速生成 ERD（实体关系图）并执行数据库迁移任务。</p>
<p><a href="https://discord.gg/QeFwyWSKwC">Community</a> • <a href="https://www.chartdb.io/">Website</a> • <a href="https://app.chartdb.io/examples">Demo</a></p>
<p><img data-src="https://socialify.git.ci/chartdb/chartdb/image?description=1&forks=1&language=1&name=1&owner=1&stargazers=1&tab=coc-ov-file?language=1&theme=Light" alt="chartdb"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240925231236402.png"></p>
<p>开源地址： <a href="https://github.com/chartdb/chartdb">https://github.com/chartdb/chartdb</a></p>
<br />

<h2 id="AIToolly：发现和选择最佳人AI工具"><a href="#AIToolly：发现和选择最佳人AI工具" class="headerlink" title="AIToolly：发现和选择最佳人AI工具"></a>AIToolly：发现和选择最佳人AI工具</h2><p>AIToolly 是一个专门用于收集和展示人工智能工具及应用的平台，用户可以通过该平台轻松查找各种类别的 AI 工具，如图像生成、视频编辑、编程、电子商务、教育、客户支持等。平台汇集了广泛的 AI 应用，从生产力工具到创意生成器，应有尽有。用户可以根据不同的应用场景，如市场营销、研究、医疗等，找到相应的 AI 解决方案。每个工具都有详细的介绍，用户可以根据自己的需求选择最合适的工具来提高工作效率或进行项目开发。此外，平台上还定期更新最新的 AI 工具，并提供一些使用技巧和用户指南。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240925231605119.png"></p>
<p>在线网站：<a href="https://aitoolly.com/zh">https://aitoolly.com/zh</a></p>
<br />

<h2 id="Void：全面隐私保护的开源-AI-代码编辑器"><a href="#Void：全面隐私保护的开源-AI-代码编辑器" class="headerlink" title="Void：全面隐私保护的开源 AI 代码编辑器"></a>Void：全面隐私保护的开源 AI 代码编辑器</h2><p>Void 是一个开源的 AI 驱动代码编辑器，是 Cursor 的替代品，旨在为开发者提供强大的代码自动补全、智能搜索等 AI 功能，同时保障用户对数据的完全控制。该工具基于 VS Code 构建，用户可以无缝转移原有的主题、快捷键和设置。Void 支持与多种大型语言模型（LLM）集成，用户可以选择在本地托管模型，或直接与 GPT、Claude、Gemini 等模型通信，避免依赖第三方服务。 </p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240925232003472.png"></p>
<p>在线网站：<a href="https://voideditor.com/">https://voideditor.com/</a></p>
<p>开源地址：<a href="https://github.com/voideditor/void">https://github.com/voideditor/void</a></p>
<br />

<h2 id="Cherry-Studio：支持多模型的跨平台-AI-助手"><a href="#Cherry-Studio：支持多模型的跨平台-AI-助手" class="headerlink" title="Cherry Studio：支持多模型的跨平台 AI 助手"></a>Cherry Studio：支持多模型的跨平台 AI 助手</h2><p>Cherry Studio 是一款专为提升工作和学习效率而设计的多模型 AI 助手，支持国内外多款最先进的大语言模型。用户可以在 Windows、macOS（包括 Intel 和 Apple Silicon 版本）以及 Linux 平台上使用该工具。Cherry Studio 的安装过程非常简单，无需使用 Docker 或命令行，用户只需点击几下鼠标即可快速安装。该工具具有响应速度快的特点，几秒内即可完成 AI 对话。Cherry Studio 还允许用户轻松切换不同的 AI 模型，以满足不同的需求。</p>
<p><img data-src="https://private-user-images.githubusercontent.com/26830614/369796032-554aa31b-87b6-49fe-877d-af313e1608b0.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjcyNzg2NTQsIm5iZiI6MTcyNzI3ODM1NCwicGF0aCI6Ii8yNjgzMDYxNC8zNjk3OTYwMzItNTU0YWEzMWItODdiNi00OWZlLTg3N2QtYWYzMTNlMTYwOGIwLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA5MjUlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwOTI1VDE1MzIzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWM4ZmM3Mjk1ODM1NzFjMmNiZjVmYWRjNGJjMzdlYTExMDk3YjZiZTg3ZGE1M2QyOGU1ZmQwYmUzNzNkZDU5MTMmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0._0XctRIT2B0PGGEg54WWV4XNhgho_d3O9o6-nUFbv80"></p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240925233359741.png"></p>
<p>下载地址：<a href="https://cherry-ai.com/">https://cherry-ai.com/</a></p>
<p>开源地址：<a href="https://github.com/kangfenmao/cherry-studio">https://github.com/kangfenmao/cherry-studio</a></p>
<br />



<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Mini-Cover：简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面"><a href="#Mini-Cover：简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面" class="headerlink" title="Mini-Cover：简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面"></a>Mini-Cover：简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面</h2><p>Mini-Cover是一个开源的简洁的在线生成封面网站，专为博客、短视频、社交媒体等生成个性化封面。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240924230440070.png"></p>
<p>开源地址： <a href="https://github.com/JLinMr/Mini-Cover">https://github.com/JLinMr/Mini-Cover</a></p>
<p>在线使用地址：<a href="https://cover.ruom.top/">https://cover.ruom.top/</a> </p>
<br />



<h2 id="Yaak：简洁高效的现代-API-客户端，开源替代-Postman"><a href="#Yaak：简洁高效的现代-API-客户端，开源替代-Postman" class="headerlink" title="Yaak：简洁高效的现代 API 客户端，开源替代 Postman"></a>Yaak：简洁高效的现代 API 客户端，开源替代 Postman</h2><p>Yaak 是一个面向现代开发者的跨平台 API 客户端，支持 REST、GraphQL 和 gRPC 请求。它提供了简洁的用户界面，同时包含诸如多环境变量、自动补全、可视化响应预览、批量发送请求等功能，帮助开发者高效管理和测试 API。Yaak 支持从 Postman、Insomnia、OpenAPI 或 cURL 导入请求，并允许用户将请求复制为可运行的 cURL 命令。所有数据存储在本地，确保用户隐私与安全。Yaak 已成为开源工具，用户可以免费使用并根据需求进行扩展。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20240925235233606.png"></p>
<p>官网：<a href="https://yaak.app/">https://yaak.app/</a></p>
<p>开源地址：<a href="https://github.com/yaakapp">https://github.com/yaakapp</a></p>
<br />

<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p>🎉 本文同步更新于 <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
  <entry>
    <title>网上冲浪周刊第63期</title>
    <url>/posts/39201.html</url>
    <content><![CDATA[<p>欢迎阅读本期技术资讯！我们为您推荐了一些有趣的工具，如开源 PDF 文献翻译工具PDFMathTranslate  、AB Download Manager：加速下载与文件管理的开源工具、PMRF：一种实现高质量图像修复的新型算法、强大的开源OCR工具Surya 。此外，还推荐了Luxirty Search : 无内容农场的搜索引擎、Lemuroid：开源多合一游戏模拟器，让Android设备变身游戏机、ChatMemOllama：开源微信公众号聊天机器人。</p>
<p> <img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20241011224826494.png" alt="绍兴2024.10"></p>
<span id="more"></span>



<br />

<p>欢迎来到第63期 ！😄</p>
<p>期待您通过RSS订阅我们：<a href="https://www.lifeee.top//atom.xml">https://www.lifeee.top//atom.xml</a></p>
<br />



<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><p><a href="https://juejin.cn/post/7411812014047166475">Flutter&amp;Rust#01 | 突破能力瓶颈Rust 是和 C++ 同一级别的系统级编程语言，而 Flutter 是</a> : 文章讨论了Rust和Flutter结合使用的优势，特别是在处理图片处理、音视频处理、复杂解析、AI算法等复杂运算时的能力。作者指出，Flutter的Dart语言在某些高性能场景下可能力不从心，但可以通过FFI调用Rust代码来实现功能，从而提升性能。文章详细介绍了环境准备、安装flutter_rust_bridge桥接工具、构建应用产物、Flutter&amp;Rust项目解读、增加Rust项目功能、在已有项目中集成Rust等步骤。作者还提供了具体的代码示例和项目结构说明，帮助读者理解如何在Flutter项目中集成Rust代码，并利用Rust的强大性能。</p>
</li>
<li><p><a href="https://juejin.cn/post/7420980084361625600">Tauri2.0 发布！不止于桌面！</a>: Tauri 2.0的发布带来了对移动端开发的支持，这标志着Tauri从一个专注于桌面应用开发的框架，转变为一个能够覆盖桌面和移动平台的全平台开发工具。文章讨论了Tauri的跨平台能力、轻量化特性、对开发者友好的体验，以及在移动端的性能表现。作者强调了Tauri在保持应用体积小、性能好的同时，如何通过统一的开发体验降低开发者的学习和维护成本。文章还提到了Tauri团队对移动端支持的持续优化，以及Tauri在兼容性和稳定性方面的潜力。</p>
</li>
<li><p><a href="https://juejin.cn/post/7342148728134074380">图解Nestjs - 适合中国宝宝的入门指导Nestjs很好用，但刚入门时也挺让人迷糊，本文会尽量简单的展示Nestjs)</a>:  文章通过构建一个“宝可梦大全”服务的例子，详细解释了NestJS框架中的模块（Module）概念、控制器（Controller）和服务（Service）的工作原理，以及它们如何互相协作。文章介绍了如何定义模块、控制器和服务，以及如何通过依赖注入（Dependency Injection）来实现模块间的通信。作者还讨论了模块的输入和输出，解释了Provider和Import的区别，并提供了模块化开发的最佳实践。最后，文章总结了如何通过理解NestJS的模块相互作用来掌握框架的使用。</p>
</li>
</ul>
<br />

<br />

<h1 id="有趣的工具"><a href="#有趣的工具" class="headerlink" title="有趣的工具"></a>有趣的工具</h1><h2 id="PDFMathTranslate-开源-PDF-文献翻译工具，保留公式和图表，支持双语对照"><a href="#PDFMathTranslate-开源-PDF-文献翻译工具，保留公式和图表，支持双语对照" class="headerlink" title="PDFMathTranslate 开源 PDF 文献翻译工具，保留公式和图表，支持双语对照"></a>PDFMathTranslate 开源 PDF 文献翻译工具，保留公式和图表，支持双语对照</h2><p>PDFMathTranslate是一个开源项目，旨在通过深度学习和字体规则，自动翻译PDF格式的科学论文，并支持双语比较。该工具不仅能够翻译整篇文档，还可以指定翻译的页码和语言，同时保持公式和图形的原始布局。用户可通过简单的命令行指令进行操作，支持正则表达式指定需要保留的公式字体和字符。</p>
 <img data-src="https://socialify.git.ci/Byaidu/PDFMathTranslate/image?description=1&descriptionEditable=PDFMathTranslate%20%E5%BC%80%E6%BA%90%20PDF%20%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7%EF%BC%8C%E4%BF%9D%E7%95%99%E5%85%AC%E5%BC%8F%E5%92%8C%E5%9B%BE%E8%A1%A8%EF%BC%8C%E6%94%AF%E6%8C%81%E5%8F%8C%E8%AF%AD%E5%AF%B9%E7%85%A7&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="PDFMathTranslate" width="640" height="320" />

<p>官网： <a href="https://github.com/Byaidu/PDFMathTranslate">https://github.com/Byaidu/PDFMathTranslate</a></p>
<br />



<h2 id="AB-Download-Manager：加速下载与文件管理的开源工具"><a href="#AB-Download-Manager：加速下载与文件管理的开源工具" class="headerlink" title="AB Download Manager：加速下载与文件管理的开源工具"></a>AB Download Manager：加速下载与文件管理的开源工具</h2><p>AB Download Manager是一个多平台的下载管理工具，支持Windows和Linux系统。它提供更快的下载速度、队列和调度功能，及浏览器扩展，以便更好地管理下载文件。应用拥有现代化的用户界面，并支持深色和浅色主题</p>
<img data-src="https://socialify.git.ci/amir1376/ab-download-manager/image?description=1&descriptionEditable=AB%20Download%20Manager%EF%BC%9A%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="ab-download-manager" width="640" height="320" />

<p>开源地址：  <a href="https://github.com/amir1376/ab-download-manager">https://github.com/amir1376/ab-download-manager</a></p>
<br />

<h2 id="PMRF：一种实现高质量图像修复的新型算法"><a href="#PMRF：一种实现高质量图像修复的新型算法" class="headerlink" title="PMRF：一种实现高质量图像修复的新型算法"></a>PMRF：一种实现高质量图像修复的新型算法</h2><p>PMRF（Posterior-Mean Rectified Flow）是一种图像修复算法，它通过多任务图像恢复、降低图像失真和提升感知质量，以及应对复杂的图像退化问题，表现出色。PMRF结合了多尺度特征提取和感知损失优化技术，适用于医学图像恢复、文化遗产保护、面部修复和智能监控等领域。文章还提供了PMRF的GitHub地址和在线Demo体验链接。</p>
<p>[<a href="https://arxiv.org/abs/2410.00418">Paper</a>] [<a href="https://pmrf-ml.github.io/">Project Page</a>] [<a href="https://huggingface.co/spaces/ohayonguy/PMRF">Demo</a>]</p>
<p><img data-src="https://socialify.git.ci/ohayonguy/PMRF/image?description=1&descriptionEditable=PMRF%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E9%AB%98%E8%B4%A8%E9%87%8F%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E6%96%B0%E5%9E%8B%E7%AE%97%E6%B3%95&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="PMRF"></p>
<p>开源地址：<a href="https://github.com/ohayonguy/PMRF">https://github.com/ohayonguy/PMRF</a></p>
<p>在线Demo：<a href="https://huggingface.co/spaces/ohayonguy/PMRF">https://huggingface.co/spaces/ohayonguy/PMRF</a></p>
<br />



<h2 id="强大的开源OCR工具Surya"><a href="#强大的开源OCR工具Surya" class="headerlink" title="强大的开源OCR工具Surya"></a>强大的开源OCR工具Surya</h2><p>Surya是一个性能卓越的开源OCR工具，尤其以表格识别功能著称。它能够识别表格的行、列、单元格，并且支持复杂布局和多语言识别，包括中文、日文、韩文、阿拉伯文等。Surya的优势在于其高性能的识别能力，可商用的开源许可，跨平台支持，以及活跃的社区和开发者支持。</p>
<p>安装及使用方法可以查看 <a href="https://github.com/VikParuchuri/surya#installation">https://github.com/VikParuchuri/surya#installation</a></p>
<p> <img data-src="https://socialify.git.ci/VikParuchuri/surya/image?description=1&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="surya"></p>
<p>开源地址： <a href="https://github.com/VikParuchuri/surya">https://github.com/VikParuchuri/surya</a></p>
<br />

 

<br />



<h1 id="宝藏信息"><a href="#宝藏信息" class="headerlink" title="宝藏信息"></a>宝藏信息</h1><h2 id="Luxirty-Search-无内容农场的搜索引擎"><a href="#Luxirty-Search-无内容农场的搜索引擎" class="headerlink" title="Luxirty Search : 无内容农场的搜索引擎"></a>Luxirty Search : 无内容农场的搜索引擎</h2><p>Luxirty Search是一个新开发的搜索引擎，旨在解决垃圾网页和广告泛滥的问题。该工具基于Google的搜索引擎，加入了内置的内容农场屏蔽功能，使搜索结果更加干净和简洁。用户可以通过一系列优化功能，如提高特定网站的搜索权重，简化搜索流程。</p>
<p><strong>特性&amp;功能</strong></p>
<ol>
<li>内置内容农场屏蔽，包括csdn、华x云、百度云智能、腾讯云开发者等seo网站，以及一些 stackoverflow 中文翻译站。</li>
</ol>
<p>Note</p>
<p>你可以在 <a href="https://github.com/KoriIku/luxirty-search/blob/main/docs/block_list.txt">&#x2F;docs&#x2F;block_list.txt</a>中查看完整的屏蔽名单。</p>
<ol>
<li>点击<code>For Program</code>一键拉高 GitHub、Stackoverflow、v2ex、cnblog 权重，免去手打 site: 的麻烦。</li>
<li>一键搜索 v2ex 、 Raddit</li>
<li>内置广告屏蔽、跟踪链接移除。</li>
</ol>
<p><strong>与 uBlackList, Hit by Hidden 等工具的区别</strong></p>
<p>这些工具在前端屏蔽搜索结果，也就是等到内容农场已经出现在搜索结果中，再将其删除或隐藏。</p>
<p>而 Luxirty Search 通过配置 Annotations 让 Google 直接屏蔽垃圾网站，服务器在执行搜索时就已经将网站排除，可以理解为内置多条 ‘-site:domain.com’ 。</p>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20241011222342301.png"></p>
<p><img data-src="https://socialify.git.ci/KoriIku/luxirty-search/image?description=1&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="luxirty-search"></p>
<p>在线地址：<a href="https://search.luxirty.com/">https://search.luxirty.com/</a></p>
<p>开源地址：<a href="https://github.com/KoriIku/luxirty-search">https://github.com/KoriIku/luxirty-search</a></p>
<h2 id="Lemuroid：开源多合一游戏模拟器，让Android设备变身游戏机"><a href="#Lemuroid：开源多合一游戏模拟器，让Android设备变身游戏机" class="headerlink" title="Lemuroid：开源多合一游戏模拟器，让Android设备变身游戏机"></a>Lemuroid：开源多合一游戏模拟器，让Android设备变身游戏机</h2><p>Lemuroid是一个基于Libretro的开源多合一游戏模拟器，可以在Android设备上运行。Lemuroid支持多种游戏机的模拟，如NES、GBA、3DS、PSP等，提供了即时存档、本地多人游戏、自定义按键等功能。模拟器的特点包括支持Android TV、自动保存和恢复游戏状态、ROM扫描和索引、优化的触控控制、快速保存&#x2F;加载、支持压缩ROM文件、显示模拟、游戏手柄支持、本地多人游戏、倾斜输入、可自定义触控控制以及云存储同步等。</p>
<p><strong>特点：</strong></p>
<ul>
<li>• 支持Android TV</li>
<li>• 自动保存和恢复游戏状态</li>
<li>• ROM扫描和索引</li>
<li>• 优化的触控控制</li>
<li>• 快速保存&#x2F;加载</li>
<li>• 支持压缩ROM文件</li>
<li>• 显示模拟（LCD&#x2F;CRT）</li>
<li>• 游戏手柄支持</li>
<li>• 本地多人游戏</li>
<li>• 倾斜输入</li>
<li>• 可自定义触控控制（大小和位置）</li>
<li>• 云存储同步</li>
<li>• 高清模式</li>
</ul>
<p><img data-src="https://lifeee-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/image-20241011002108147.png"></p>
<p><img data-src="https://socialify.git.ci/Swordfish90/Lemuroid/image?description=1&forks=1&issues=1&name=1&owner=1&pulls=1&stargazers=1&tab=readme-ov-file?language=1&theme=Light" alt="Lemuroid"></p>
<p>开源地址：<a href="https://github.com/Swordfish90/Lemuroid">https://github.com/Swordfish90/Lemuroid</a>   </p>
<br />



<h2 id="ChatMemOllama：开源微信公众号聊天机器人"><a href="#ChatMemOllama：开源微信公众号聊天机器人" class="headerlink" title="ChatMemOllama：开源微信公众号聊天机器人"></a>ChatMemOllama：开源微信公众号聊天机器人</h2><p>ChatMemOllama是一个开源的微信公众号聊天机器人，它使用Ollama提供的本地AI模型进行对话，并通过mem0进行记忆管理，以提供连贯的对话体验。该项目支持多用户对话，并快速响应。</p>
<p><strong>功能特性</strong></p>
<ul>
<li><strong>本地 AI 模型</strong>：使用 Ollama 提供的本地 AI 模型进行对话。</li>
<li><strong>记忆管理</strong>：通过 mem0 管理用户的聊天记忆，提供更连贯的对话体验。</li>
<li><strong>多用户支持</strong>：支持多个用户同时进行对话（测试版存在逻辑问题）。</li>
<li><strong>快速响应</strong>：尽量在 5 秒内回复用户，超时情况下会提示用户等待。</li>
</ul>
<p><img data-src="https://socialify.git.ci/LIghtJUNction/ChatMemOllama/image?description=1&forks=1&issues=1&language=1&name=1&owner=1&pulls=1&stargazers=1&theme=Light" alt="ChatMemOllama"></p>
<p>开源地址： <a href="https://github.com/LIghtJUNction/ChatMemOllama">https://github.com/LIghtJUNction/ChatMemOllama</a></p>
<br />

<br />

<br />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>百闻不如一见，百见不如一试。</p>
<p> 🎉 本文同步更新于 <a href="https://github.com/starsight/TechWeekly">https://github.com/starsight/TechWeekly</a></p>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲浪</tag>
      </tags>
  </entry>
</search>
